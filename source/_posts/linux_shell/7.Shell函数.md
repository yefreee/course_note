---
title: Shell函数
date: 2023-04-18 11:31:23
tags:
---

编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。

函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。

## 基本脚本函数

### 创建函数、调用函数

1. 第一种方式采用function关键字，后面跟函数名以及代码块

    ```bash
    function 函数名 {
        函数体
    }
    ```

    name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。

2. 第二种方式更接近其他编程语言的定义方式

    ```bash
    函数名() {
        函数体
    }
    ```

```bash
#!/bin/bash

greet
function greet {
    echo "Hello, World!"
}
greet

```

- 当函数在被定义之前使用的话会产生错误信息

```bash
#!/bin/bash
# using a function located in the middle of a script
count=1
echo "This line comes before the function definition"
function func1 {
echo "This is an exam,rple of a function"
}
while [ $count -le 5 ]
do
func1
count=$[ $count + 1 ]
done
echo "This is the end of the loop"
func2
echo "Now this is the end of the script"
function func2 {
echo "This is an example of a function"
}
```

## 返回值

`bash shell`会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成`退出状态码`。

### 默认退出状态码

默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量`$?`来确定函数的退出状态码。

```bash
#!/bin/bash

function greet {
  # ls -l badfile
    echo "Hello, World!"
  ls -l badfile
}

greet
echo "the exit status is: $?"
```

如果注释掉第一个`ls`命令，由于函数的最后一条语句`echo`运行成功，该函数的退出状态是`0`，尽管前一个命令没有运行成功。

### 使用return命令

`bash shell`使用`return`命令来退出函数并返回特定的退出状态码。`return`命令允许指定一个整数值来定义函数的`退出状态码`

```bash
#!/bin/bash
# using the return command in a function
function dbl {
read -p "Enter a value: " value
echo "doubling the value"
return $[ $value * 2 ]
}
dbl
echo "The new value is $?"
```

`dbl`函数会将`$value`变量中用户输入的值翻倍，然后用`return`命令返回结果。脚本用`$?`变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：

1. 函数一结束就取返回值
2. 退出状态码必须是0~255

如果在用`$?`变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，`$?`变量会返回执行的最后一条命令的退出状态码。
第二个问题界定了返回值的取值范围。由于退出状态码必须`小于256`，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。

```shell
ubuntu@sh:~$ bash test.sh
Enter a value: 200
doubling the value
The new value is 144
```

### 使用函数输出

正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：

```bash
result=`dbl`
```

这个命令会将`dbl`函数的输出赋给`$result`变量。

```bash
#!/bin/bash
# using the echo to return a value
function dbl {
read -p "Enter a value: " value
echo $[ $value * 2 ]
}
result=`dbl`
echo "The new value is $result"
```

```shell
ubuntu@sh:~$ bash test.sh
Enter a value: 200
value = 400
ubuntu@sh:~$
```

## 函数中使用变量

### 向函数传递参数

bash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。

函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`等定义。也可以用特殊变量`$#`来判断传给函数的参数数目。

```bash
#!/bin/bash

# 定义一个函数，接收两个参数并输出它们
function print_two_args {
    echo "第一个参数是：$1"
    echo "第二个参数是：$2"
}

# 调用函数，并传递两个参数
print_two_args "hello" "world"
```

```shell
第一个参数是：hello
第二个参数是：world
```

### 在函数中处理变量

作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。

### 全局变量

对于全局变量，可以直接在函数中使用或修改。例如：

```bash
#!/bin/bash

# 定义全局变量
name="Tom"

# 定义函数
my_func() {
  echo "Hello, $name"
  name="Jerry"
}

# 调用函数
my_func
echo "Name is $name" # 输出 "Name is Jerry"
```

### 局部变量

```bash
#!/bin/bash

# 定义函数
my_func() {
  # 定义局部变量
  local count=0

  # 修改局部变量
  count=$[ $count + 1 ]

  # 输出局部变量
  echo "Count is $count"
}

# 调用函数
my_func # 输出 "Count is 1"

```

需要注意的是，在函数中使用局部变量时，变量名前必须加上 **`local`**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。

```bash
#!/bin/bash
# 在函数中使用局部变量不会影响到脚本主体中的全局变量的值
function func1 {
local temp=$[ $value + 5 ]
result=$[ $temp * 2 ]
}
temp=4
value=6
func1
echo "The result is $result"
if [ $temp -gt $value ]
then
echo "temp is larger"
else
echo "temp is smaller"
fi
```

## 在命令行上使用函数

可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在`PATH`环境变量里。重点在于让shell能够识别这些函数。

### 在命令行上创建函数

- 单行方式定义函数

```bash
ubuntu@sh:~$ function addem { echo $[ $1 + $2 ]; }
ubuntu@sh:~$ addem 1 2
3
```

- 多行方式定义函数

```bash
ubuntu@sh:~$ function multem {
> echo $[ $1 * $2 ]
> }
ubuntu@sh:~$ multem 2 4
8
ubuntu@sh:~$
```

在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。

### 在.bashrc文件中定义函数

在命令行上直接定义`shell`函数的明显缺点是退出`shell`时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在`shell`启动时由`shell`重新载入。`.bashrc`文件会在每次`shell`启动时在主目录下被查找并调用，因此可以在主目录下的.`bashrc`文件中定义函数。

将以下内容写入到`.bashrc`文件的末尾：

```bash
function addem {
echo $[ $1 + $2 ]
}
```

## 创建库

通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：

```bash
function addem {
echo $[ $1 + $2 ]
}
function multem {
echo $[ $1 * $2 ]
}
function divem {
if [ $2 -ne 0 ]
then
echo $[ $1 / $2 ]
else
echo -1
fi
}
```

在另一个脚本中执行`myfuncs`

```bash
#!/bin/bash
# using a library file the wrong way
./myfuncs
result=$(adem 10 15)
echo "The result is $result"
```

输出信息

```shell
addem: command not found
The result is
```

使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。

```bash
#!/bin/bash
# using functions defined in a library file
. ./myfuncs
value1=10
value2=5
result1=$(addem $value1 $value2)
result2=$(multem $value1 $value2)
result3=$(divem $value1 $value2)
echo "The result of adding them is: $result1"
echo "The result of multiplying them is: $result2"
echo "The result of dividing them is: $result3"
```

## 通过函数体实现加减运算

```bash
function calculate {

    case $op in
        "+")
            result=
            ;;
        "-")
            result=
            ;;
        *)
            echo "Error: unsupported operator."
            return 1
            ;;
    esac
    echo "Result: $result"
    return 0
}
```
