---
title: OpenStack运维案例
date:  2023-12-16 14:19:59
tags:
---

## 开放镜像权限

### 理论基础

在 OpenStack Glance 中，镜像可见性分为：

* **Public（公有）**：所有租户可见。
* **Private（私有）**：仅镜像所属项目可见。
* **Shared（共享）**：镜像所有者可将镜像共享给指定项目（Image Member 机制）。

多租户隔离是云的默认安全边界。共享私有镜像的正确做法是由管理员（或镜像所有者）通过“添加成员”把目标项目加入镜像成员列表，从而在保持隔离的同时精确授权。

### 案例描述

需求：管理员上传的镜像仅共享给 A 租户（projectA），B 租户（projectB）不可见。

策略：镜像保持私有（Private），再通过 `openstack image add project` 将镜像成员授权给 projectA。

### 案例实施

1) 认证环境

```shell
# 加载管理员凭据，后续 openstack/keystone/glance 命令无需重复传参
[root@controller ~]# source /etc/keystone/admin-openrc.sh
```

2) 创建项目与用户（示例以 projectB/userB 展示；projectA/userA 同理）

```shell
# 创建项目 projectB（域为 xiandian）
[root@controller ~]# openstack project create --domain xiandian projectB

# 创建用户 userB，默认项目为 projectB，密码 000000
[root@controller ~]# openstack user create --domain xiandian --project projectB --password 000000 userB

# 为 userB 赋予普通 user 角色（项目级权限）
[root@controller ~]# openstack role add --project projectB --user userB user
```

> 可通过 Horizon 图形界面完成同样的创建与验证。

3) 管理员上传镜像并保持私有

在 Horizon 管理员菜单上传 cirros 镜像，保持“私有”可见性，避免对所有租户暴露。

4) 将镜像共享给 projectA

```shell
# 将私有镜像 cirros 共享给项目 projectA
[root@controller ~]# openstack image add project cirros projectA
```

*提示：若状态显示 pending，需要 projectA 成员确认后变为 accepted（视版本/策略而定）。*

5) 验证可见性

* 使用 userA 登录（隶属 projectA）：应能看到 cirros 镜像。
* 使用 userB 登录（隶属 projectB）：不应看到该镜像。

> 作业1：使用 userA 登录 Horizon，截图镜像列表。

## 负载均衡服务配置与测试

### 理论基础

Octavia（LBaaS）核心组件：

* **Load Balancer**：承载 VIP 的负载均衡实例。
* **Listener**：监听协议/端口，接收流量。
* **Pool**：后端服务器组。
* **Member**：资源池中的具体后端节点。
* **Health Monitor**：健康检查，剔除不健康节点。

常见调度算法：ROUND_ROBIN（轮询）、LEAST_CONNECTIONS（最少连接）、SOURCE_IP（源地址哈希）。本例使用 ROUND_ROBIN。

### 案例实施

#### Heat 模板快速建网与主机

```yaml
heat_template_version: 2015-04-30
description: 创建负载均衡实验环境

resources:
    my_network:
        type: OS::Neutron::Net
        properties:
            name: private-iso-net

    my_subnet:
        type: OS::Neutron::Subnet
        properties:
            name: private-iso-net-subnet
            network_id: { get_resource: my_network }
            cidr: 192.168.200.0/24
            gateway_ip: 192.168.200.1
            dns_nameservers: ["114.114.114.114", "8.8.8.8"]
            ip_version: 4
            enable_dhcp: true

    # 示例只写一个实例，实际应创建 web01、web02、client 三台
    my_instance:
        type: OS::Nova::Server
        properties:
            name: instance1
            image: cirros
            flavor: m1.small
            networks:
                - network: { get_resource: my_network }
```

#### 配置后端 Web 服务

```shell
# web01：返回标识 01 的响应
[root@web01 ~]# echo -e "HTTP/1.0 200 OK\n\nThis is Web Server 01" > /tmp/msg
[root@web01 ~]# while true; do cat /tmp/msg | nc -l -p 80; done &

# web02：返回标识 02 的响应
[root@web02 ~]# echo -e "HTTP/1.0 200 OK\n\nThis is Web Server 02" > /tmp/msg
[root@web02 ~]# while true; do cat /tmp/msg | nc -l -p 80; done &
```

> 使用 nc 快速模拟 HTTP 服务，便于观察流量分配。

#### 构建负载均衡器

```shell
# 1) 创建 LB（指定 VIP 所在子网）
[root@controller ~]# openstack loadbalancer create --name lb-demo --vip-subnet-id <subnet-id>
[root@controller ~]# openstack loadbalancer show lb-demo   # 等待 provisioning_status=ACTIVE

# 2) 创建 Listener（HTTP/80）
[root@controller ~]# openstack loadbalancer listener create --name listener-http --protocol HTTP --protocol-port 80 lb-demo

# 3) 创建 Pool（轮询算法）
[root@controller ~]# openstack loadbalancer pool create --name pool-http --lb-algorithm ROUND_ROBIN --listener listener-http --protocol HTTP

# 4) 添加 Members（替换为实际后端 IP）
[root@controller ~]# openstack loadbalancer member create --subnet-id <subnet-id> --address <web01-ip> --protocol-port 80 pool-http
[root@controller ~]# openstack loadbalancer member create --subnet-id <subnet-id> --address <web02-ip> --protocol-port 80 pool-http
```

#### 验证与高可用

```shell
# 轮询验证
[root@controller ~]# openstack loadbalancer show lb-demo -c vip_address -f value
192.168.100.200
[root@client ~]# curl 192.168.100.200
This is Web Server 01
[root@client ~]# curl 192.168.100.200
This is Web Server 02

# 配置健康检查（5 秒探测，失败 3 次判定 DOWN）
[root@controller ~]# openstack loadbalancer healthmonitor create --delay 5 --max-retries 3 --timeout 5 --type HTTP --url-path / pool-http

# 模拟故障：停止 web01
[root@web01 ~]# killall nc  # 或 systemctl stop httpd

# 再次访问，流量应全部命中 web02
[root@client ~]# curl 192.168.100.200
This is Web Server 02
```

> 结论：健康检查生效，故障节点被自动剔除，业务持续可用。

## 配置 NFS 作为 Glance 后端存储

### 理论基础

Glance 通过“存储后端”保存镜像文件，常见后端：本地文件、Cinder、Swift、Ceph RBD、NFS 等。

在多控制节点场景下，本地文件存储会导致镜像分散；使用 NFS 可让所有 Glance 节点共享同一目录，保证镜像一致性并便于扩容。

### 案例实施

1) 配置 NFS 服务端

编辑 `/etc/exports`：

```text
/mnt/test 192.168.100.0/24(rw,no_root_squash,no_all_squash,sync,anonuid=501,anongid=501)
```

关键选项说明：`rw` 读写；`no_root_squash` 保留客户端 root 权限；`sync` 同步写盘；`anonuid/anongid` 指定匿名映射。

重启服务并验证导出：

```shell
[root@controller ~]# systemctl restart rpcbind
[root@controller ~]# systemctl restart nfs
[root@controller ~]# showmount -e 192.168.100.10
```

2) Glance 节点挂载 NFS

```shell
# 确认客户端工具已安装
[root@controller ~]# rpm -qa | grep nfs-utils

# 挂载到 Glance 默认目录
[root@controller ~]# mount -t nfs 192.168.100.10:/mnt/test /var/lib/glance/images/
[root@controller ~]# df -h | grep glance
```

> 生产环境请写入 `/etc/fstab` 以便开机自动挂载。

3) 权限修正

```shell
[root@controller ~]# cd /var/lib/glance
[root@controller glance]# chown glance:glance images
[root@controller glance]# ll -d images
```

4) 上传镜像并验证

在 Horizon 或 CLI 上传镜像后，检查 NFS 目录：

```shell
[root@controller glance]# ll /mnt/test
```

若出现新文件，说明镜像已写入 NFS。

> 作业2：上传镜像后，截图 NFS 目录文件列表。

5) Windows 访问（可选）

启用 Windows “NFS 服务”后，可在资源管理器访问：`\\192.168.100.10\mnt\test`。

<img src="https://lsky.taojie.fun:52222/i/2023/12/18/2023-12-18-1702886652.png" alt="1702886652481.png" title="1702886652481.png" />
