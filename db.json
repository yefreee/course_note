{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cat.png","path":"images/cat.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":1,"renderable":1},{"_id":"source/index.md.bak","path":"index.md.bak","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/.deleted/.OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/.obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #1 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #1 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #10 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #10 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #11 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #11 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #12 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #2 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #2 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #3 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #3 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #4 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #4 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #5 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #5 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #6 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #6 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #7 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #7 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570849},{"_id":"source/_posts/.deleted/Copy #8 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #8 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #9 of .OBSIDIANTEST","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/Copy #9 of .obtest","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.deleted/新建位图图像.bmp","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570859},{"_id":"source/_posts/.trash/Untitled 26.png.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570829},{"_id":"source/_posts/.trash/未命名.canvas","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1686384570829},{"_id":"source/index.md","hash":"ce5c4b3024604f5746b3109a905150d82b5056dc","modified":1693418542013},{"_id":"source/index.md.bak","hash":"8b79296a0cfe9d16c1f25c70011ab23a53e02034","modified":1693418527962},{"_id":"source/_posts/.obsidian/app.json","hash":"2c74662d62f84c5226ede5218af09a91ea5c5430","modified":1693417139113},{"_id":"source/_posts/.obsidian/appearance.json","hash":"07f2c8739996be8c57d852af274187dcfac35131","modified":1693417139291},{"_id":"source/_posts/.obsidian/community-plugins.json","hash":"63dc8ac6ddb87e32beb5a40300cea1e9e5e2baae","modified":1693417140646},{"_id":"source/_posts/.obsidian/core-plugins-migration.json","hash":"2285eee1d1614df70edf233f27e7187947aea3d3","modified":1693417139989},{"_id":"source/_posts/.obsidian/core-plugins.json","hash":"54dc51687d814cb0d2011df3a2d9a6a37924af86","modified":1693417139977},{"_id":"source/_posts/.obsidian/hotkeys.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1686384570829},{"_id":"source/_posts/.obsidian/workspace.json","hash":"1a5109166ece81321297c5f95ff9ea4298586a05","modified":1693418195003},{"_id":"source/_posts/.trash/1.md","hash":"8a8c92d2915eed2fbe022c30aaa401348f706d2a","modified":1687874505301},{"_id":"source/_posts/c_program/1.第一周.md","hash":"f49f89a68fab93243ab814f58da0cd479719bd98","modified":1687423644550},{"_id":"source/_posts/c_program/2.第二周.md","hash":"d795f599bd7ad3ee1ab1aff5716baebc8628da85","modified":1687073434123},{"_id":"source/_posts/c_program/3.第三周.md","hash":"c31e92f6f53568b7ae475777b7ff362dc0a58c09","modified":1686964008416},{"_id":"source/_posts/c_program/4.第四周.md","hash":"96935bd802e86595aba66899e1fb3d57d96b620c","modified":1687543662382},{"_id":"source/_posts/linux_shell/1.Shell初识，编辑器使用.md","hash":"8a6df47f82761dcdc754686638763b10aace9bf7","modified":1686885044773},{"_id":"source/_posts/linux_shell/10.文本处理工具awk.md","hash":"92e426aeaed828f8474093f09c7526e7d3b53c39","modified":1686922188368},{"_id":"source/_posts/linux_shell/11.系统资源性能监控脚本构建.md","hash":"1816ef4f74761f46566277632af03c2e02d4c418","modified":1687075174423},{"_id":"source/_posts/linux_shell/12.项目实战集.md","hash":"f7d61f7b8f6244df4d607251402f5d7aed076e55","modified":1687874669410},{"_id":"source/_posts/linux_shell/2.构建基本脚本.md","hash":"8b34750d3fedad565d566c8f59a8af0a90089109","modified":1686921122479},{"_id":"source/_posts/linux_shell/3.Shell条件测试.md","hash":"d5e434643d2f0348548008a43f2be9c9e6043c88","modified":1686921179047},{"_id":"source/_posts/linux_shell/4.Shell循环.md","hash":"88709ac1ed38c1b7a041c798a19206b1308dab2e","modified":1686921460667},{"_id":"source/_posts/linux_shell/5.处理用户输入.md","hash":"709c444e1b9ff2deb4fe4626825e69f0496536ff","modified":1686921643562},{"_id":"source/_posts/linux_shell/6.使用重定向呈现数据.md","hash":"469e05b5e30152dc2769790aae84405e30903e0a","modified":1686921698608},{"_id":"source/_posts/linux_shell/7.Shell函数.md","hash":"f8d4e664623a1f1efb2a36a510a20f90d39b5ba7","modified":1686921793156},{"_id":"source/_posts/linux_shell/8.正则表达式.md","hash":"4d416de412315887880cdbdcb947dc67f6dcda32","modified":1686928775032},{"_id":"source/_posts/linux_shell/9.流编辑器sed.md","hash":"05c073d4c8b0cb3a649cfdfc14e8f43bd4c6fcc7","modified":1686922128266},{"_id":"source/_posts/private_clouds/1.初识云计算与OpenStack.md","hash":"c302566c47bdb6b121a5349a1e2638bc50a783d7","modified":1693417019442},{"_id":"source/_posts/.obsidian/plugins/dataview/manifest.json","hash":"ddd9ed4be8f9d6bff39d58a3a663cca36e900c84","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/dataview/styles.css","hash":"d8705550409b8cbaec842e3f98efedcdadbe2b32","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/data.json","hash":"82358df459eb7332bb7933ee351acb6ed2fd3909","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/manifest.json","hash":"761287e28e70cc91877dc532dd8472613124f192","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/styles.css","hash":"369c7b06e650354d20bcc91f7c3d678084fc5fc8","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-quiet-outline/manifest.json","hash":"a678e7a044c709d129582e1bf9d01e9db7e09ad5","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/obsidian-quiet-outline/styles.css","hash":"788e109fa45cb3de19be58193443d44d1854451b","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/data.json","hash":"94c879cd5c6a819bd39c4de9d25919dcf08764a0","modified":1693417138617},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/manifest.json","hash":"d63fff649e6fcd9fd5b8eada80b6414feddad7de","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/styles.css","hash":"a03f657e10903825a3c4b2c2ff67b378b33df136","modified":1686384570829},{"_id":"source/_posts/.obsidian/themes/Blue Topaz/manifest.json","hash":"e1ce1badf6cd4436b7754cfeb0e07532607e7f75","modified":1686384570849},{"_id":"source/_posts/.obsidian/themes/Obsidian Nord/manifest.json","hash":"8bf923f083d545ff9f64afdc7695e47b56ec32ee","modified":1686384570849},{"_id":"source/_posts/.obsidian/themes/Obsidian Nord/theme.css","hash":"3afc5c4a854a0038054912a468c92fd7442ebb46","modified":1686384570849},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1687876376144},{"_id":"themes/next/_config.yml","hash":"3ae18cb9c867f5675603e4e6defe0e3708537612","modified":1687876376224},{"_id":"themes/next/_vendors.yml","hash":"5aa3b0573d47f85b1be7d21ced21c7810b37ecef","modified":1687876376224},{"_id":"themes/next/package.json","hash":"65193a84296855f28111f95b230f57d30c6957ba","modified":1687876376224},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1687876376134},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1687876376134},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1687876376144},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1687876376154},{"_id":"themes/next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1687876376154},{"_id":"themes/next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1687876376154},{"_id":"themes/next/languages/bn.yml","hash":"9f791494afa263c3e31f14b8a5fa2996dfc834c0","modified":1687876376154},{"_id":"themes/next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1687876376154},{"_id":"themes/next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1687876376154},{"_id":"themes/next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1687876376154},{"_id":"themes/next/languages/fr.yml","hash":"44cd26479f503751329f6da2ed80cce1bbf18117","modified":1687876376154},{"_id":"themes/next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1687876376154},{"_id":"themes/next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1687876376154},{"_id":"themes/next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1687876376154},{"_id":"themes/next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1687876376154},{"_id":"themes/next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1687876376154},{"_id":"themes/next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1687876376164},{"_id":"themes/next/languages/pt.yml","hash":"70de366e10ea584ba039d40d6b35ac97f93454ad","modified":1687876376164},{"_id":"themes/next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1687876376164},{"_id":"themes/next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1687876376164},{"_id":"themes/next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1687876376164},{"_id":"themes/next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1687876376164},{"_id":"themes/next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1687876376164},{"_id":"themes/next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1687876376164},{"_id":"themes/next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1687876376164},{"_id":"themes/next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1687876376164},{"_id":"themes/next/languages/zh-HK.yml","hash":"88ea50eeb9097ab4a87a44981a102d8594feb064","modified":1687876376164},{"_id":"themes/next/languages/zh-TW.yml","hash":"4695c87d6b81b3a23d16ad6513d9eaa925f8d8ad","modified":1687876376164},{"_id":"themes/next/layout/_layout.njk","hash":"fc0a45112f2dcfc2642404e8934ea32a793c3bd7","modified":1687876376174},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1687876376214},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1687876376214},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1687876376214},{"_id":"themes/next/layout/page.njk","hash":"b0660b2af0ac7d3fda14ca4d9f2c9e79ef06c6f9","modified":1687876376214},{"_id":"themes/next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1687876376214},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1687876376214},{"_id":"themes/next/docs/ru/README.md","hash":"ac3c4a7616ea80f0d32d68d6e53233952ba756dc","modified":1687876376134},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1687876376134},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1687876376134},{"_id":"themes/next/docs/zh-CN/README.md","hash":"9bbdbb0656505acceef9b9895a576164175fe888","modified":1687876376134},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1687876376214},{"_id":"themes/next/layout/_macro/post.njk","hash":"95822069cce2c4702e035c770b3089bc12a3404c","modified":1687876376214},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"547c62ab14d9e05d2d9116db9048a677fbe1fb6d","modified":1687876376214},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1687876376184},{"_id":"themes/next/layout/_partials/footer.njk","hash":"c40760b559c516677c8b11a00ba50c011f2079fd","modified":1687876376194},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1687876376194},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1687876376194},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"e7f988ecddb2159313699a00827a45eca5622bd4","modified":1687876376214},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1687876376214},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1687876376214},{"_id":"themes/next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1687876376184},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1687876376184},{"_id":"themes/next/layout/_third-party/index.njk","hash":"bda05391c72f7a25731e762077636c4a97fc4910","modified":1687876376184},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1687876376184},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1687876376184},{"_id":"themes/next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1687876376134},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1687876376134},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1687876376134},{"_id":"themes/next/scripts/filters/minify.js","hash":"964a01bec35a95da974882295cababcb93219b40","modified":1687876376134},{"_id":"themes/next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1687876376134},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1687876376134},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1687876376134},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1687876376134},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1687876376134},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1687876376134},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"fd24abfaba4d91923ddb6aecf0268b216678c8bd","modified":1687876376134},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1687876376134},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1687876376134},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1687876376134},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1687876376134},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1687876376134},{"_id":"themes/next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1687876376134},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1687876376134},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1687876376134},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1687876376134},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1687876376134},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1687876376134},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1687876376134},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1687876376134},{"_id":"themes/next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1687876376134},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1687876376114},{"_id":"themes/next/source/css/_mixins.styl","hash":"83647a6207333b9609ba90b0946b3fa9548e6381","modified":1687876376124},{"_id":"themes/next/source/css/main.styl","hash":"f08dc859180f258bde852e724dbc5e2f54bec073","modified":1687876376134},{"_id":"themes/next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1687876376134},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1687876376054},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1687876376054},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1687876376054},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1687876376054},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1687876376074},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1687876376074},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1687876376114},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1687876376114},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1687876376114},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1687876376114},{"_id":"themes/next/source/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1687876376114},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1687876376114},{"_id":"themes/next/source/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1687876376114},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1687876376114},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1687876376194},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1687876376194},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1687876376184},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1687876376184},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1687876376184},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1687876376184},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1687876376184},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1687876376184},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1687876376184},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1687876376184},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1687876376184},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1687876376184},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"79667fd0be85ee0e0c69e542e4f870b114c96c33","modified":1687876376194},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1687876376194},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1687876376204},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1687876376204},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1687876376204},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"ce90c97f222d9c751a08392e9b14d2bdf0f3df1a","modified":1687876376204},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1687876376184},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1687876376184},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1687876376184},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"70342218473a6e6aa9148de06bfffe121afb8548","modified":1687876376214},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1687876376184},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1687876376184},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1687876376184},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1687876376184},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1687876376184},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1687876376184},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1687876376184},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1687876376184},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1687876376184},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1687876376184},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1687876376184},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1687876376184},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1687876376184},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1687876376184},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1687876376184},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1687876376184},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1687876376184},{"_id":"themes/next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1687876376184},{"_id":"themes/next/scripts/events/lib/config.js","hash":"9ec51eb61f7fee612ffc5252f489003a0fa301fc","modified":1687876376134},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1687876376134},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1687876376134},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1687876376134},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"6853e5433e3eaa19ea43fa20b08d956ba4cec4ac","modified":1687876376134},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1687876376134},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1687876376134},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c7791eb0e38e07d8ce3a06cd2e84007c904ebe86","modified":1687876376134},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a1418c9dc8c0f1a0ad4ded0f4627c45bf0db1a10","modified":1687876376124},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1687876376134},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"48f4f277946a168d0db1ea02804e85c22ca2c7db","modified":1687876376134},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c4fc4e862d09221265ab1466085f057be2ad2e4d","modified":1687876376124},{"_id":"themes/next/source/js/schemes/muse.js","hash":"ba7ba2c129d1f240c6a22cec3e53f3f22af64b6b","modified":1687876376114},{"_id":"themes/next/source/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1687876376094},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1687876376114},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1687876376114},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1687876376114},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"7664491542046df9a3887cf40a06e00c0b4086a9","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"580aa86ed2ec05a7382338a6eea02e9c740b02a5","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"782ee1fc5e669d3ddbfeb82b73ad7fe561f1a4fb","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9dfe853c901bdc52fc950bacdf15484dbb9bf140","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"547c0b5cd5e7ea10d21863d13a6b16579a49396c","modified":1687876376114},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"ac2dc0ce9c775a83ef7132ae957b54539366ac9c","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"26a0cba1eee5de45a45a5e14e17707f905390512","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"91dbf3ca5c3a613d4e30618c120da535bf2d0336","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1687876376124},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1687876376124},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1687876376114},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1687876376114},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1687876376114},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1687876376114},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1687876376114},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1687876376114},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1687876376114},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1687876376114},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1687876376114},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1687876376114},{"_id":"themes/next/source/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1687876376114},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1687876376114},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1687876376114},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1687876376114},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1ecfd64507954810b07a9d21fb5305b5378feda0","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"11497388f124bfbb4001495a67d3629a9f618405","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"04cf4a69537fc14d3b8904f965d283356853847f","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1687876376124},{"_id":"themes/next/README.md","hash":"36c4b25587ca494102323dab5a38de5490451a64","modified":1687876376164},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1687876376124},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1687876376104},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"77550e0d3e029b7458e35d8c5ae1fbd612c9673b","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1687876376124},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"b750af2fb833c10c4313b5a4258237161a7833d7","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"da5e88f8debd5ac8d7af5c6ba6240df66104955f","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"c6a27beb3f741211a14576026f3b4cfc44cc6407","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"9a7c71560fbdc936ad4e736fe15063ea3e8a644b","modified":1687876376124},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"9056be572ec1cfa429abb22be4b45a662d5b0fb1","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"98d4c20aff0f0fcfe1824017fb06ab21ef0d218e","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1687876376124},{"_id":"themes/next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1687876376124},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1687876376114},{"_id":"themes/next/source/images/cat.png","hash":"e7fd992e7aaf6e091b819e68d3adf8622c99663a","modified":1687876376094},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1687876376114},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1687876376114},{"_id":"source/_posts/.obsidian/plugins/obsidian-quiet-outline/main.js","hash":"d114c38a0835ece26be946b7b6a17e2f216c9cc0","modified":1686384570829},{"_id":"source/_posts/.obsidian/themes/Blue Topaz/theme.css","hash":"9d8342c74c678bab55b339d2b2ba76db853438e4","modified":1686384570849},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/main.js","hash":"1fbdc9e2bab546bd115ace9f8c987327a1c9e43b","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/dataview/main.js","hash":"551153e308a7a463ed841905ce3e4ef0fc59d1af","modified":1686384570829},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/main.js","hash":"ad3a3ce7b72c396c15c638c1e4e835fe2a4951ba","modified":1686384570829},{"_id":"public/index.html","hash":"aab15b3bbc0f7e2743a5292690020cb58f562968","modified":1693418570153},{"_id":"public/archives/index.html","hash":"c39e1c82f8388d3faacfdc7027400a50d4f8164f","modified":1693418570153},{"_id":"public/archives/page/2/index.html","hash":"023192002d14b0a9a0aa8a46872af0df29c6368a","modified":1693418570153},{"_id":"public/archives/2023/index.html","hash":"20bbd23be1d7d8a0035b7f34c47303468983b880","modified":1693418570153},{"_id":"public/archives/2023/page/2/index.html","hash":"488b6daba9fe2ff4aba3ec6b6a69dc4277bbb6c9","modified":1693418570153},{"_id":"public/archives/2023/04/index.html","hash":"333054709871d02d412c14fec9175fd2d0b38618","modified":1693418570153},{"_id":"public/archives/2023/06/index.html","hash":"9c68041c8ce3d59bf5917021043a3d05a91d2075","modified":1693418570153},{"_id":"public/2023/06/20/c_program/4.第四周/index.html","hash":"416ad297121a4842a4457d93fb0a08e91a39d8df","modified":1693418570153},{"_id":"public/2023/06/16/c_program/3.第三周/index.html","hash":"57179e1e1dc8526c2d0c37590d6ea682fa889103","modified":1693418570153},{"_id":"public/2023/06/16/linux_shell/12.项目实战集/index.html","hash":"792978f4f2bb08cc06a493087f658908a5650e39","modified":1693418570153},{"_id":"public/2023/06/16/linux_shell/11.系统资源性能监控脚本构建/index.html","hash":"08472a160a00c86538874212d914e6d9e378759f","modified":1693418570153},{"_id":"public/2023/06/16/c_program/2.第二周/index.html","hash":"1283c9ddd202826d2e3a73525d6d23c6b7848627","modified":1693418570153},{"_id":"public/2023/06/27/private_clouds/1.初识云计算与OpenStack/index.html","hash":"4b709c04b655400117333639ac953f5841a6242d","modified":1693418570153},{"_id":"public/2023/06/09/c_program/1.第一周/index.html","hash":"214558eb4594d4244cff64ba93cbd281e4035348","modified":1693418570153},{"_id":"public/2023/04/23/linux_shell/10.文本处理工具awk/index.html","hash":"947b320a5789222c05c550d76ba84ac1c8ea13dd","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/1.Shell初识，编辑器使用/index.html","hash":"63625c74cf264aa3460315526d87556a4fdc7edc","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/3.Shell条件测试/index.html","hash":"60d43a53f5f88c76a7c310bcd8a072b0a26fab2b","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/4.Shell循环/index.html","hash":"342802faa4bb90fe55823f2c1276911ae3efed36","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/2.构建基本脚本/index.html","hash":"f1b99668405e765f90211a4b0dc7d62289a724ed","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/5.处理用户输入/index.html","hash":"0625ce737e705256e8a985f49ec68fd291b8fbb0","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/6.使用重定向呈现数据/index.html","hash":"e1b4e53059b5fdc5bb30d3ff92964bc4c2c266fc","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/7.Shell函数/index.html","hash":"d7108d3f8a8f6ee88bd49b98df04e4cb95c81d28","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/8.正则表达式/index.html","hash":"c805a7657a8900175c617353e2d09b14eb82af95","modified":1693418570153},{"_id":"public/2023/04/18/linux_shell/9.流编辑器sed/index.html","hash":"4945b0f57f5767d7732dba1844da8d3b23cf064d","modified":1693418570153},{"_id":"public/source/index.md/index.html","hash":"790b9185dab7b08dce65b724c416cc6b2a0de9a3","modified":1693418570153},{"_id":"public/source/index.md/page/2/index.html","hash":"b734dec25e4c0986a990be29989cfb365fae2425","modified":1693418570153},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1693418570153},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1693418570153},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1693418570153},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1693418570153},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1693418570153},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1693418570153},{"_id":"public/index.md.bak","hash":"8b79296a0cfe9d16c1f25c70011ab23a53e02034","modified":1693418570153},{"_id":"public/images/cat.png","hash":"e7fd992e7aaf6e091b819e68d3adf8622c99663a","modified":1693418570153},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1693418570153},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1693418570153},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1693418570153},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1693418570153},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1693418570153},{"_id":"public/js/motion.js","hash":"770d63c26f22705311028a36b52e999cc8a2da82","modified":1693418570153},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1693418570153},{"_id":"public/js/pjax.js","hash":"b03ba78c6916ad2f390d55bc1bc18fafb64b0ebf","modified":1693418570153},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1693418570153},{"_id":"public/js/schemes/muse.js","hash":"ba7ba2c129d1f240c6a22cec3e53f3f22af64b6b","modified":1693418570153},{"_id":"public/js/third-party/addtoany.js","hash":"5276c8f78ee562a8965216dc67d762e59cb4a9f2","modified":1693418570153},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1693418570153},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1693418570153},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1693418570153},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1693418570153},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1693418570153},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1693418570153},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1693418570153},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1693418570153},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1693418570153},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1693418570153},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1693418570153},{"_id":"public/js/third-party/comments/disqus.js","hash":"da361917d65e5dca8362f8cdeb6c8cc0e8316cec","modified":1693418570153},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"1e826dea3f684c0515f362dc1352447a1f0eae71","modified":1693418570153},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1693418570153},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1693418570153},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1693418570153},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1693418570153},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1693418570153},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1693418570153},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1693418570153},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1693418570153},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":1693418570153},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1693418570153},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1693418570153},{"_id":"public/js/third-party/statistics/firestore.js","hash":"6e0682bb42170d61b13b786295f45f9c785f8b73","modified":1693418570153},{"_id":"public/js/third-party/tags/wavedrom.js","hash":"40dcd10df6edf124088c329346e0cc0bdac74ef1","modified":1693418570153},{"_id":"public/css/main.css","hash":"697c2bf15b51a4d5ef448f938a30cda633db4310","modified":1693418570153},{"_id":"public/js/utils.js","hash":"5e1cf39de050964e97fb3ba0825aeec7f4bc36dd","modified":1693418570153}],"Category":[],"Data":[],"Page":[{"layout":"page","title":"Home Page","date":"2023-04-17T16:00:00.000Z","tags":null,"_content":"\n## 私有云服务架构与运维-64课时\n\n1. {% post_link private_clouds/1.初识云计算与OpenStack %} \n","source":"index.md","raw":"---\nlayout: page\ntitle: Home Page\ndate: 2023-04-18\ntags: \n---\n\n## 私有云服务架构与运维-64课时\n\n1. {% post_link private_clouds/1.初识云计算与OpenStack %} \n","updated":"2023-08-30T18:02:22.013Z","path":"index.html","comments":1,"_id":"clly1p04500001dnz2c867yxe","content":"<h2 id=\"私有云服务架构与运维-64课时\"><a href=\"#私有云服务架构与运维-64课时\" class=\"headerlink\" title=\"私有云服务架构与运维-64课时\"></a>私有云服务架构与运维-64课时</h2><ol>\n<li><a href=\"/2023/06/27/private_clouds/1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenStack/\" title=\"初识云计算与OpenStack\">初识云计算与OpenStack</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"私有云服务架构与运维-64课时\"><a href=\"#私有云服务架构与运维-64课时\" class=\"headerlink\" title=\"私有云服务架构与运维-64课时\"></a>私有云服务架构与运维-64课时</h2><ol>\n<li><a href=\"/2023/06/27/private_clouds/1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenStack/\" title=\"初识云计算与OpenStack\">初识云计算与OpenStack</a></li>\n</ol>\n"}],"Post":[{"title":"第一周","date":"2023-06-09T03:31:25.000Z","_content":"\n## 名词解释\n\n1. 高级语言、低级语言、机器语言\n    1. 高级语言（High-Level Language）：\n    高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。\n    2. 低级语言（Low-Level Language）：\n    低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。\n    3. 机器语言（Machine Language）：\n    机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。\n\n2. 解释型语言和编译型语\n\n    ![1.第一周-2023-06-09-10-53-51](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png)\n\n    Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。\n\n3. C语言源代码到可执行文件的过程\n\n    1. C源代码：\n    程序员使用C语言编写源代码，源代码以`.c`为扩展名。源代码包含了程序的逻辑和功能的定义。\n    2. 预处理：\n    在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。\n    3. 编译：\n    经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（`.s`文件）。\n    4. 汇编：\n    汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（`.o`文件）。\n    5. 链接：\n    链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。\n    6. 可执行文件：\n    最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。\n\n4. 静态语言和动态语言\n\n    1. 静态语言（Static Language）：\n    静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。\n\n        优点：\n        1. 更早地发现类型错误，提前检测潜在的编程错误。\n        2. 在编译时进行类型检查，提高代码的稳定性和可靠性。\n        3. 性能较好，由于类型已经确定，编译器可以进行更多的优化。\n\n        缺点：\n        1. 代码相对冗长，需要显式声明和定义类型。\n        2. 编译时间较长，需要进行较多的类型检查和编译过程。\n\n    2. 动态语言（Dynamic Language）：\n    动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。\n\n        优点：\n\n        1. 灵活性高，可以在运行时动态地改变变量的类型和行为。\n        2. 代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。\n\n        缺点：\n\n        1. 需要在运行时进行类型检查和解析，性能可能相对较低。\n        2. 容易出现运行时类型错误，只能在运行时才能发现。\n\n    需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。\n\n## C语言开发环境\n\n1. 在线运行平台（一键运行）：\n    1. [https://www.nhooo.com/tool/c/](https://www.nhooo.com/tool/c/)\n    2. [https://www.bejson.com/runcode/c740/](https://www.bejson.com/runcode/c740/)\n2. IDE（集成开发环境）：\n    1. Visual Studio（一站式安装，一键编译运行）\n\n        [Visual Studio下载地址](https://visualstudio.microsoft.com/zh-hans/)，[中文安装教程](https://zhuanlan.zhihu.com/p/71110525)\n\n    2. VSCode + mingw（配置灵活且繁琐，一键编译运行）\n\n        [VSCode下载地址](https://code.visualstudio.com/download)，[mingw压缩包地址](https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z)，[vscode和mingw安装教程](https://zhuanlan.zhihu.com/p/354400717)\n\n3. Linux环境（vim+gcc）\n\n    编译命令`gcc -o 目标文件名 源文件`\n\n    例：`gcc -o test test.c` 将名为`test.c`的源文件编译成名为`test`的目标文件\n\n## C语言程序的结构\n\n- 简单的C程序实例\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        /* 定义一个名为num的变量 */\n        int num;\n        /* 为num赋一个值 */\n        num = 1;\n    \n        /* 使用printf()函数 */\n        printf(\"I am a simple \");\n        printf(\"computer.\\n\");\n        printf(\"My favorite number is %d because it is first.\\n\", num);\n    \n        return 0;\n    }\n    ```\n\n1. `#include`指令和头文件\n\n    `#include`这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。\n\n    `#include <stdio.h>`的作用相当于把`stdio.h`文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。\n\n2. `main()`函数\n\n    C程序从`main()`函数开始执行。除了`main()`函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。`int`是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词`void` 。\n\n    ```c\n    //错误的main函数定义1\n    main()\n    \n    //错误的main函数定义2\n    void main()\n    \n    //正确的main函数定义1\n    int main(void)\n    \n    //正确的main函数定义2\n    int main(int argc, char *argv[])\n    ```\n\n    `int main(int argc, char *argv[])` 是C语言中常见的`main`函数的定义方式，它用于接收命令行参数。\n\n    参数解释：\n\n    - `int argc`：表示命令行参数的数量（Argument Count）。\n    - `char *argv[]`：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。\n\n    使用这种方式定义的`main`函数可以接收命令行传递的参数，如下所示：\n\n    ```c\n    #include <stdio.h>\n    \n    int main(int argc, char *argv[]) {\n        printf(\"argc: %d\\n\", argc);\n    \n        for (int i = 0; i < argc; i++) {\n            printf(\"argv[%d]: %s\\n\", i, argv[i]);\n        }\n    \n        return 0;\n    }\n    ```\n\n    运行该程序并传递参数，例如：\n\n    ```bash\n    ./program arg1 arg2 arg3\n    ```\n\n    程序运行结果会输出命令行参数的数量以及每个参数的值，如：\n\n    ```text\n    argc: 4\n    argv[0]: ./program\n    argv[1]: arg1\n    argv[2]: arg2\n    argv[3]: arg3\n    ```\n\n3. 注释\n\n    在程序中，被两个`/* */`符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。\n\n    ```c\n    /* 这是一条C注释。 */\n    /* 这也是一条注释，\n    被分成两行。*/\n    /*\n    也可以这样写注释。\n    */\n    /* 这条注释无效，因为缺少了结束标记。\n    \n    // 这种注释只能写成一行\n    ```\n\n4. 花括号、函数体和块\n\n    花括号把main()函数括起来。一般而言，所有的C函数都使用`花括号`标记`函数体的开始和结束`。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句`合并`为一个`单元或块`。\n\n5. 声明（declaration）\n\n    声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为\n    num的变量（`variable`）。其二，`int`表明`num`是一个`整数`（即，没有小数点或小数部分的数）。`int`是一种数据类型。编译器使用这些信息为`num`变量在内存中分配存储空间。\n\n6. 赋值\n\n    赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。\n\n7. `printf()`函数\n\n    示例代码中有3行代码都使用了C语言的一个标准函数：`printf()`。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把`I am a simple`传递给printf()函数。该信息被称为参数。\n\n    换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始\n\n8. `return`语句\n\n    return语句是示例程序中的最后一条语句。`int main(void)`中的int表明main()函数应返回一个`整数`。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。\n\n## C语言源程序的书写格式\n\n1. 缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。\n2. 大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。\n\n    ```c\n    if (condition) {\n        // 代码块\n        // ...\n    }\n    ```\n\n3. 空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。\n\n    ```c\n    int sum = a + b;\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", i);\n    }\n    ```\n\n4. 注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。\n\n    ```c\n    // 计算两个数的和\n    int sum = a + b;\n    ```\n\n5. 命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。\n\n    ```c\n    int numberOfStudents = 10;\n    void printMessage() {\n        // 函数体\n    }\n    ```\n\n6. 换行：在较长的语句中，适当地进行换行，以保持代码的可读性。\n\n    ```c\n    longResult = (longValue1 + longValue2 + longValue3) /\n                 (longValue4 - longValue5);\n    ```\n\n## C语言数据类型\n\n1. 整型（Integer）：\n    - `int`：表示整数类型。通常占用4个字节。\n    - `short`：表示短整数类型。通常占用2个字节。\n    - `long`：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。\n\n    示例代码：\n\n    ```c\n    int num1 = 10;\n    short num2 = 20;\n    long num3 = 30L;  // 后缀L表示长整数类型\n    ```\n\n2. 浮点型（Floating-point）：\n    - `float`：表示单精度浮点数类型。通常占用4个字节。\n    - `double`：表示双精度浮点数类型。通常占用8个字节。\n\n    示例代码：\n\n    ```c\n    float num1 = 3.14f;  // 后缀f表示单精度浮点数类型\n    double num2 = 2.71828;\n    ```\n\n3. 字符型（Character）：\n    - `char`：表示字符类型。通常占用1个字节。\n\n    示例代码：\n\n    ```c\n    char ch1 = 'A';\n    char ch2 = 'B';\n    ```\n\n4. 布尔型（Boolean）：\n    - `bool`：表示布尔类型，只能取`true`（非零值）或`false`（零值）。\n\n    示例代码：\n\n    ```c\n    #include <stdbool.h>  // 需要包含stdbool.h头文件\n    \n    bool flag1 = true;\n    bool flag2 = false;\n    ```\n\n### 数据类型示例代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nint main(void) {\n    // 整型示例\n    int num1 = 10;\n    printf(\"整数num1 = %d，整型大小: %u 字节\\n\", num1, sizeof(num1));\n\n    short num2 = 20;\n    printf(\"短整数num2 = %hd，短整数大小: %u 字节\\n\", num2, sizeof(num2));\n\n    long num3 = 30L;\n    printf(\"长整数num3 = %ld，长整数大小: %u 字节\\n\", num3, sizeof(num3));\n\n    // 浮点型示例\n    float num4 = 3.14f;\n    printf(\"单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n\", num4, sizeof(num4));\n\n    double num5 = 2.71828;\n    printf(\"双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n\", num5, sizeof(num5));\n\n    // 字符型示例\n    char ch1 = 'A';\n    printf(\"字符ch1 = %c，字符大小: %u 字节\\n\", ch1, sizeof(ch1));\n\n    char ch2 = 66;  // ASCII码值\n    printf(\"字符ch2 = %c，字符大小: %u 字节\\n\", ch2, sizeof(ch2));\n\n    // 布尔型示例\n    bool flag1 = true;\n    printf(\"布尔数flag1 = %d，布尔值大小: %u 字节\\n\", flag1, sizeof(flag1));\n\n    bool flag2 = false;\n    printf(\"布尔数flag2 = %d，布尔值大小: %u 字节\\n\", flag2, sizeof(flag2));\n\n    return 0;\n}\n```\n\n## C语言的运算符\n\nC语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：\n\n1. 算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。\n    - `+`：加法运算\n    - `-`：减法运算\n    - *：乘法运算\n    - `/`：除法运算\n    - `%`：取模（取余）运算\n2. 关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。\n    - `==`：等于\n    - `!=`：不等于\n    - `<`：小于\n    - `>`：大于\n    - `<=`：小于等于\n    - `>=`：大于等于\n3. 逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。\n    - `&&`：逻辑与（与）\n    - `||`：逻辑或（或）\n    - `!`：逻辑非（非）\n4. 位运算符：用于对二进制数据的位进行操作。\n    - `&`：按位与\n    - `|`：按位或\n    - `^`：按位异或\n    - `~`：按位取反\n    - `<<`：左移\n    - `>>`：右移\n5. 赋值运算符：用于给变量赋值。\n    - `=`：简单赋值\n    - `+=`：加法赋值\n    - `=`：减法赋值\n    - `=`：乘法赋值\n    - `/=`：除法赋值\n    - `%=`：取模赋值\n    - `<<=`：左移赋值\n    - `>>=`：右移赋值\n    - `&=`：按位与赋值\n    - `|=`：按位或赋值\n    - `^=`：按位异或赋值\n6. 自增和自减运算符：用于对变量进行递增或递减操作。\n    - `++`：自增\n    - `-`：自减\n7. 条件运算符：用于根据条件选择不同的值。\n    - `? :`：条件表达式，也称为三元运算符。\n8. 其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。\n","source":"_posts/c_program/1.第一周.md","raw":"---\ntitle: 第一周\ndate: 2023-06-09 11:31:25\ntags: \n---\n\n## 名词解释\n\n1. 高级语言、低级语言、机器语言\n    1. 高级语言（High-Level Language）：\n    高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。\n    2. 低级语言（Low-Level Language）：\n    低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。\n    3. 机器语言（Machine Language）：\n    机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。\n\n2. 解释型语言和编译型语\n\n    ![1.第一周-2023-06-09-10-53-51](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png)\n\n    Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。\n\n3. C语言源代码到可执行文件的过程\n\n    1. C源代码：\n    程序员使用C语言编写源代码，源代码以`.c`为扩展名。源代码包含了程序的逻辑和功能的定义。\n    2. 预处理：\n    在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。\n    3. 编译：\n    经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（`.s`文件）。\n    4. 汇编：\n    汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（`.o`文件）。\n    5. 链接：\n    链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。\n    6. 可执行文件：\n    最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。\n\n4. 静态语言和动态语言\n\n    1. 静态语言（Static Language）：\n    静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。\n\n        优点：\n        1. 更早地发现类型错误，提前检测潜在的编程错误。\n        2. 在编译时进行类型检查，提高代码的稳定性和可靠性。\n        3. 性能较好，由于类型已经确定，编译器可以进行更多的优化。\n\n        缺点：\n        1. 代码相对冗长，需要显式声明和定义类型。\n        2. 编译时间较长，需要进行较多的类型检查和编译过程。\n\n    2. 动态语言（Dynamic Language）：\n    动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。\n\n        优点：\n\n        1. 灵活性高，可以在运行时动态地改变变量的类型和行为。\n        2. 代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。\n\n        缺点：\n\n        1. 需要在运行时进行类型检查和解析，性能可能相对较低。\n        2. 容易出现运行时类型错误，只能在运行时才能发现。\n\n    需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。\n\n## C语言开发环境\n\n1. 在线运行平台（一键运行）：\n    1. [https://www.nhooo.com/tool/c/](https://www.nhooo.com/tool/c/)\n    2. [https://www.bejson.com/runcode/c740/](https://www.bejson.com/runcode/c740/)\n2. IDE（集成开发环境）：\n    1. Visual Studio（一站式安装，一键编译运行）\n\n        [Visual Studio下载地址](https://visualstudio.microsoft.com/zh-hans/)，[中文安装教程](https://zhuanlan.zhihu.com/p/71110525)\n\n    2. VSCode + mingw（配置灵活且繁琐，一键编译运行）\n\n        [VSCode下载地址](https://code.visualstudio.com/download)，[mingw压缩包地址](https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z)，[vscode和mingw安装教程](https://zhuanlan.zhihu.com/p/354400717)\n\n3. Linux环境（vim+gcc）\n\n    编译命令`gcc -o 目标文件名 源文件`\n\n    例：`gcc -o test test.c` 将名为`test.c`的源文件编译成名为`test`的目标文件\n\n## C语言程序的结构\n\n- 简单的C程序实例\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        /* 定义一个名为num的变量 */\n        int num;\n        /* 为num赋一个值 */\n        num = 1;\n    \n        /* 使用printf()函数 */\n        printf(\"I am a simple \");\n        printf(\"computer.\\n\");\n        printf(\"My favorite number is %d because it is first.\\n\", num);\n    \n        return 0;\n    }\n    ```\n\n1. `#include`指令和头文件\n\n    `#include`这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。\n\n    `#include <stdio.h>`的作用相当于把`stdio.h`文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。\n\n2. `main()`函数\n\n    C程序从`main()`函数开始执行。除了`main()`函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。`int`是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词`void` 。\n\n    ```c\n    //错误的main函数定义1\n    main()\n    \n    //错误的main函数定义2\n    void main()\n    \n    //正确的main函数定义1\n    int main(void)\n    \n    //正确的main函数定义2\n    int main(int argc, char *argv[])\n    ```\n\n    `int main(int argc, char *argv[])` 是C语言中常见的`main`函数的定义方式，它用于接收命令行参数。\n\n    参数解释：\n\n    - `int argc`：表示命令行参数的数量（Argument Count）。\n    - `char *argv[]`：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。\n\n    使用这种方式定义的`main`函数可以接收命令行传递的参数，如下所示：\n\n    ```c\n    #include <stdio.h>\n    \n    int main(int argc, char *argv[]) {\n        printf(\"argc: %d\\n\", argc);\n    \n        for (int i = 0; i < argc; i++) {\n            printf(\"argv[%d]: %s\\n\", i, argv[i]);\n        }\n    \n        return 0;\n    }\n    ```\n\n    运行该程序并传递参数，例如：\n\n    ```bash\n    ./program arg1 arg2 arg3\n    ```\n\n    程序运行结果会输出命令行参数的数量以及每个参数的值，如：\n\n    ```text\n    argc: 4\n    argv[0]: ./program\n    argv[1]: arg1\n    argv[2]: arg2\n    argv[3]: arg3\n    ```\n\n3. 注释\n\n    在程序中，被两个`/* */`符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。\n\n    ```c\n    /* 这是一条C注释。 */\n    /* 这也是一条注释，\n    被分成两行。*/\n    /*\n    也可以这样写注释。\n    */\n    /* 这条注释无效，因为缺少了结束标记。\n    \n    // 这种注释只能写成一行\n    ```\n\n4. 花括号、函数体和块\n\n    花括号把main()函数括起来。一般而言，所有的C函数都使用`花括号`标记`函数体的开始和结束`。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句`合并`为一个`单元或块`。\n\n5. 声明（declaration）\n\n    声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为\n    num的变量（`variable`）。其二，`int`表明`num`是一个`整数`（即，没有小数点或小数部分的数）。`int`是一种数据类型。编译器使用这些信息为`num`变量在内存中分配存储空间。\n\n6. 赋值\n\n    赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。\n\n7. `printf()`函数\n\n    示例代码中有3行代码都使用了C语言的一个标准函数：`printf()`。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把`I am a simple`传递给printf()函数。该信息被称为参数。\n\n    换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始\n\n8. `return`语句\n\n    return语句是示例程序中的最后一条语句。`int main(void)`中的int表明main()函数应返回一个`整数`。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。\n\n## C语言源程序的书写格式\n\n1. 缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。\n2. 大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。\n\n    ```c\n    if (condition) {\n        // 代码块\n        // ...\n    }\n    ```\n\n3. 空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。\n\n    ```c\n    int sum = a + b;\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", i);\n    }\n    ```\n\n4. 注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。\n\n    ```c\n    // 计算两个数的和\n    int sum = a + b;\n    ```\n\n5. 命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。\n\n    ```c\n    int numberOfStudents = 10;\n    void printMessage() {\n        // 函数体\n    }\n    ```\n\n6. 换行：在较长的语句中，适当地进行换行，以保持代码的可读性。\n\n    ```c\n    longResult = (longValue1 + longValue2 + longValue3) /\n                 (longValue4 - longValue5);\n    ```\n\n## C语言数据类型\n\n1. 整型（Integer）：\n    - `int`：表示整数类型。通常占用4个字节。\n    - `short`：表示短整数类型。通常占用2个字节。\n    - `long`：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。\n\n    示例代码：\n\n    ```c\n    int num1 = 10;\n    short num2 = 20;\n    long num3 = 30L;  // 后缀L表示长整数类型\n    ```\n\n2. 浮点型（Floating-point）：\n    - `float`：表示单精度浮点数类型。通常占用4个字节。\n    - `double`：表示双精度浮点数类型。通常占用8个字节。\n\n    示例代码：\n\n    ```c\n    float num1 = 3.14f;  // 后缀f表示单精度浮点数类型\n    double num2 = 2.71828;\n    ```\n\n3. 字符型（Character）：\n    - `char`：表示字符类型。通常占用1个字节。\n\n    示例代码：\n\n    ```c\n    char ch1 = 'A';\n    char ch2 = 'B';\n    ```\n\n4. 布尔型（Boolean）：\n    - `bool`：表示布尔类型，只能取`true`（非零值）或`false`（零值）。\n\n    示例代码：\n\n    ```c\n    #include <stdbool.h>  // 需要包含stdbool.h头文件\n    \n    bool flag1 = true;\n    bool flag2 = false;\n    ```\n\n### 数据类型示例代码\n\n```c\n#include <stdio.h>\n#include <stdbool.h>\n\nint main(void) {\n    // 整型示例\n    int num1 = 10;\n    printf(\"整数num1 = %d，整型大小: %u 字节\\n\", num1, sizeof(num1));\n\n    short num2 = 20;\n    printf(\"短整数num2 = %hd，短整数大小: %u 字节\\n\", num2, sizeof(num2));\n\n    long num3 = 30L;\n    printf(\"长整数num3 = %ld，长整数大小: %u 字节\\n\", num3, sizeof(num3));\n\n    // 浮点型示例\n    float num4 = 3.14f;\n    printf(\"单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n\", num4, sizeof(num4));\n\n    double num5 = 2.71828;\n    printf(\"双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n\", num5, sizeof(num5));\n\n    // 字符型示例\n    char ch1 = 'A';\n    printf(\"字符ch1 = %c，字符大小: %u 字节\\n\", ch1, sizeof(ch1));\n\n    char ch2 = 66;  // ASCII码值\n    printf(\"字符ch2 = %c，字符大小: %u 字节\\n\", ch2, sizeof(ch2));\n\n    // 布尔型示例\n    bool flag1 = true;\n    printf(\"布尔数flag1 = %d，布尔值大小: %u 字节\\n\", flag1, sizeof(flag1));\n\n    bool flag2 = false;\n    printf(\"布尔数flag2 = %d，布尔值大小: %u 字节\\n\", flag2, sizeof(flag2));\n\n    return 0;\n}\n```\n\n## C语言的运算符\n\nC语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：\n\n1. 算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。\n    - `+`：加法运算\n    - `-`：减法运算\n    - *：乘法运算\n    - `/`：除法运算\n    - `%`：取模（取余）运算\n2. 关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。\n    - `==`：等于\n    - `!=`：不等于\n    - `<`：小于\n    - `>`：大于\n    - `<=`：小于等于\n    - `>=`：大于等于\n3. 逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。\n    - `&&`：逻辑与（与）\n    - `||`：逻辑或（或）\n    - `!`：逻辑非（非）\n4. 位运算符：用于对二进制数据的位进行操作。\n    - `&`：按位与\n    - `|`：按位或\n    - `^`：按位异或\n    - `~`：按位取反\n    - `<<`：左移\n    - `>>`：右移\n5. 赋值运算符：用于给变量赋值。\n    - `=`：简单赋值\n    - `+=`：加法赋值\n    - `=`：减法赋值\n    - `=`：乘法赋值\n    - `/=`：除法赋值\n    - `%=`：取模赋值\n    - `<<=`：左移赋值\n    - `>>=`：右移赋值\n    - `&=`：按位与赋值\n    - `|=`：按位或赋值\n    - `^=`：按位异或赋值\n6. 自增和自减运算符：用于对变量进行递增或递减操作。\n    - `++`：自增\n    - `-`：自减\n7. 条件运算符：用于根据条件选择不同的值。\n    - `? :`：条件表达式，也称为三元运算符。\n8. 其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。\n","slug":"c_program/1.第一周","published":1,"updated":"2023-06-22T08:47:24.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04700011dnz2v7mgjs0","content":"<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ol>\n<li><p>高级语言、低级语言、机器语言</p>\n<ol>\n<li>高级语言（High-Level Language）：<br> 高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。</li>\n<li>低级语言（Low-Level Language）：<br> 低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。</li>\n<li>机器语言（Machine Language）：<br> 机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。</li>\n</ol>\n</li>\n<li><p>解释型语言和编译型语</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png\" alt=\"1.第一周-2023-06-09-10-53-51\"></p>\n<p> Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>\n</li>\n<li><p>C语言源代码到可执行文件的过程</p>\n<ol>\n<li>C源代码：<br> 程序员使用C语言编写源代码，源代码以<code>.c</code>为扩展名。源代码包含了程序的逻辑和功能的定义。</li>\n<li>预处理：<br> 在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。</li>\n<li>编译：<br> 经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（<code>.s</code>文件）。</li>\n<li>汇编：<br> 汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（<code>.o</code>文件）。</li>\n<li>链接：<br> 链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。</li>\n<li>可执行文件：<br> 最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。</li>\n</ol>\n</li>\n<li><p>静态语言和动态语言</p>\n<ol>\n<li><p>静态语言（Static Language）：<br> 静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。</p>\n<p> 优点：</p>\n<ol>\n<li>更早地发现类型错误，提前检测潜在的编程错误。</li>\n<li>在编译时进行类型检查，提高代码的稳定性和可靠性。</li>\n<li>性能较好，由于类型已经确定，编译器可以进行更多的优化。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>代码相对冗长，需要显式声明和定义类型。</li>\n<li>编译时间较长，需要进行较多的类型检查和编译过程。</li>\n</ol>\n</li>\n<li><p>动态语言（Dynamic Language）：<br> 动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。</p>\n<p> 优点：</p>\n<ol>\n<li>灵活性高，可以在运行时动态地改变变量的类型和行为。</li>\n<li>代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>需要在运行时进行类型检查和解析，性能可能相对较低。</li>\n<li>容易出现运行时类型错误，只能在运行时才能发现。</li>\n</ol>\n</li>\n</ol>\n<p> 需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。</p>\n</li>\n</ol>\n<h2 id=\"C语言开发环境\"><a href=\"#C语言开发环境\" class=\"headerlink\" title=\"C语言开发环境\"></a>C语言开发环境</h2><ol>\n<li><p>在线运行平台（一键运行）：</p>\n<ol>\n<li><a href=\"https://www.nhooo.com/tool/c/\">https://www.nhooo.com/tool/c/</a></li>\n<li><a href=\"https://www.bejson.com/runcode/c740/\">https://www.bejson.com/runcode/c740/</a></li>\n</ol>\n</li>\n<li><p>IDE（集成开发环境）：</p>\n<ol>\n<li><p>Visual Studio（一站式安装，一键编译运行）</p>\n<p> <a href=\"https://visualstudio.microsoft.com/zh-hans/\">Visual Studio下载地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/71110525\">中文安装教程</a></p>\n</li>\n<li><p>VSCode + mingw（配置灵活且繁琐，一键编译运行）</p>\n<p> <a href=\"https://code.visualstudio.com/download\">VSCode下载地址</a>，<a href=\"https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z\">mingw压缩包地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/354400717\">vscode和mingw安装教程</a></p>\n</li>\n</ol>\n</li>\n<li><p>Linux环境（vim+gcc）</p>\n<p> 编译命令<code>gcc -o 目标文件名 源文件</code></p>\n<p> 例：<code>gcc -o test test.c</code> 将名为<code>test.c</code>的源文件编译成名为<code>test</code>的目标文件</p>\n</li>\n</ol>\n<h2 id=\"C语言程序的结构\"><a href=\"#C语言程序的结构\" class=\"headerlink\" title=\"C语言程序的结构\"></a>C语言程序的结构</h2><ul>\n<li><p>简单的C程序实例</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/* 定义一个名为num的变量 */</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/* 为num赋一个值 */</span>\n    num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* 使用printf()函数 */</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am a simple \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"computer.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"My favorite number is %d because it is first.\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<ol>\n<li><p><code>#include</code>指令和头文件</p>\n<p> <code>#include</code>这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。</p>\n<p> <code>#include &lt;stdio.h&gt;</code>的作用相当于把<code>stdio.h</code>文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。</p>\n</li>\n<li><p><code>main()</code>函数</p>\n<p> C程序从<code>main()</code>函数开始执行。除了<code>main()</code>函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。<code>int</code>是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词<code>void</code> 。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//错误的main函数定义1</span>\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//错误的main函数定义2</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//正确的main函数定义1</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//正确的main函数定义2</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> <code>int main(int argc, char *argv[])</code> 是C语言中常见的<code>main</code>函数的定义方式，它用于接收命令行参数。</p>\n<p> 参数解释：</p>\n<ul>\n<li><code>int argc</code>：表示命令行参数的数量（Argument Count）。</li>\n<li><code>char *argv[]</code>：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。</li>\n</ul>\n<p> 使用这种方式定义的<code>main</code>函数可以接收命令行传递的参数，如下所示：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"argc: %d\\n\"</span><span class=\"token punctuation\">,</span> argc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> argc<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"argv[%d]: %s\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行该程序并传递参数，例如：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">./program arg1 arg2 arg3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 程序运行结果会输出命令行参数的数量以及每个参数的值，如：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">argc: 4\nargv[0]: ./program\nargv[1]: arg1\nargv[2]: arg2\nargv[3]: arg3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>注释</p>\n<p> 在程序中，被两个<code>/* */</code>符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">/* 这是一条C注释。 */</span>\n<span class=\"token comment\">/* 这也是一条注释，\n被分成两行。*/</span>\n<span class=\"token comment\">/*\n也可以这样写注释。\n*/</span>\n<span class=\"token comment\">/* 这条注释无效，因为缺少了结束标记。\n\n// 这种注释只能写成一行</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>花括号、函数体和块</p>\n<p> 花括号把main()函数括起来。一般而言，所有的C函数都使用<code>花括号</code>标记<code>函数体的开始和结束</code>。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句<code>合并</code>为一个<code>单元或块</code>。</p>\n</li>\n<li><p>声明（declaration）</p>\n<p> 声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为<br> num的变量（<code>variable</code>）。其二，<code>int</code>表明<code>num</code>是一个<code>整数</code>（即，没有小数点或小数部分的数）。<code>int</code>是一种数据类型。编译器使用这些信息为<code>num</code>变量在内存中分配存储空间。</p>\n</li>\n<li><p>赋值</p>\n<p> 赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。</p>\n</li>\n<li><p><code>printf()</code>函数</p>\n<p> 示例代码中有3行代码都使用了C语言的一个标准函数：<code>printf()</code>。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把<code>I am a simple</code>传递给printf()函数。该信息被称为参数。</p>\n<p> 换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始</p>\n</li>\n<li><p><code>return</code>语句</p>\n<p> return语句是示例程序中的最后一条语句。<code>int main(void)</code>中的int表明main()函数应返回一个<code>整数</code>。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。</p>\n</li>\n</ol>\n<h2 id=\"C语言源程序的书写格式\"><a href=\"#C语言源程序的书写格式\" class=\"headerlink\" title=\"C语言源程序的书写格式\"></a>C语言源程序的书写格式</h2><ol>\n<li><p>缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。</p>\n</li>\n<li><p>大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 代码块</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// 计算两个数的和</span>\n<span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> numberOfStudents <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">printMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 函数体</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>换行：在较长的语句中，适当地进行换行，以保持代码的可读性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">longResult <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>longValue1 <span class=\"token operator\">+</span> longValue2 <span class=\"token operator\">+</span> longValue3<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span>\n             <span class=\"token punctuation\">(</span>longValue4 <span class=\"token operator\">-</span> longValue5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"C语言数据类型\"><a href=\"#C语言数据类型\" class=\"headerlink\" title=\"C语言数据类型\"></a>C语言数据类型</h2><ol>\n<li><p>整型（Integer）：</p>\n<ul>\n<li><code>int</code>：表示整数类型。通常占用4个字节。</li>\n<li><code>short</code>：表示短整数类型。通常占用2个字节。</li>\n<li><code>long</code>：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">short</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> num3 <span class=\"token operator\">=</span> <span class=\"token number\">30L</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 后缀L表示长整数类型</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>浮点型（Floating-point）：</p>\n<ul>\n<li><code>float</code>：表示单精度浮点数类型。通常占用4个字节。</li>\n<li><code>double</code>：表示双精度浮点数类型。通常占用8个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">float</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">3.14f</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 后缀f表示单精度浮点数类型</span>\n<span class=\"token keyword\">double</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">2.71828</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>字符型（Character）：</p>\n<ul>\n<li><code>char</code>：表示字符类型。通常占用1个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> ch1 <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> ch2 <span class=\"token operator\">=</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>布尔型（Boolean）：</p>\n<ul>\n<li><code>bool</code>：表示布尔类型，只能取<code>true</code>（非零值）或<code>false</code>（零值）。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdbool.h></span>  <span class=\"token comment\">// 需要包含stdbool.h头文件</span></span>\n\nbool flag1 <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\nbool flag2 <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"数据类型示例代码\"><a href=\"#数据类型示例代码\" class=\"headerlink\" title=\"数据类型示例代码\"></a>数据类型示例代码</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdbool.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 整型示例</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"整数num1 = %d，整型大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">short</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"短整数num2 = %hd，短整数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">long</span> num3 <span class=\"token operator\">=</span> <span class=\"token number\">30L</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"长整数num3 = %ld，长整数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 浮点型示例</span>\n    <span class=\"token keyword\">float</span> num4 <span class=\"token operator\">=</span> <span class=\"token number\">3.14f</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num4<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">double</span> num5 <span class=\"token operator\">=</span> <span class=\"token number\">2.71828</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num5<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 字符型示例</span>\n    <span class=\"token keyword\">char</span> ch1 <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"字符ch1 = %c，字符大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> ch1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ch1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">char</span> ch2 <span class=\"token operator\">=</span> <span class=\"token number\">66</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ASCII码值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"字符ch2 = %c，字符大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> ch2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ch2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 布尔型示例</span>\n    bool flag1 <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"布尔数flag1 = %d，布尔值大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> flag1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>flag1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    bool flag2 <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"布尔数flag2 = %d，布尔值大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> flag2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>flag2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"C语言的运算符\"><a href=\"#C语言的运算符\" class=\"headerlink\" title=\"C语言的运算符\"></a>C语言的运算符</h2><p>C语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：</p>\n<ol>\n<li>算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。<ul>\n<li><code>+</code>：加法运算</li>\n<li><code>-</code>：减法运算</li>\n<li>*：乘法运算</li>\n<li><code>/</code>：除法运算</li>\n<li><code>%</code>：取模（取余）运算</li>\n</ul>\n</li>\n<li>关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。<ul>\n<li><code>==</code>：等于</li>\n<li><code>!=</code>：不等于</li>\n<li><code>&lt;</code>：小于</li>\n<li><code>&gt;</code>：大于</li>\n<li><code>&lt;=</code>：小于等于</li>\n<li><code>&gt;=</code>：大于等于</li>\n</ul>\n</li>\n<li>逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。<ul>\n<li><code>&amp;&amp;</code>：逻辑与（与）</li>\n<li><code>||</code>：逻辑或（或）</li>\n<li><code>!</code>：逻辑非（非）</li>\n</ul>\n</li>\n<li>位运算符：用于对二进制数据的位进行操作。<ul>\n<li><code>&amp;</code>：按位与</li>\n<li><code>|</code>：按位或</li>\n<li><code>^</code>：按位异或</li>\n<li><code>~</code>：按位取反</li>\n<li><code>&lt;&lt;</code>：左移</li>\n<li><code>&gt;&gt;</code>：右移</li>\n</ul>\n</li>\n<li>赋值运算符：用于给变量赋值。<ul>\n<li><code>=</code>：简单赋值</li>\n<li><code>+=</code>：加法赋值</li>\n<li><code>=</code>：减法赋值</li>\n<li><code>=</code>：乘法赋值</li>\n<li><code>/=</code>：除法赋值</li>\n<li><code>%=</code>：取模赋值</li>\n<li><code>&lt;&lt;=</code>：左移赋值</li>\n<li><code>&gt;&gt;=</code>：右移赋值</li>\n<li><code>&amp;=</code>：按位与赋值</li>\n<li><code>|=</code>：按位或赋值</li>\n<li><code>^=</code>：按位异或赋值</li>\n</ul>\n</li>\n<li>自增和自减运算符：用于对变量进行递增或递减操作。<ul>\n<li><code>++</code>：自增</li>\n<li><code>-</code>：自减</li>\n</ul>\n</li>\n<li>条件运算符：用于根据条件选择不同的值。<ul>\n<li><code>? :</code>：条件表达式，也称为三元运算符。</li>\n</ul>\n</li>\n<li>其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h2><ol>\n<li><p>高级语言、低级语言、机器语言</p>\n<ol>\n<li>高级语言（High-Level Language）：<br> 高级语言是一种相对抽象和易于理解的编程语言，其目的是提供更高层次的抽象和功能，使程序员能够更容易地编写复杂的程序。高级语言使用人类可读的语法和结构，使用更高级别的概念和抽象，使得程序的编写更容易、更快速。高级语言通常需要通过编译或解释器转换为机器语言才能在计算机上执行。常见的高级语言包括C、C++、Java、Python和JavaScript等。</li>\n<li>低级语言（Low-Level Language）：<br> 低级语言是与计算机硬件更接近的编程语言，它使用更接近机器语言的语法和结构。低级语言通常直接操作计算机的底层硬件和资源，提供了对硬件细节的更多控制。低级语言可以更高效地利用计算机的资源，但编写和理解低级语言程序相对更困难。汇编语言和机器语言都属于低级语言。</li>\n<li>机器语言（Machine Language）：<br> 机器语言是计算机硬件直接能理解和执行的语言。它由二进制位组成，表示计算机指令和数据。机器语言是计算机可以直接执行的最底层的语言。每个计算机的机器语言是特定于该计算机体系结构的。编写机器语言程序需要对机器指令和二进制表示有深入的了解。由于机器语言的复杂性和难以理解，通常使用高级语言来编写程序，然后通过编译器或解释器将其转换为机器语言。</li>\n</ol>\n</li>\n<li><p>解释型语言和编译型语</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-10-53-51.png\" alt=\"1.第一周-2023-06-09-10-53-51\"></p>\n<p> Python 如此设计的原因在于将程序的执行与底层硬件进一步地分离，无需担心程序的编译、汇编以及链接过程，使得 Python 程序相较于 C 程序而言更加易于移植。</p>\n</li>\n<li><p>C语言源代码到可执行文件的过程</p>\n<ol>\n<li>C源代码：<br> 程序员使用C语言编写源代码，源代码以<code>.c</code>为扩展名。源代码包含了程序的逻辑和功能的定义。</li>\n<li>预处理：<br> 在编译之前，C预处理器会处理源代码。预处理器执行宏展开、条件编译等操作，生成经过预处理的源代码。</li>\n<li>编译：<br> 经过预处理的源代码会被编译器翻译成汇编代码。编译器将C源代码转换为汇编语言表示，生成汇编代码文件（<code>.s</code>文件）。</li>\n<li>汇编：<br> 汇编器将汇编代码转换为机器码指令。它将汇编代码文件翻译成机器可执行的指令，并生成目标文件（<code>.o</code>文件）。</li>\n<li>链接：<br> 链接器将目标文件与其他必要的库文件进行链接，生成最终的可执行文件。链接器解析目标文件中的符号引用，并将其与库函数和其他目标文件中的符号定义进行关联。链接器生成一个包含所有必要信息的可执行文件。</li>\n<li>可执行文件：<br> 最终的可执行文件是操作系统可以直接执行的二进制文件。它包含了程序的机器码指令、数据和其他必要的信息。可执行文件可以通过命令行或操作系统的运行环境来执行。</li>\n</ol>\n</li>\n<li><p>静态语言和动态语言</p>\n<ol>\n<li><p>静态语言（Static Language）：<br> 静态语言是在编译时进行类型检查的语言。在静态语言中，变量的类型在编译时确定，并且编译器会对类型进行检查。在编译过程中，变量的类型和使用方法需要在代码中明确声明和定义。静态语言的编译器会检查变量的类型是否与其使用方式相匹配，以避免类型错误。常见的静态语言包括C、C++、Java等。</p>\n<p> 优点：</p>\n<ol>\n<li>更早地发现类型错误，提前检测潜在的编程错误。</li>\n<li>在编译时进行类型检查，提高代码的稳定性和可靠性。</li>\n<li>性能较好，由于类型已经确定，编译器可以进行更多的优化。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>代码相对冗长，需要显式声明和定义类型。</li>\n<li>编译时间较长，需要进行较多的类型检查和编译过程。</li>\n</ol>\n</li>\n<li><p>动态语言（Dynamic Language）：<br> 动态语言是在运行时进行类型检查的语言。在动态语言中，变量的类型可以根据其赋值进行推断，并且可以在运行时动态地改变变量的类型。动态语言的编译器或解释器在运行时进行类型检查和解析。常见的动态语言包括Python、JavaScript、Ruby等。</p>\n<p> 优点：</p>\n<ol>\n<li>灵活性高，可以在运行时动态地改变变量的类型和行为。</li>\n<li>代码相对简洁，无需显式声明和定义类型，灵活性提高了开发效率。</li>\n</ol>\n<p> 缺点：</p>\n<ol>\n<li>需要在运行时进行类型检查和解析，性能可能相对较低。</li>\n<li>容易出现运行时类型错误，只能在运行时才能发现。</li>\n</ol>\n</li>\n</ol>\n<p> 需要注意的是，静态语言和动态语言并非绝对的对立关系，很多语言在某些方面可以具备静态语言和动态语言的特性。例如，Java是静态语言，但具备一些动态语言的特性，如反射和动态代理。同样，Python是动态语言，但也可以通过类型注解等方式实现静态类型检查。</p>\n</li>\n</ol>\n<h2 id=\"C语言开发环境\"><a href=\"#C语言开发环境\" class=\"headerlink\" title=\"C语言开发环境\"></a>C语言开发环境</h2><ol>\n<li><p>在线运行平台（一键运行）：</p>\n<ol>\n<li><a href=\"https://www.nhooo.com/tool/c/\">https://www.nhooo.com/tool/c/</a></li>\n<li><a href=\"https://www.bejson.com/runcode/c740/\">https://www.bejson.com/runcode/c740/</a></li>\n</ol>\n</li>\n<li><p>IDE（集成开发环境）：</p>\n<ol>\n<li><p>Visual Studio（一站式安装，一键编译运行）</p>\n<p> <a href=\"https://visualstudio.microsoft.com/zh-hans/\">Visual Studio下载地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/71110525\">中文安装教程</a></p>\n</li>\n<li><p>VSCode + mingw（配置灵活且繁琐，一键编译运行）</p>\n<p> <a href=\"https://code.visualstudio.com/download\">VSCode下载地址</a>，<a href=\"https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z\">mingw压缩包地址</a>，<a href=\"https://zhuanlan.zhihu.com/p/354400717\">vscode和mingw安装教程</a></p>\n</li>\n</ol>\n</li>\n<li><p>Linux环境（vim+gcc）</p>\n<p> 编译命令<code>gcc -o 目标文件名 源文件</code></p>\n<p> 例：<code>gcc -o test test.c</code> 将名为<code>test.c</code>的源文件编译成名为<code>test</code>的目标文件</p>\n</li>\n</ol>\n<h2 id=\"C语言程序的结构\"><a href=\"#C语言程序的结构\" class=\"headerlink\" title=\"C语言程序的结构\"></a>C语言程序的结构</h2><ul>\n<li><p>简单的C程序实例</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/* 定义一个名为num的变量 */</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/* 为num赋一个值 */</span>\n    num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* 使用printf()函数 */</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am a simple \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"computer.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"My favorite number is %d because it is first.\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<ol>\n<li><p><code>#include</code>指令和头文件</p>\n<p> <code>#include</code>这行代码是一条C预处理器指令。通常，C编译器在编译前会对源代码做一些准备工作，即预处理。</p>\n<p> <code>#include &lt;stdio.h&gt;</code>的作用相当于把<code>stdio.h</code>文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。</p>\n</li>\n<li><p><code>main()</code>函数</p>\n<p> C程序从<code>main()</code>函数开始执行。除了<code>main()</code>函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。<code>int</code>是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词<code>void</code> 。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//错误的main函数定义1</span>\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//错误的main函数定义2</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//正确的main函数定义1</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">//正确的main函数定义2</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> <code>int main(int argc, char *argv[])</code> 是C语言中常见的<code>main</code>函数的定义方式，它用于接收命令行参数。</p>\n<p> 参数解释：</p>\n<ul>\n<li><code>int argc</code>：表示命令行参数的数量（Argument Count）。</li>\n<li><code>char *argv[]</code>：表示命令行参数的数组（Argument Vector），是一个指针数组，每个指针指向一个以null结尾的字符串，即命令行参数的值。</li>\n</ul>\n<p> 使用这种方式定义的<code>main</code>函数可以接收命令行传递的参数，如下所示：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"argc: %d\\n\"</span><span class=\"token punctuation\">,</span> argc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> argc<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"argv[%d]: %s\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行该程序并传递参数，例如：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">./program arg1 arg2 arg3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 程序运行结果会输出命令行参数的数量以及每个参数的值，如：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">argc: 4\nargv[0]: ./program\nargv[1]: arg1\nargv[2]: arg2\nargv[3]: arg3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>注释</p>\n<p> 在程序中，被两个<code>/* */</code>符号括起来的部分是程序的注释。写注释能让他人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独放一行或多行。所有的注释都会被编译器忽略。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">/* 这是一条C注释。 */</span>\n<span class=\"token comment\">/* 这也是一条注释，\n被分成两行。*/</span>\n<span class=\"token comment\">/*\n也可以这样写注释。\n*/</span>\n<span class=\"token comment\">/* 这条注释无效，因为缺少了结束标记。\n\n// 这种注释只能写成一行</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>花括号、函数体和块</p>\n<p> 花括号把main()函数括起来。一般而言，所有的C函数都使用<code>花括号</code>标记<code>函数体的开始和结束</code>。这是规定，不能省略。只有花括号（{}）能起这种作用，圆括号（()）和方括号（[]）都不行。花括号还可用于把函数中的多条语句<code>合并</code>为一个<code>单元或块</code>。</p>\n</li>\n<li><p>声明（declaration）</p>\n<p> 声明是C语言最重要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为<br> num的变量（<code>variable</code>）。其二，<code>int</code>表明<code>num</code>是一个<code>整数</code>（即，没有小数点或小数部分的数）。<code>int</code>是一种数据类型。编译器使用这些信息为<code>num</code>变量在内存中分配存储空间。</p>\n</li>\n<li><p>赋值</p>\n<p> 赋值是C语言的基本操作之一。该行代码的意思是“把值1赋给变量num”。在执行int num;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。</p>\n</li>\n<li><p><code>printf()</code>函数</p>\n<p> 示例代码中有3行代码都使用了C语言的一个标准函数：<code>printf()</code>。圆括号表明printf是一个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例如，上面的第1行把<code>I am a simple</code>传递给printf()函数。该信息被称为参数。</p>\n<p> 换行符是一个转义序列（escape sequence）。转义序列用于代表难以表示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每个转义序列都以反斜杠字符（\\）开始</p>\n</li>\n<li><p><code>return</code>语句</p>\n<p> return语句是示例程序中的最后一条语句。<code>int main(void)</code>中的int表明main()函数应返回一个<code>整数</code>。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号（}）时会返回0。因此，可以省略main()函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。</p>\n</li>\n</ol>\n<h2 id=\"C语言源程序的书写格式\"><a href=\"#C语言源程序的书写格式\" class=\"headerlink\" title=\"C语言源程序的书写格式\"></a>C语言源程序的书写格式</h2><ol>\n<li><p>缩进：使用适当的缩进来表示代码块的层次结构，常见的缩进为4个空格或一个制表符（Tab）。</p>\n</li>\n<li><p>大括号：对于控制结构、函数等代码块，使用大括号将其括起来，以表示代码块的开始和结束。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 代码块</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>空格：在运算符、逗号、分号等符号周围添加适当的空格，以提高代码的可读性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>注释：使用注释来解释代码的功能、目的、算法等，以增加代码的可读性和可维护性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// 计算两个数的和</span>\n<span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>命名规范：使用有意义的变量名、函数名和常量名，遵循命名规范，以提高代码的可读性和可维护性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> numberOfStudents <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">printMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 函数体</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>换行：在较长的语句中，适当地进行换行，以保持代码的可读性。</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">longResult <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>longValue1 <span class=\"token operator\">+</span> longValue2 <span class=\"token operator\">+</span> longValue3<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span>\n             <span class=\"token punctuation\">(</span>longValue4 <span class=\"token operator\">-</span> longValue5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"C语言数据类型\"><a href=\"#C语言数据类型\" class=\"headerlink\" title=\"C语言数据类型\"></a>C语言数据类型</h2><ol>\n<li><p>整型（Integer）：</p>\n<ul>\n<li><code>int</code>：表示整数类型。通常占用4个字节。</li>\n<li><code>short</code>：表示短整数类型。通常占用2个字节。</li>\n<li><code>long</code>：表示长整数类型。通常占用4个或8个字节，取决于编译器和操作系统。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">short</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> num3 <span class=\"token operator\">=</span> <span class=\"token number\">30L</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 后缀L表示长整数类型</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>浮点型（Floating-point）：</p>\n<ul>\n<li><code>float</code>：表示单精度浮点数类型。通常占用4个字节。</li>\n<li><code>double</code>：表示双精度浮点数类型。通常占用8个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">float</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">3.14f</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 后缀f表示单精度浮点数类型</span>\n<span class=\"token keyword\">double</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">2.71828</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>字符型（Character）：</p>\n<ul>\n<li><code>char</code>：表示字符类型。通常占用1个字节。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> ch1 <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> ch2 <span class=\"token operator\">=</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>布尔型（Boolean）：</p>\n<ul>\n<li><code>bool</code>：表示布尔类型，只能取<code>true</code>（非零值）或<code>false</code>（零值）。</li>\n</ul>\n<p> 示例代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdbool.h></span>  <span class=\"token comment\">// 需要包含stdbool.h头文件</span></span>\n\nbool flag1 <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\nbool flag2 <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"数据类型示例代码\"><a href=\"#数据类型示例代码\" class=\"headerlink\" title=\"数据类型示例代码\"></a>数据类型示例代码</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdbool.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 整型示例</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"整数num1 = %d，整型大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">short</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"短整数num2 = %hd，短整数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">long</span> num3 <span class=\"token operator\">=</span> <span class=\"token number\">30L</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"长整数num3 = %ld，长整数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 浮点型示例</span>\n    <span class=\"token keyword\">float</span> num4 <span class=\"token operator\">=</span> <span class=\"token number\">3.14f</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"单精度浮点数num4 = %f，单精度浮点数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num4<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">double</span> num5 <span class=\"token operator\">=</span> <span class=\"token number\">2.71828</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"双精度浮点数num5 = %lf，双精度浮点数大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> num5<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>num5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 字符型示例</span>\n    <span class=\"token keyword\">char</span> ch1 <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"字符ch1 = %c，字符大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> ch1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ch1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">char</span> ch2 <span class=\"token operator\">=</span> <span class=\"token number\">66</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// ASCII码值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"字符ch2 = %c，字符大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> ch2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ch2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 布尔型示例</span>\n    bool flag1 <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"布尔数flag1 = %d，布尔值大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> flag1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>flag1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    bool flag2 <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"布尔数flag2 = %d，布尔值大小: %u 字节\\n\"</span><span class=\"token punctuation\">,</span> flag2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>flag2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"C语言的运算符\"><a href=\"#C语言的运算符\" class=\"headerlink\" title=\"C语言的运算符\"></a>C语言的运算符</h2><p>C语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：</p>\n<ol>\n<li>算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。<ul>\n<li><code>+</code>：加法运算</li>\n<li><code>-</code>：减法运算</li>\n<li>*：乘法运算</li>\n<li><code>/</code>：除法运算</li>\n<li><code>%</code>：取模（取余）运算</li>\n</ul>\n</li>\n<li>关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。<ul>\n<li><code>==</code>：等于</li>\n<li><code>!=</code>：不等于</li>\n<li><code>&lt;</code>：小于</li>\n<li><code>&gt;</code>：大于</li>\n<li><code>&lt;=</code>：小于等于</li>\n<li><code>&gt;=</code>：大于等于</li>\n</ul>\n</li>\n<li>逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。<ul>\n<li><code>&amp;&amp;</code>：逻辑与（与）</li>\n<li><code>||</code>：逻辑或（或）</li>\n<li><code>!</code>：逻辑非（非）</li>\n</ul>\n</li>\n<li>位运算符：用于对二进制数据的位进行操作。<ul>\n<li><code>&amp;</code>：按位与</li>\n<li><code>|</code>：按位或</li>\n<li><code>^</code>：按位异或</li>\n<li><code>~</code>：按位取反</li>\n<li><code>&lt;&lt;</code>：左移</li>\n<li><code>&gt;&gt;</code>：右移</li>\n</ul>\n</li>\n<li>赋值运算符：用于给变量赋值。<ul>\n<li><code>=</code>：简单赋值</li>\n<li><code>+=</code>：加法赋值</li>\n<li><code>=</code>：减法赋值</li>\n<li><code>=</code>：乘法赋值</li>\n<li><code>/=</code>：除法赋值</li>\n<li><code>%=</code>：取模赋值</li>\n<li><code>&lt;&lt;=</code>：左移赋值</li>\n<li><code>&gt;&gt;=</code>：右移赋值</li>\n<li><code>&amp;=</code>：按位与赋值</li>\n<li><code>|=</code>：按位或赋值</li>\n<li><code>^=</code>：按位异或赋值</li>\n</ul>\n</li>\n<li>自增和自减运算符：用于对变量进行递增或递减操作。<ul>\n<li><code>++</code>：自增</li>\n<li><code>-</code>：自减</li>\n</ul>\n</li>\n<li>条件运算符：用于根据条件选择不同的值。<ul>\n<li><code>? :</code>：条件表达式，也称为三元运算符。</li>\n</ul>\n</li>\n<li>其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。</li>\n</ol>\n"},{"title":"第二周","date":"2023-06-16T13:30:30.000Z","_content":"\n## C语言的运算符\n\n### 运算符分类\n\nC语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：\n\n1. 算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。\n    - `+`：加法运算\n    - `-`：减法运算\n    - `*`：乘法运算\n    - `/`：除法运算\n    - `%`：取模（取余）运算\n2. 关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。\n    - `==`：等于\n    - `!=`：不等于\n    - `<`：小于\n    - `>`：大于\n    - `<=`：小于等于\n    - `>=`：大于等于\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n        int num = 65;\n        char ch = 'A';\n    \n        printf(\"num == ch: %d\\n\", num == ch);       // 65 == 'B' -> 1 (true)\n        printf(\"num != ch: %d\\n\", num != ch);       // 65 != 'B' -> 0 (false)\n        printf(\"num > ch: %d\\n\", num > ch);         // 65 > 'B' -> 0 (false)\n        printf(\"num < ch: %d\\n\", num < ch);         // 65 < 'B' -> 0 (false)\n        printf(\"num >= ch: %d\\n\", num >= ch);       // 65 >= 'B' -> 1 (true)\n        printf(\"num <= ch: %d\\n\", num <= ch);       // 65 <= 'B' -> 1 (true)\n    \n        return 0;\n    }\n    ```\n\n3. 逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。\n    - `&&`：逻辑与（与）\n    - `||`：逻辑或（或）\n    - `!`：逻辑非（非）\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 1, b = 2, c = 3;\n    \n        // 逻辑与运算符（&&）\n        printf(\"%d\\n\", (a < b) && (b < c)); // 1 (true) && 1 (true) -> 1 (true)\n        printf(\"%d\\n\", (a < b) && (b > c)); // 1 (true) && 0 (false) -> 0 (false)\n    \n        // 逻辑或运算符（||）\n        printf(\"%d\\n\", (a < b) || (b < c)); // 1 (true) || 1 (true) -> 1 (true)\n        printf(\"%d\\n\", (a < b) || (b > c)); // 1 (true) || 0 (false) -> 1 (false)\n    \n        // 逻辑非运算符（!）\n        printf(\"%d\\n\", !(a < b)); // !(1 (true)) -> 0 (false)\n        printf(\"%d\\n\", !(a > b)); // !(0 (false)) -> 1 (true)\n    \n        return 0;\n    }\n    ```\n\n4. 位运算符：用于对二进制数据的位进行操作。\n    - `&`：按位与\n    - `|`：按位或\n    - `^`：按位异或\n    - `~`：按位取反\n    - `<<`：左移\n    - `>>`：右移\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n      //unsigned int类型通常32位，以下所有位运算省略高24位的计算，只计算后8位\n        unsigned int a = 5;   // 二进制表示为 00000101\n        unsigned int b = 3;   // 二进制表示为 00000011\n    \n        // 按位与运算符（&）\n        unsigned int result1 = a & b;    // 00000101 & 00000011 = 00000001\n        printf(\"Result 1: %u\\n\", result1); // 输出：1\n    \n        // 按位或运算符（|）\n        unsigned int result2 = a | b;    // 00000101 | 00000011 = 00000111\n        printf(\"Result 2: %u\\n\", result2); // 输出：7\n    \n        // 按位异或运算符（^）\n        unsigned int result3 = a ^ b;    // 00000101 ^ 00000011 = 00000110\n        printf(\"Result 3: %u\\n\", result3); // 输出：6\n    \n        // 按位取反运算符（~）\n        unsigned int result4 = ~a;       // ~00000101 = 11111010\n        printf(\"Result 4: %u\\n\", result4); // 输出：4294967290\n    \n        // 左移运算符（<<）\n        unsigned int result5 = a << 2;   // 00000101 << 2 = 00010100\n        printf(\"Result 5: %u\\n\", result5); // 输出：20\n    \n        // 右移运算符（>>）\n        unsigned int result6 = a >> 1;   // 00000101 >> 1 = 00000010\n        printf(\"Result 6: %u\\n\", result6); // 输出：2\n    \n        return 0;\n    }\n    ```\n\n5. 赋值运算符：用于给变量赋值。\n    - `=`：简单赋值\n    - `+=`：加法赋值\n    - `-=`：减法赋值\n    - `*=`：乘法赋值\n    - `/=`：除法赋值\n    - `%=`：取模赋值\n    - `<<=`：左移赋值\n    - `>>=`：右移赋值\n    - `&=`：按位与赋值\n    - `|=`：按位或赋值\n    - `^=`：按位异或赋值\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 5;\n        int b = 3;\n        int c = 7;\n    \n        // 取模赋值运算符（%=）\n        b %= a;\n        printf(\"b: %d\\n\", b); // 输出：3\n    \n        // 左移赋值运算符（<<=）\n        a <<= 2;\n        printf(\"a: %d\\n\", a); // 输出：20\n    \n        // 右移赋值运算符（>>=）\n        c >>= 1;\n        printf(\"c: %d\\n\", c); // 输出：3\n    \n        // 按位与赋值运算符（&=）\n        a &= b;\n        printf(\"a: %d\\n\", a); // 输出：0\n    \n        // 按位或赋值运算符（|=）\n        c |= b;\n        printf(\"c: %d\\n\", c); // 输出：3\n    \n        // 按位异或赋值运算符（^=）\n        a ^= b;\n        printf(\"a: %d\\n\", a); // 输出：3\n    \n        return 0;\n    }\n    ```\n\n6. 自增和自减运算符：用于对变量进行递增或递减操作。\n\n    - `++`：自增\n    - `--`：自减\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 5;\n        int b = 10;\n        int c;\n    \n        // 自增运算符（++）\n        c = a++;           // 先赋值后加1\n        printf(\"%d\\n\", c); // 输出：5\n    \n        // 前置自增运算符（++）\n        c = ++a;           // 先加1后赋值\n        printf(\"%d\\n\", c); // 输出：7\n    \n        // 自减运算符（--）\n        c = b--;           // 先赋值后减1\n        printf(\"%d\\n\", c); // 输出：10\n    \n        // 前置自减运算符（--）\n        c = --b;           // 先减1后赋值\n        printf(\"%d\\n\", c); // 输出：8\n    \n        return 0;\n    }\n    ```\n\n7. 条件运算符：用于根据条件选择不同的值。\n\n    - `? :`：条件表达式，也称为三元运算符。\n    - 语法格式\n\n        ```text\n        条件表达式 ? 表达式1 : 表达式2\n        ```\n\n        如果条件表达式的结果为真（非零），则整个表达式的值为表达式1的值；如果条件表达式的结果为假（零），则整个表达式的值为表达式2的值。\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n        int a = 5;\n        int b = 10;\n    \n        // 使用条件运算符选择较大的数赋给变量c\n        int c = (a > b) ? a : b;\n        printf(\"c: %d\\n\", c);   // 输出：10\n    \n        // 使用条件运算符选择绝对值较大的数赋给变量d\n        int d = (a > 0) ? a : -a;\n        printf(\"d: %d\\n\", d);   // 输出：5\n    \n        return 0;\n    }\n    ```\n\n8. 逗号运算符\n\n    逗号运算符是C语言中的一个运算符，它用逗号 `,` 分隔多个表达式，形成一个逗号表达式。逗号表达式的求值规则是从左到右依次对每个表达式进行求值，并返回最右边表达式的值作为整个逗号表达式的结果。\n\n    1. 表达式顺序执行：逗号运算符可以用于在同一个语句中按顺序执行多个表达式，每个表达式都会被求值，但只有最后一个表达式的值会作为整个逗号表达式的结果。例如：\n\n        ```c\n        int a = 1, b = 2, c = 3;\n        int result = (a++, b++, c++, a + b + c);  // 逐个增加 a、b、c 的值，然后计算 a + b + c 的结果，赋给 result\n        ```\n\n    2. 多个初始化语句：逗号运算符可以在变量初始化时一次性初始化多个变量。例如：\n\n        ```c\n        int x = 1, y = 2, z = 3;\n        int x, y, z;\n        ```\n\n9. 其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。  \n\n### 运算符优先级\n\n![1.第一周-2023-06-09-11-36-00](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png)\n\n![1.第一周-2023-06-09-11-36-08](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png)\n\n![1.第一周-2023-06-09-11-36-21](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png)\n\n### 运算符优先级示例代码\n\n```c\n#include <stdio.h>\n\nint main(void) {\n    int a = 5, b = 3, c = 7;\n    int result1 = a + b * c;        // 5 + 3 * 7 = 26\n    int result2 = (a + b) * c;      // (5 + 3) * 7 = 56\n    int result3 = a * b / c;        // 5 * 3 / 7 = 2\n    int result4 = a * (b / c);      // 5 * (3 / 7) = 0\n    int result5 = a % b + c;        // 5 % 3 + 7 = 9\n    int result6 = a << b + c;       // 5 << (3 + 7) = 5120\n    int result7 = (a << b) + c;     // (5 << 3) + 7 = 47\n    int result8 = a < b && b < c;   // 5 < 3 && 3 < 7 = 0 (false)\n    int result9 = a < b || b < c;   // 5 < 3 || 3 < 7 = 1 (true)\n    int result10 = a == b ? c : a;  // 5 == 3 ? 7 : 5 = 5\n\n    printf(\"Result 1: %d\\n\", result1);\n    printf(\"Result 2: %d\\n\", result2);\n    printf(\"Result 3: %d\\n\", result3);\n    printf(\"Result 4: %d\\n\", result4);\n    printf(\"Result 5: %d\\n\", result5);\n    printf(\"Result 6: %d\\n\", result6);\n    printf(\"Result 7: %d\\n\", result7);\n    printf(\"Result 8: %d\\n\", result8);\n    printf(\"Result 9: %d\\n\", result9);\n    printf(\"Result 10: %d\\n\", result10);\n\n    return 0;\n}\n```\n\n## 类型转换\n\n类型转换（Type Conversion）是将一个数据类型的值转换为另一个数据类型的过程。在C语言中，类型转换可分为隐式类型转换（Implicit Conversion）和显式类型转换（Explicit Conversion）两种形式。\n\n1. 隐式类型转换：隐式类型转换是指在表达式中自动进行的类型转换，不需要显式地指定转换操作符。常见的隐式类型转换有：\n    - 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。\n\n        类型的级别从高至低依次是long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。\n\n    - 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 5;\n        double b = 3.14;\n    \n        // 隐式类型转换\n        double c = a; // 将整型变量a隐式转换为double类型\n        int d = b;    // 将double类型变量b隐式转换为整型\n    \n        printf(\"c: %f\\n\", c); // 输出：5.000000\n        printf(\"d: %d\\n\", d); // 输出：3\n        printf(\"%f\", a + b);  // 输出：8.140000\n    }\n    ```\n\n2. 显式类型转换：显式类型转换是通过显式地使用类型转换操作符来执行的。它允许我们将一个数据类型强制转换为另一个数据类型。显式类型转换的语法形式如下：\n\n    ```text\n    (目标类型) 表达式\n    ```\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n        int a = 5;\n        double b = 3.14;\n    \n        // 显式类型转换\n        int e = (int)b;        // 将double类型变量b显式转换为整型\n        printf(\"e: %d\\n\", e);  // 输出：3\n    \n        return 0;\n    }\n    ```\n\n## 表达式语句，空语句，复合语句\n\n在C语言中，有三种常见的语句类型：表达式语句（Expression Statement），空语句（Empty Statement）和复合语句（Compound Statement）。\n\n1. 表达式语句（Expression Statement）：表达式语句由一个表达式和一个分号组成，用于执行一个表达式并丢弃其结果。表达式可以是函数调用、赋值表达式、递增递减表达式等。例如：\n\n    ```c\n    x = 5;           // 赋值表达式作为表达式语句\n    printf(\"Hello\"); // 函数调用作为表达式语句\n    x++;\n    ```\n\n2. 空语句（Empty Statement）：空语句只包含一个分号，用于表示一个空操作。空语句在某些情况下可以用作占位符，或者在循环中作为一个空的循环体。例如：\n\n    ```c\n    ; // 空语句\n    for (int i = 0; i < 10; i++) \n        printf(); // 空循环体\n    ```\n\n    空语句不做任何操作，它在语法上是合法的语句，但不会有任何实际的影响。\n\n3. 复合语句（Compound Statement）：复合语句是由一对花括号 `{}` 包围的语句块，可以包含多条语句。复合语句常用于定义函数体或在控制流语句中使用。例如：\n\n    ```c\n    {\n        int x = 5;          // 定义变量\n        printf(\"Value: %d\", x);\n        x++;                // 修改变量的值\n        printf(\"Updated Value: %d\", x);\n    }\n    ```\n\n    这些语句类型在C语言中用于不同的场景和目的。表达式语句用于执行表达式并丢弃结果，空语句表示一个空操作，复合语句用于组织多个语句形成一个语句块。了解这些语句类型可以帮助我们编写清晰、有效的代码。\n","source":"_posts/c_program/2.第二周.md","raw":"---\ntitle: 第二周\ndate: 2023-06-16 21:30:30\ntags: \n---\n\n## C语言的运算符\n\n### 运算符分类\n\nC语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：\n\n1. 算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。\n    - `+`：加法运算\n    - `-`：减法运算\n    - `*`：乘法运算\n    - `/`：除法运算\n    - `%`：取模（取余）运算\n2. 关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。\n    - `==`：等于\n    - `!=`：不等于\n    - `<`：小于\n    - `>`：大于\n    - `<=`：小于等于\n    - `>=`：大于等于\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n        int num = 65;\n        char ch = 'A';\n    \n        printf(\"num == ch: %d\\n\", num == ch);       // 65 == 'B' -> 1 (true)\n        printf(\"num != ch: %d\\n\", num != ch);       // 65 != 'B' -> 0 (false)\n        printf(\"num > ch: %d\\n\", num > ch);         // 65 > 'B' -> 0 (false)\n        printf(\"num < ch: %d\\n\", num < ch);         // 65 < 'B' -> 0 (false)\n        printf(\"num >= ch: %d\\n\", num >= ch);       // 65 >= 'B' -> 1 (true)\n        printf(\"num <= ch: %d\\n\", num <= ch);       // 65 <= 'B' -> 1 (true)\n    \n        return 0;\n    }\n    ```\n\n3. 逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。\n    - `&&`：逻辑与（与）\n    - `||`：逻辑或（或）\n    - `!`：逻辑非（非）\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 1, b = 2, c = 3;\n    \n        // 逻辑与运算符（&&）\n        printf(\"%d\\n\", (a < b) && (b < c)); // 1 (true) && 1 (true) -> 1 (true)\n        printf(\"%d\\n\", (a < b) && (b > c)); // 1 (true) && 0 (false) -> 0 (false)\n    \n        // 逻辑或运算符（||）\n        printf(\"%d\\n\", (a < b) || (b < c)); // 1 (true) || 1 (true) -> 1 (true)\n        printf(\"%d\\n\", (a < b) || (b > c)); // 1 (true) || 0 (false) -> 1 (false)\n    \n        // 逻辑非运算符（!）\n        printf(\"%d\\n\", !(a < b)); // !(1 (true)) -> 0 (false)\n        printf(\"%d\\n\", !(a > b)); // !(0 (false)) -> 1 (true)\n    \n        return 0;\n    }\n    ```\n\n4. 位运算符：用于对二进制数据的位进行操作。\n    - `&`：按位与\n    - `|`：按位或\n    - `^`：按位异或\n    - `~`：按位取反\n    - `<<`：左移\n    - `>>`：右移\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n      //unsigned int类型通常32位，以下所有位运算省略高24位的计算，只计算后8位\n        unsigned int a = 5;   // 二进制表示为 00000101\n        unsigned int b = 3;   // 二进制表示为 00000011\n    \n        // 按位与运算符（&）\n        unsigned int result1 = a & b;    // 00000101 & 00000011 = 00000001\n        printf(\"Result 1: %u\\n\", result1); // 输出：1\n    \n        // 按位或运算符（|）\n        unsigned int result2 = a | b;    // 00000101 | 00000011 = 00000111\n        printf(\"Result 2: %u\\n\", result2); // 输出：7\n    \n        // 按位异或运算符（^）\n        unsigned int result3 = a ^ b;    // 00000101 ^ 00000011 = 00000110\n        printf(\"Result 3: %u\\n\", result3); // 输出：6\n    \n        // 按位取反运算符（~）\n        unsigned int result4 = ~a;       // ~00000101 = 11111010\n        printf(\"Result 4: %u\\n\", result4); // 输出：4294967290\n    \n        // 左移运算符（<<）\n        unsigned int result5 = a << 2;   // 00000101 << 2 = 00010100\n        printf(\"Result 5: %u\\n\", result5); // 输出：20\n    \n        // 右移运算符（>>）\n        unsigned int result6 = a >> 1;   // 00000101 >> 1 = 00000010\n        printf(\"Result 6: %u\\n\", result6); // 输出：2\n    \n        return 0;\n    }\n    ```\n\n5. 赋值运算符：用于给变量赋值。\n    - `=`：简单赋值\n    - `+=`：加法赋值\n    - `-=`：减法赋值\n    - `*=`：乘法赋值\n    - `/=`：除法赋值\n    - `%=`：取模赋值\n    - `<<=`：左移赋值\n    - `>>=`：右移赋值\n    - `&=`：按位与赋值\n    - `|=`：按位或赋值\n    - `^=`：按位异或赋值\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 5;\n        int b = 3;\n        int c = 7;\n    \n        // 取模赋值运算符（%=）\n        b %= a;\n        printf(\"b: %d\\n\", b); // 输出：3\n    \n        // 左移赋值运算符（<<=）\n        a <<= 2;\n        printf(\"a: %d\\n\", a); // 输出：20\n    \n        // 右移赋值运算符（>>=）\n        c >>= 1;\n        printf(\"c: %d\\n\", c); // 输出：3\n    \n        // 按位与赋值运算符（&=）\n        a &= b;\n        printf(\"a: %d\\n\", a); // 输出：0\n    \n        // 按位或赋值运算符（|=）\n        c |= b;\n        printf(\"c: %d\\n\", c); // 输出：3\n    \n        // 按位异或赋值运算符（^=）\n        a ^= b;\n        printf(\"a: %d\\n\", a); // 输出：3\n    \n        return 0;\n    }\n    ```\n\n6. 自增和自减运算符：用于对变量进行递增或递减操作。\n\n    - `++`：自增\n    - `--`：自减\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 5;\n        int b = 10;\n        int c;\n    \n        // 自增运算符（++）\n        c = a++;           // 先赋值后加1\n        printf(\"%d\\n\", c); // 输出：5\n    \n        // 前置自增运算符（++）\n        c = ++a;           // 先加1后赋值\n        printf(\"%d\\n\", c); // 输出：7\n    \n        // 自减运算符（--）\n        c = b--;           // 先赋值后减1\n        printf(\"%d\\n\", c); // 输出：10\n    \n        // 前置自减运算符（--）\n        c = --b;           // 先减1后赋值\n        printf(\"%d\\n\", c); // 输出：8\n    \n        return 0;\n    }\n    ```\n\n7. 条件运算符：用于根据条件选择不同的值。\n\n    - `? :`：条件表达式，也称为三元运算符。\n    - 语法格式\n\n        ```text\n        条件表达式 ? 表达式1 : 表达式2\n        ```\n\n        如果条件表达式的结果为真（非零），则整个表达式的值为表达式1的值；如果条件表达式的结果为假（零），则整个表达式的值为表达式2的值。\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n        int a = 5;\n        int b = 10;\n    \n        // 使用条件运算符选择较大的数赋给变量c\n        int c = (a > b) ? a : b;\n        printf(\"c: %d\\n\", c);   // 输出：10\n    \n        // 使用条件运算符选择绝对值较大的数赋给变量d\n        int d = (a > 0) ? a : -a;\n        printf(\"d: %d\\n\", d);   // 输出：5\n    \n        return 0;\n    }\n    ```\n\n8. 逗号运算符\n\n    逗号运算符是C语言中的一个运算符，它用逗号 `,` 分隔多个表达式，形成一个逗号表达式。逗号表达式的求值规则是从左到右依次对每个表达式进行求值，并返回最右边表达式的值作为整个逗号表达式的结果。\n\n    1. 表达式顺序执行：逗号运算符可以用于在同一个语句中按顺序执行多个表达式，每个表达式都会被求值，但只有最后一个表达式的值会作为整个逗号表达式的结果。例如：\n\n        ```c\n        int a = 1, b = 2, c = 3;\n        int result = (a++, b++, c++, a + b + c);  // 逐个增加 a、b、c 的值，然后计算 a + b + c 的结果，赋给 result\n        ```\n\n    2. 多个初始化语句：逗号运算符可以在变量初始化时一次性初始化多个变量。例如：\n\n        ```c\n        int x = 1, y = 2, z = 3;\n        int x, y, z;\n        ```\n\n9. 其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。  \n\n### 运算符优先级\n\n![1.第一周-2023-06-09-11-36-00](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png)\n\n![1.第一周-2023-06-09-11-36-08](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png)\n\n![1.第一周-2023-06-09-11-36-21](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png)\n\n### 运算符优先级示例代码\n\n```c\n#include <stdio.h>\n\nint main(void) {\n    int a = 5, b = 3, c = 7;\n    int result1 = a + b * c;        // 5 + 3 * 7 = 26\n    int result2 = (a + b) * c;      // (5 + 3) * 7 = 56\n    int result3 = a * b / c;        // 5 * 3 / 7 = 2\n    int result4 = a * (b / c);      // 5 * (3 / 7) = 0\n    int result5 = a % b + c;        // 5 % 3 + 7 = 9\n    int result6 = a << b + c;       // 5 << (3 + 7) = 5120\n    int result7 = (a << b) + c;     // (5 << 3) + 7 = 47\n    int result8 = a < b && b < c;   // 5 < 3 && 3 < 7 = 0 (false)\n    int result9 = a < b || b < c;   // 5 < 3 || 3 < 7 = 1 (true)\n    int result10 = a == b ? c : a;  // 5 == 3 ? 7 : 5 = 5\n\n    printf(\"Result 1: %d\\n\", result1);\n    printf(\"Result 2: %d\\n\", result2);\n    printf(\"Result 3: %d\\n\", result3);\n    printf(\"Result 4: %d\\n\", result4);\n    printf(\"Result 5: %d\\n\", result5);\n    printf(\"Result 6: %d\\n\", result6);\n    printf(\"Result 7: %d\\n\", result7);\n    printf(\"Result 8: %d\\n\", result8);\n    printf(\"Result 9: %d\\n\", result9);\n    printf(\"Result 10: %d\\n\", result10);\n\n    return 0;\n}\n```\n\n## 类型转换\n\n类型转换（Type Conversion）是将一个数据类型的值转换为另一个数据类型的过程。在C语言中，类型转换可分为隐式类型转换（Implicit Conversion）和显式类型转换（Explicit Conversion）两种形式。\n\n1. 隐式类型转换：隐式类型转换是指在表达式中自动进行的类型转换，不需要显式地指定转换操作符。常见的隐式类型转换有：\n    - 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。\n\n        类型的级别从高至低依次是long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。\n\n    - 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void)\n    {\n        int a = 5;\n        double b = 3.14;\n    \n        // 隐式类型转换\n        double c = a; // 将整型变量a隐式转换为double类型\n        int d = b;    // 将double类型变量b隐式转换为整型\n    \n        printf(\"c: %f\\n\", c); // 输出：5.000000\n        printf(\"d: %d\\n\", d); // 输出：3\n        printf(\"%f\", a + b);  // 输出：8.140000\n    }\n    ```\n\n2. 显式类型转换：显式类型转换是通过显式地使用类型转换操作符来执行的。它允许我们将一个数据类型强制转换为另一个数据类型。显式类型转换的语法形式如下：\n\n    ```text\n    (目标类型) 表达式\n    ```\n\n    ```c\n    #include <stdio.h>\n    \n    int main(void) {\n        int a = 5;\n        double b = 3.14;\n    \n        // 显式类型转换\n        int e = (int)b;        // 将double类型变量b显式转换为整型\n        printf(\"e: %d\\n\", e);  // 输出：3\n    \n        return 0;\n    }\n    ```\n\n## 表达式语句，空语句，复合语句\n\n在C语言中，有三种常见的语句类型：表达式语句（Expression Statement），空语句（Empty Statement）和复合语句（Compound Statement）。\n\n1. 表达式语句（Expression Statement）：表达式语句由一个表达式和一个分号组成，用于执行一个表达式并丢弃其结果。表达式可以是函数调用、赋值表达式、递增递减表达式等。例如：\n\n    ```c\n    x = 5;           // 赋值表达式作为表达式语句\n    printf(\"Hello\"); // 函数调用作为表达式语句\n    x++;\n    ```\n\n2. 空语句（Empty Statement）：空语句只包含一个分号，用于表示一个空操作。空语句在某些情况下可以用作占位符，或者在循环中作为一个空的循环体。例如：\n\n    ```c\n    ; // 空语句\n    for (int i = 0; i < 10; i++) \n        printf(); // 空循环体\n    ```\n\n    空语句不做任何操作，它在语法上是合法的语句，但不会有任何实际的影响。\n\n3. 复合语句（Compound Statement）：复合语句是由一对花括号 `{}` 包围的语句块，可以包含多条语句。复合语句常用于定义函数体或在控制流语句中使用。例如：\n\n    ```c\n    {\n        int x = 5;          // 定义变量\n        printf(\"Value: %d\", x);\n        x++;                // 修改变量的值\n        printf(\"Updated Value: %d\", x);\n    }\n    ```\n\n    这些语句类型在C语言中用于不同的场景和目的。表达式语句用于执行表达式并丢弃结果，空语句表示一个空操作，复合语句用于组织多个语句形成一个语句块。了解这些语句类型可以帮助我们编写清晰、有效的代码。\n","slug":"c_program/2.第二周","published":1,"updated":"2023-06-18T07:30:34.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04b00021dnzc0un0mmf","content":"<h2 id=\"C语言的运算符\"><a href=\"#C语言的运算符\" class=\"headerlink\" title=\"C语言的运算符\"></a>C语言的运算符</h2><h3 id=\"运算符分类\"><a href=\"#运算符分类\" class=\"headerlink\" title=\"运算符分类\"></a>运算符分类</h3><p>C语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：</p>\n<ol>\n<li><p>算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。</p>\n<ul>\n<li><code>+</code>：加法运算</li>\n<li><code>-</code>：减法运算</li>\n<li><code>*</code>：乘法运算</li>\n<li><code>/</code>：除法运算</li>\n<li><code>%</code>：取模（取余）运算</li>\n</ul>\n</li>\n<li><p>关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。</p>\n<ul>\n<li><code>==</code>：等于</li>\n<li><code>!=</code>：不等于</li>\n<li><code>&lt;</code>：小于</li>\n<li><code>&gt;</code>：大于</li>\n<li><code>&lt;=</code>：小于等于</li>\n<li><code>&gt;=</code>：大于等于</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">65</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num == ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">==</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 == 'B' -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num != ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">!=</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 != 'B' -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num > ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">></span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 65 > 'B' -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num &lt; ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">&lt;</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 65 &lt; 'B' -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num >= ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">>=</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 >= 'B' -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num &lt;= ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">&lt;=</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 &lt;= 'B' -> 1 (true)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。</p>\n<ul>\n<li><code>&amp;&amp;</code>：逻辑与（与）</li>\n<li><code>||</code>：逻辑或（或）</li>\n<li><code>!</code>：逻辑非（非）</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 逻辑与运算符（&amp;&amp;）</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) &amp;&amp; 1 (true) -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">></span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) &amp;&amp; 0 (false) -> 0 (false)</span>\n\n    <span class=\"token comment\">// 逻辑或运算符（||）</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) || 1 (true) -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">></span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) || 0 (false) -> 1 (false)</span>\n\n    <span class=\"token comment\">// 逻辑非运算符（!）</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// !(1 (true)) -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// !(0 (false)) -> 1 (true)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>位运算符：用于对二进制数据的位进行操作。</p>\n<ul>\n<li><code>&amp;</code>：按位与</li>\n<li><code>|</code>：按位或</li>\n<li><code>^</code>：按位异或</li>\n<li><code>~</code>：按位取反</li>\n<li><code>&lt;&lt;</code>：左移</li>\n<li><code>&gt;&gt;</code>：右移</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">//unsigned int类型通常32位，以下所有位运算省略高24位的计算，只计算后8位</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 二进制表示为 00000101</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 二进制表示为 00000011</span>\n\n    <span class=\"token comment\">// 按位与运算符（&amp;）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result1 <span class=\"token operator\">=</span> a <span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 00000101 &amp; 00000011 = 00000001</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 1: %u\\n\"</span><span class=\"token punctuation\">,</span> result1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：1</span>\n\n    <span class=\"token comment\">// 按位或运算符（|）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result2 <span class=\"token operator\">=</span> a <span class=\"token operator\">|</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 00000101 | 00000011 = 00000111</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 2: %u\\n\"</span><span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：7</span>\n\n    <span class=\"token comment\">// 按位异或运算符（^）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result3 <span class=\"token operator\">=</span> a <span class=\"token operator\">^</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 00000101 ^ 00000011 = 00000110</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 3: %u\\n\"</span><span class=\"token punctuation\">,</span> result3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：6</span>\n\n    <span class=\"token comment\">// 按位取反运算符（~）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result4 <span class=\"token operator\">=</span> <span class=\"token operator\">~</span>a<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// ~00000101 = 11111010</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 4: %u\\n\"</span><span class=\"token punctuation\">,</span> result4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：4294967290</span>\n\n    <span class=\"token comment\">// 左移运算符（&lt;&lt;）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result5 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 00000101 &lt;&lt; 2 = 00010100</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 5: %u\\n\"</span><span class=\"token punctuation\">,</span> result5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：20</span>\n\n    <span class=\"token comment\">// 右移运算符（>>）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result6 <span class=\"token operator\">=</span> a <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 00000101 >> 1 = 00000010</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 6: %u\\n\"</span><span class=\"token punctuation\">,</span> result6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：2</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>赋值运算符：用于给变量赋值。</p>\n<ul>\n<li><code>=</code>：简单赋值</li>\n<li><code>+=</code>：加法赋值</li>\n<li><code>-=</code>：减法赋值</li>\n<li><code>*=</code>：乘法赋值</li>\n<li><code>/=</code>：除法赋值</li>\n<li><code>%=</code>：取模赋值</li>\n<li><code>&lt;&lt;=</code>：左移赋值</li>\n<li><code>&gt;&gt;=</code>：右移赋值</li>\n<li><code>&amp;=</code>：按位与赋值</li>\n<li><code>|=</code>：按位或赋值</li>\n<li><code>^=</code>：按位异或赋值</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 取模赋值运算符（%=）</span>\n    b <span class=\"token operator\">%=</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b: %d\\n\"</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token comment\">// 左移赋值运算符（&lt;&lt;=）</span>\n    a <span class=\"token operator\">&lt;&lt;=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：20</span>\n\n    <span class=\"token comment\">// 右移赋值运算符（>>=）</span>\n    c <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token comment\">// 按位与赋值运算符（&amp;=）</span>\n    a <span class=\"token operator\">&amp;=</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：0</span>\n\n    <span class=\"token comment\">// 按位或赋值运算符（|=）</span>\n    c <span class=\"token operator\">|=</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token comment\">// 按位异或赋值运算符（^=）</span>\n    a <span class=\"token operator\">^=</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>自增和自减运算符：用于对变量进行递增或递减操作。</p>\n<ul>\n<li><code>++</code>：自增</li>\n<li><code>--</code>：自减</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 自增运算符（++）</span>\n    c <span class=\"token operator\">=</span> a<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先赋值后加1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：5</span>\n\n    <span class=\"token comment\">// 前置自增运算符（++）</span>\n    c <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>a<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先加1后赋值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：7</span>\n\n    <span class=\"token comment\">// 自减运算符（--）</span>\n    c <span class=\"token operator\">=</span> b<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先赋值后减1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：10</span>\n\n    <span class=\"token comment\">// 前置自减运算符（--）</span>\n    c <span class=\"token operator\">=</span> <span class=\"token operator\">--</span>b<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先减1后赋值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：8</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>条件运算符：用于根据条件选择不同的值。</p>\n<ul>\n<li><p><code>? :</code>：条件表达式，也称为三元运算符。</p>\n</li>\n<li><p>语法格式</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">条件表达式 ? 表达式1 : 表达式2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  如果条件表达式的结果为真（非零），则整个表达式的值为表达式1的值；如果条件表达式的结果为假（零），则整个表达式的值为表达式2的值。</p>\n</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 使用条件运算符选择较大的数赋给变量c</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 输出：10</span>\n\n    <span class=\"token comment\">// 使用条件运算符选择绝对值较大的数赋给变量d</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> <span class=\"token operator\">-</span>a<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"d: %d\\n\"</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 输出：5</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逗号运算符</p>\n<p> 逗号运算符是C语言中的一个运算符，它用逗号 <code>,</code> 分隔多个表达式，形成一个逗号表达式。逗号表达式的求值规则是从左到右依次对每个表达式进行求值，并返回最右边表达式的值作为整个逗号表达式的结果。</p>\n<ol>\n<li><p>表达式顺序执行：逗号运算符可以用于在同一个语句中按顺序执行多个表达式，每个表达式都会被求值，但只有最后一个表达式的值会作为整个逗号表达式的结果。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 逐个增加 a、b、c 的值，然后计算 a + b + c 的结果，赋给 result</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>多个初始化语句：逗号运算符可以在变量初始化时一次性初始化多个变量。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> z <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p>其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。</p>\n</li>\n</ol>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png\" alt=\"1.第一周-2023-06-09-11-36-00\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png\" alt=\"1.第一周-2023-06-09-11-36-08\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png\" alt=\"1.第一周-2023-06-09-11-36-21\"></p>\n<h3 id=\"运算符优先级示例代码\"><a href=\"#运算符优先级示例代码\" class=\"headerlink\" title=\"运算符优先级示例代码\"></a>运算符优先级示例代码</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result1 <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">*</span> c<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5 + 3 * 7 = 26</span>\n    <span class=\"token keyword\">int</span> result2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> c<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// (5 + 3) * 7 = 56</span>\n    <span class=\"token keyword\">int</span> result3 <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> b <span class=\"token operator\">/</span> c<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5 * 3 / 7 = 2</span>\n    <span class=\"token keyword\">int</span> result4 <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">/</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 5 * (3 / 7) = 0</span>\n    <span class=\"token keyword\">int</span> result5 <span class=\"token operator\">=</span> a <span class=\"token operator\">%</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5 % 3 + 7 = 9</span>\n    <span class=\"token keyword\">int</span> result6 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;&lt;</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 5 &lt;&lt; (3 + 7) = 5120</span>\n    <span class=\"token keyword\">int</span> result7 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// (5 &lt;&lt; 3) + 7 = 47</span>\n    <span class=\"token keyword\">int</span> result8 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">&amp;&amp;</span> b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 5 &lt; 3 &amp;&amp; 3 &lt; 7 = 0 (false)</span>\n    <span class=\"token keyword\">int</span> result9 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">||</span> b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 5 &lt; 3 || 3 &lt; 7 = 1 (true)</span>\n    <span class=\"token keyword\">int</span> result10 <span class=\"token operator\">=</span> a <span class=\"token operator\">==</span> b <span class=\"token operator\">?</span> c <span class=\"token operator\">:</span> a<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 5 == 3 ? 7 : 5 = 5</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 1: %d\\n\"</span><span class=\"token punctuation\">,</span> result1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 2: %d\\n\"</span><span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 3: %d\\n\"</span><span class=\"token punctuation\">,</span> result3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 4: %d\\n\"</span><span class=\"token punctuation\">,</span> result4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 5: %d\\n\"</span><span class=\"token punctuation\">,</span> result5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 6: %d\\n\"</span><span class=\"token punctuation\">,</span> result6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 7: %d\\n\"</span><span class=\"token punctuation\">,</span> result7<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 8: %d\\n\"</span><span class=\"token punctuation\">,</span> result8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 9: %d\\n\"</span><span class=\"token punctuation\">,</span> result9<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 10: %d\\n\"</span><span class=\"token punctuation\">,</span> result10<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>类型转换（Type Conversion）是将一个数据类型的值转换为另一个数据类型的过程。在C语言中，类型转换可分为隐式类型转换（Implicit Conversion）和显式类型转换（Explicit Conversion）两种形式。</p>\n<ol>\n<li><p>隐式类型转换：隐式类型转换是指在表达式中自动进行的类型转换，不需要显式地指定转换操作符。常见的隐式类型转换有：</p>\n<ul>\n<li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。</p>\n<p>  类型的级别从高至低依次是long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。</p>\n</li>\n<li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。</p>\n</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 隐式类型转换</span>\n    <span class=\"token keyword\">double</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将整型变量a隐式转换为double类型</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 将double类型变量b隐式转换为整型</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %f\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：5.000000</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"d: %d\\n\"</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%f\"</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出：8.140000</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>显式类型转换：显式类型转换是通过显式地使用类型转换操作符来执行的。它允许我们将一个数据类型强制转换为另一个数据类型。显式类型转换的语法形式如下：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">(目标类型) 表达式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 显式类型转换</span>\n    <span class=\"token keyword\">int</span> e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>b<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 将double类型变量b显式转换为整型</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"e: %d\\n\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"表达式语句，空语句，复合语句\"><a href=\"#表达式语句，空语句，复合语句\" class=\"headerlink\" title=\"表达式语句，空语句，复合语句\"></a>表达式语句，空语句，复合语句</h2><p>在C语言中，有三种常见的语句类型：表达式语句（Expression Statement），空语句（Empty Statement）和复合语句（Compound Statement）。</p>\n<ol>\n<li><p>表达式语句（Expression Statement）：表达式语句由一个表达式和一个分号组成，用于执行一个表达式并丢弃其结果。表达式可以是函数调用、赋值表达式、递增递减表达式等。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 赋值表达式作为表达式语句</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数调用作为表达式语句</span>\nx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>空语句（Empty Statement）：空语句只包含一个分号，用于表示一个空操作。空语句在某些情况下可以用作占位符，或者在循环中作为一个空的循环体。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 空语句</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 空循环体</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p> 空语句不做任何操作，它在语法上是合法的语句，但不会有任何实际的影响。</p>\n</li>\n<li><p>复合语句（Compound Statement）：复合语句是由一对花括号 <code>&#123;&#125;</code> 包围的语句块，可以包含多条语句。复合语句常用于定义函数体或在控制流语句中使用。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// 定义变量</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value: %d\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    x<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\">// 修改变量的值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Updated Value: %d\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 这些语句类型在C语言中用于不同的场景和目的。表达式语句用于执行表达式并丢弃结果，空语句表示一个空操作，复合语句用于组织多个语句形成一个语句块。了解这些语句类型可以帮助我们编写清晰、有效的代码。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C语言的运算符\"><a href=\"#C语言的运算符\" class=\"headerlink\" title=\"C语言的运算符\"></a>C语言的运算符</h2><h3 id=\"运算符分类\"><a href=\"#运算符分类\" class=\"headerlink\" title=\"运算符分类\"></a>运算符分类</h3><p>C语言中有多种类型的运算符，用于执行各种算术、逻辑和位操作。以下是C语言中常见的运算符类型：</p>\n<ol>\n<li><p>算术运算符：用于执行基本的算术操作，如加法、减法、乘法、除法、取模等。</p>\n<ul>\n<li><code>+</code>：加法运算</li>\n<li><code>-</code>：减法运算</li>\n<li><code>*</code>：乘法运算</li>\n<li><code>/</code>：除法运算</li>\n<li><code>%</code>：取模（取余）运算</li>\n</ul>\n</li>\n<li><p>关系运算符：用于比较两个值之间的关系，返回一个布尔值（1表示真，0表示假）。</p>\n<ul>\n<li><code>==</code>：等于</li>\n<li><code>!=</code>：不等于</li>\n<li><code>&lt;</code>：小于</li>\n<li><code>&gt;</code>：大于</li>\n<li><code>&lt;=</code>：小于等于</li>\n<li><code>&gt;=</code>：大于等于</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">65</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num == ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">==</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 == 'B' -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num != ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">!=</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 != 'B' -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num > ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">></span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 65 > 'B' -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num &lt; ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">&lt;</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 65 &lt; 'B' -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num >= ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">>=</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 >= 'B' -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num &lt;= ch: %d\\n\"</span><span class=\"token punctuation\">,</span> num <span class=\"token operator\">&lt;=</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 65 &lt;= 'B' -> 1 (true)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逻辑运算符：用于执行逻辑操作，对布尔值进行组合和求反。</p>\n<ul>\n<li><code>&amp;&amp;</code>：逻辑与（与）</li>\n<li><code>||</code>：逻辑或（或）</li>\n<li><code>!</code>：逻辑非（非）</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 逻辑与运算符（&amp;&amp;）</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) &amp;&amp; 1 (true) -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">></span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) &amp;&amp; 0 (false) -> 0 (false)</span>\n\n    <span class=\"token comment\">// 逻辑或运算符（||）</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) || 1 (true) -> 1 (true)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">></span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 (true) || 0 (false) -> 1 (false)</span>\n\n    <span class=\"token comment\">// 逻辑非运算符（!）</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// !(1 (true)) -> 0 (false)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// !(0 (false)) -> 1 (true)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>位运算符：用于对二进制数据的位进行操作。</p>\n<ul>\n<li><code>&amp;</code>：按位与</li>\n<li><code>|</code>：按位或</li>\n<li><code>^</code>：按位异或</li>\n<li><code>~</code>：按位取反</li>\n<li><code>&lt;&lt;</code>：左移</li>\n<li><code>&gt;&gt;</code>：右移</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">//unsigned int类型通常32位，以下所有位运算省略高24位的计算，只计算后8位</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 二进制表示为 00000101</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 二进制表示为 00000011</span>\n\n    <span class=\"token comment\">// 按位与运算符（&amp;）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result1 <span class=\"token operator\">=</span> a <span class=\"token operator\">&amp;</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 00000101 &amp; 00000011 = 00000001</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 1: %u\\n\"</span><span class=\"token punctuation\">,</span> result1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：1</span>\n\n    <span class=\"token comment\">// 按位或运算符（|）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result2 <span class=\"token operator\">=</span> a <span class=\"token operator\">|</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 00000101 | 00000011 = 00000111</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 2: %u\\n\"</span><span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：7</span>\n\n    <span class=\"token comment\">// 按位异或运算符（^）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result3 <span class=\"token operator\">=</span> a <span class=\"token operator\">^</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 00000101 ^ 00000011 = 00000110</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 3: %u\\n\"</span><span class=\"token punctuation\">,</span> result3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：6</span>\n\n    <span class=\"token comment\">// 按位取反运算符（~）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result4 <span class=\"token operator\">=</span> <span class=\"token operator\">~</span>a<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// ~00000101 = 11111010</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 4: %u\\n\"</span><span class=\"token punctuation\">,</span> result4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：4294967290</span>\n\n    <span class=\"token comment\">// 左移运算符（&lt;&lt;）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result5 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 00000101 &lt;&lt; 2 = 00010100</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 5: %u\\n\"</span><span class=\"token punctuation\">,</span> result5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：20</span>\n\n    <span class=\"token comment\">// 右移运算符（>>）</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> result6 <span class=\"token operator\">=</span> a <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 00000101 >> 1 = 00000010</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 6: %u\\n\"</span><span class=\"token punctuation\">,</span> result6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：2</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>赋值运算符：用于给变量赋值。</p>\n<ul>\n<li><code>=</code>：简单赋值</li>\n<li><code>+=</code>：加法赋值</li>\n<li><code>-=</code>：减法赋值</li>\n<li><code>*=</code>：乘法赋值</li>\n<li><code>/=</code>：除法赋值</li>\n<li><code>%=</code>：取模赋值</li>\n<li><code>&lt;&lt;=</code>：左移赋值</li>\n<li><code>&gt;&gt;=</code>：右移赋值</li>\n<li><code>&amp;=</code>：按位与赋值</li>\n<li><code>|=</code>：按位或赋值</li>\n<li><code>^=</code>：按位异或赋值</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 取模赋值运算符（%=）</span>\n    b <span class=\"token operator\">%=</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b: %d\\n\"</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token comment\">// 左移赋值运算符（&lt;&lt;=）</span>\n    a <span class=\"token operator\">&lt;&lt;=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：20</span>\n\n    <span class=\"token comment\">// 右移赋值运算符（>>=）</span>\n    c <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token comment\">// 按位与赋值运算符（&amp;=）</span>\n    a <span class=\"token operator\">&amp;=</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：0</span>\n\n    <span class=\"token comment\">// 按位或赋值运算符（|=）</span>\n    c <span class=\"token operator\">|=</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token comment\">// 按位异或赋值运算符（^=）</span>\n    a <span class=\"token operator\">^=</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>自增和自减运算符：用于对变量进行递增或递减操作。</p>\n<ul>\n<li><code>++</code>：自增</li>\n<li><code>--</code>：自减</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 自增运算符（++）</span>\n    c <span class=\"token operator\">=</span> a<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先赋值后加1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：5</span>\n\n    <span class=\"token comment\">// 前置自增运算符（++）</span>\n    c <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>a<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先加1后赋值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：7</span>\n\n    <span class=\"token comment\">// 自减运算符（--）</span>\n    c <span class=\"token operator\">=</span> b<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先赋值后减1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：10</span>\n\n    <span class=\"token comment\">// 前置自减运算符（--）</span>\n    c <span class=\"token operator\">=</span> <span class=\"token operator\">--</span>b<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 先减1后赋值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：8</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>条件运算符：用于根据条件选择不同的值。</p>\n<ul>\n<li><p><code>? :</code>：条件表达式，也称为三元运算符。</p>\n</li>\n<li><p>语法格式</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">条件表达式 ? 表达式1 : 表达式2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  如果条件表达式的结果为真（非零），则整个表达式的值为表达式1的值；如果条件表达式的结果为假（零），则整个表达式的值为表达式2的值。</p>\n</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 使用条件运算符选择较大的数赋给变量c</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %d\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 输出：10</span>\n\n    <span class=\"token comment\">// 使用条件运算符选择绝对值较大的数赋给变量d</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> a <span class=\"token operator\">:</span> <span class=\"token operator\">-</span>a<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"d: %d\\n\"</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 输出：5</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逗号运算符</p>\n<p> 逗号运算符是C语言中的一个运算符，它用逗号 <code>,</code> 分隔多个表达式，形成一个逗号表达式。逗号表达式的求值规则是从左到右依次对每个表达式进行求值，并返回最右边表达式的值作为整个逗号表达式的结果。</p>\n<ol>\n<li><p>表达式顺序执行：逗号运算符可以用于在同一个语句中按顺序执行多个表达式，每个表达式都会被求值，但只有最后一个表达式的值会作为整个逗号表达式的结果。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 逐个增加 a、b、c 的值，然后计算 a + b + c 的结果，赋给 result</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>多个初始化语句：逗号运算符可以在变量初始化时一次性初始化多个变量。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> z <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p>其他运算符：还有一些其他类型的运算符，如指针运算符、sizeof运算符、类型转换运算符等。</p>\n</li>\n</ol>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-00.png\" alt=\"1.第一周-2023-06-09-11-36-00\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-08.png\" alt=\"1.第一周-2023-06-09-11-36-08\"></p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E7%AC%AC%E4%B8%80%E5%91%A8-2023-06-09-11-36-21.png\" alt=\"1.第一周-2023-06-09-11-36-21\"></p>\n<h3 id=\"运算符优先级示例代码\"><a href=\"#运算符优先级示例代码\" class=\"headerlink\" title=\"运算符优先级示例代码\"></a>运算符优先级示例代码</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result1 <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">*</span> c<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5 + 3 * 7 = 26</span>\n    <span class=\"token keyword\">int</span> result2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> c<span class=\"token punctuation\">;</span>      <span class=\"token comment\">// (5 + 3) * 7 = 56</span>\n    <span class=\"token keyword\">int</span> result3 <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> b <span class=\"token operator\">/</span> c<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5 * 3 / 7 = 2</span>\n    <span class=\"token keyword\">int</span> result4 <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>b <span class=\"token operator\">/</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// 5 * (3 / 7) = 0</span>\n    <span class=\"token keyword\">int</span> result5 <span class=\"token operator\">=</span> a <span class=\"token operator\">%</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5 % 3 + 7 = 9</span>\n    <span class=\"token keyword\">int</span> result6 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;&lt;</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 5 &lt;&lt; (3 + 7) = 5120</span>\n    <span class=\"token keyword\">int</span> result7 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;&lt;</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// (5 &lt;&lt; 3) + 7 = 47</span>\n    <span class=\"token keyword\">int</span> result8 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">&amp;&amp;</span> b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 5 &lt; 3 &amp;&amp; 3 &lt; 7 = 0 (false)</span>\n    <span class=\"token keyword\">int</span> result9 <span class=\"token operator\">=</span> a <span class=\"token operator\">&lt;</span> b <span class=\"token operator\">||</span> b <span class=\"token operator\">&lt;</span> c<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 5 &lt; 3 || 3 &lt; 7 = 1 (true)</span>\n    <span class=\"token keyword\">int</span> result10 <span class=\"token operator\">=</span> a <span class=\"token operator\">==</span> b <span class=\"token operator\">?</span> c <span class=\"token operator\">:</span> a<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 5 == 3 ? 7 : 5 = 5</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 1: %d\\n\"</span><span class=\"token punctuation\">,</span> result1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 2: %d\\n\"</span><span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 3: %d\\n\"</span><span class=\"token punctuation\">,</span> result3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 4: %d\\n\"</span><span class=\"token punctuation\">,</span> result4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 5: %d\\n\"</span><span class=\"token punctuation\">,</span> result5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 6: %d\\n\"</span><span class=\"token punctuation\">,</span> result6<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 7: %d\\n\"</span><span class=\"token punctuation\">,</span> result7<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 8: %d\\n\"</span><span class=\"token punctuation\">,</span> result8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 9: %d\\n\"</span><span class=\"token punctuation\">,</span> result9<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Result 10: %d\\n\"</span><span class=\"token punctuation\">,</span> result10<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>类型转换（Type Conversion）是将一个数据类型的值转换为另一个数据类型的过程。在C语言中，类型转换可分为隐式类型转换（Implicit Conversion）和显式类型转换（Explicit Conversion）两种形式。</p>\n<ol>\n<li><p>隐式类型转换：隐式类型转换是指在表达式中自动进行的类型转换，不需要显式地指定转换操作符。常见的隐式类型转换有：</p>\n<ul>\n<li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。</p>\n<p>  类型的级别从高至低依次是long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。</p>\n</li>\n<li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。</p>\n</li>\n</ul>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 隐式类型转换</span>\n    <span class=\"token keyword\">double</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将整型变量a隐式转换为double类型</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 将double类型变量b隐式转换为整型</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c: %f\\n\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：5.000000</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"d: %d\\n\"</span><span class=\"token punctuation\">,</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 输出：3</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%f\"</span><span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出：8.140000</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>显式类型转换：显式类型转换是通过显式地使用类型转换操作符来执行的。它允许我们将一个数据类型强制转换为另一个数据类型。显式类型转换的语法形式如下：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">(目标类型) 表达式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 显式类型转换</span>\n    <span class=\"token keyword\">int</span> e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>b<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 将double类型变量b显式转换为整型</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"e: %d\\n\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 输出：3</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"表达式语句，空语句，复合语句\"><a href=\"#表达式语句，空语句，复合语句\" class=\"headerlink\" title=\"表达式语句，空语句，复合语句\"></a>表达式语句，空语句，复合语句</h2><p>在C语言中，有三种常见的语句类型：表达式语句（Expression Statement），空语句（Empty Statement）和复合语句（Compound Statement）。</p>\n<ol>\n<li><p>表达式语句（Expression Statement）：表达式语句由一个表达式和一个分号组成，用于执行一个表达式并丢弃其结果。表达式可以是函数调用、赋值表达式、递增递减表达式等。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 赋值表达式作为表达式语句</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 函数调用作为表达式语句</span>\nx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>空语句（Empty Statement）：空语句只包含一个分号，用于表示一个空操作。空语句在某些情况下可以用作占位符，或者在循环中作为一个空的循环体。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 空语句</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 空循环体</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p> 空语句不做任何操作，它在语法上是合法的语句，但不会有任何实际的影响。</p>\n</li>\n<li><p>复合语句（Compound Statement）：复合语句是由一对花括号 <code>&#123;&#125;</code> 包围的语句块，可以包含多条语句。复合语句常用于定义函数体或在控制流语句中使用。例如：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>          <span class=\"token comment\">// 定义变量</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value: %d\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    x<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\">// 修改变量的值</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Updated Value: %d\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 这些语句类型在C语言中用于不同的场景和目的。表达式语句用于执行表达式并丢弃结果，空语句表示一个空操作，复合语句用于组织多个语句形成一个语句块。了解这些语句类型可以帮助我们编写清晰、有效的代码。</p>\n</li>\n</ol>\n"},{"title":"第三周","date":"2023-06-16T14:22:10.000Z","_content":"\n## C语言中的输入输出函数\n\nC语言有很多函数能够实现各种信息的输入和输出，信息的输入主要来源是标准输入（键盘），信息的输出主要目标是标准输出（屏幕），下面介绍几种常见的输入输出函数。\n\n### printf和scanf\n\n1. printf用于将数据格式化输出到标准输出（通常是屏幕）\n\n    printf函数原型如下：\n\n    ```c\n    int printf(const char *format, ...);\n    ```\n\n    printf() 函数接受一个格式化字符串`format`和可变数量的参数，根据格式化字符串中的占位符将参数格式化为字符串并输出到标准输出（通常是控制台）。返回值为输出的字符数。\n\n    常见的格式化占位符以及含义：\n\n    ```text\n    %d：输出有符号十进制整数。\n    %u：输出无符号十进制整数。\n    %f：输出浮点数。\n    %c：输出字符。\n    %s：输出字符串。\n    %x：输出无符号十六进制整数。\n    %o：输出无符号八进制整数。\n    %e：以指数形式输出浮点数。\n    %p：输出指针的地址。\n    %%：输出一个百分号。\n    ```\n\n    创建test.c文件并编辑以下代码，注释部分为运行结果：\n\n    ```c print用法示例\n    #include <stdio.h>\n\n    int main() {\n    int num = 10;\n    float pi = 3.14159;\n    char ch = 'A';\n    char str[] = \"Hello, World!\";\n    \n    printf(\"Integer: %d\\n\", num);   //Integer: 10\n    printf(\"Float: %.2f\\n\", pi);    //Float: 3.14\n    printf(\"Integer: %d\\nFloat: %.2f\\n\", num, pi);\n    printf(\"Character: %c\\n\", ch);  //Character: A\n    printf(\"String: %s\\n\", str);    //String: Hello, World!\n    \n    return 0;\n\n    }\n\n    ```\n\n2. scanf用于从标准输入（通常是键盘）读取格式化的数据\n\n    scanf原型如下：\n\n    ```c\n    int scanf(const char *format, ...);\n    ```\n\n    scanf() 函数接受一个格式化字符串`format`和对应的参数列表，根据格式化字符串中的占位符从输入流中读取数据，并将读取到的数据存储到对应的变量中。返回值为成功读取的变量的数量。\n\n    创建test.c文件并编辑以下代码：\n\n    ```c scanf用法示例\n    #include <stdio.h>\n\n    int main() {\n        int num;\n        float pi;\n        char ch;\n        char str[100];\n        \n        printf(\"Enter an integer: \");\n        scanf(\"%d\", &num);\n        \n        printf(\"Enter a float: \");\n        scanf(\"%f\", &pi);\n        \n        printf(\"Enter a character: \");\n        scanf(\" %c\", &ch);\n        \n        printf(\"Enter a string: \");\n        scanf(\"%s\", str);\n        \n        printf(\"Integer: %d\\n\", num);\n        printf(\"Float: %.2f\\n\", pi);\n        printf(\"Character: %c\\n\", ch);\n        printf(\"String: %s\\n\", str);\n        \n        return 0;\n    }\n\n    ```\n\n    使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n    ```text\n    Enter an integer: 10\n    Enter a float: 10.1\n    Enter a character: d\n    Enter a string: string\n    Integer: 10\n    Float: 10.10\n    Character: d\n    String: string\n    ```\n\n### getchar和putchar\n\n1. getchar用于从输入流中读取单个字符\n\n    getchar函数原型如下：\n\n    ```c\n    int getchar(void);\n    ```\n\n    getchar() 函数没有参数，它从标准输入（通常是键盘）读取一个字符，并返回读取到的字符的ASCII码值（作为整数）。\n\n    创建test.c文件并编辑以下代码：\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        char ch;\n        \n        printf(\"Enter a character: \");\n        ch = getchar();\n        \n        printf(\"You entered: %c\\n\", ch);\n        \n        return 0;\n    }\n\n    ```\n\n    使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n    ```text\n    Enter a character: d\n    You entered: d\n\n    Enter a character: dd\n    You entered: d\n    ```\n\n2. putchar用于将一个字符输出到标准输出（通常是屏幕）\n\n    putchar函数原型如下：\n\n    ```c\n    int putchar(int c);\n    ```\n\n    putchar()函数接受一个整数参数`c`，它表示要输出的字符的ASCII码值。函数将该字符输出到标准输出，并返回输出的字符。\n\n    创建test.c文件并编辑以下代码：\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        char ch = 'A';\n        \n        printf(\"Character: \");\n        putchar(ch);\n        putchar('\\n');\n        \n        return 0;\n    }\n \n    ```\n\n    使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n    ```text\n   Character: A\n \n    ```\n\n### 其他输入输出函数\n\n- 标准输入输出（stdio.h库）：\n\n  - printf()：用于将数据格式化输出到标准输出（通常是控制台）。\n  - scanf()：用于从标准输入（键盘）读取格式化的数据。\n  - getchar()：用于从标准输入（键盘）读取单个字符。\n  - puts()：用于将字符串输出到标准输出（控制台）并自动换行。\n  - gets()：用于从标准输入（键盘）读取字符串（已被弃用，请使用 fgets()）。\n\n- 文件输入输出（stdio.h库）：\n\n  - fopen()：打开文件并返回文件指针。\n  - fclose()：关闭文件。\n  - fprintf()：将数据格式化输出到文件。\n  - fscanf()：从文件读取格式化的数据。\n  - fgets()：从文件读取一行字符串。\n\n- 字符输入输出（ctype.h库）：\n\n  - putc()：将一个字符写入指定的文件。\n  - getc()：从指定的文件读取一个字符。\n\n- 格式化输出（stdarg.h库）：\n\n  - sprintf()：将数据格式化输出到字符串。\n  - printf()：将数据格式化输出到字符串或标准输出。\n\n## 控制语句：分支和跳转\n\n### if语句\n\nif语句的语法格式：\n\n```c\nif(boolean_expression)\n{\n   /* 如果布尔表达式为真将执行的语句 */\n}\n```\n\n如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。\nC 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num;\n\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n\n    if (num > 0) {\n        printf(\"The number is positive.\\n\");\n    } else if (num < 0) {\n        printf(\"The number is negative.\\n\");\n    } else {\n        printf(\"The number is zero.\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n可以使用各种类型的运算符来构建表达式：\n\n1. 关系运算符：\n\n    ```c\n        int a = 5, b = 10;\n        if (a == b) {\n        // 执行代码块\n        }\n    ```\n\n2. 逻辑运算符：\n\n    ```c\n        int x = 5, y = 10;\n        if (x > 0 && y > 0) {\n            // 执行代码块\n    }\n    ```\n\n3. 位运算符：\n\n    ```c\n    unsigned int flags = 0b1011;\n    if (flags & 0b1000) {\n        // 执行代码块\n    }\n\n    ```\n\n### switch语句\n\n`switch`语句是C语言中用于多路分支的控制语句，它根据表达式的值，选择性地执行与每个选项相关联的代码块。以下是`switch`语句的基本用法：\n\n```c\nswitch (expression) {\n    case constant1:\n        // 与 constant1 相关的代码块\n        break;\n    case constant2:\n        // 与 constant2 相关的代码块\n        break;\n    // 更多的 case 分支...\n    default:\n        // 默认情况的代码块\n        break;\n}\n\n```\n\n`switch`语句包含以下几个部分：\n\n1. `expression`：一个表达式，其结果将与每个case分支的常量值进行比较。\n\n2. `case`分支：每个case后面跟着一个常量表达式，用于与expression进行比较。如果expression的值与某个case的常量值匹配，将执行与该case相关联的代码块。\n\n3. `break`语句：在每个case分支的代码块结束时使用break语句，以终止switch语句的执行。如果忽略了break语句，将会发生\"穿透\"现象，即会继续执行下一个case分支中的代码块，直到遇到break或switch语句结束。\n\n4. `default`分支：在所有的case分支都不匹配时，将执行default分支中的代码块。default是可选的，可以省略。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int choice;\n\n    printf(\"Enter a number between 1 and 3: \");\n    scanf(\"%d\", &choice);\n\n    switch (choice) {\n        case 1:\n            printf(\"You selected option 1.\\n\");\n            break;\n        case 2:\n            printf(\"You selected option 2.\\n\");\n            break;\n        case 3:\n            printf(\"You selected option 3.\\n\");\n            break;\n        default:\n            printf(\"Invalid option.\\n\");\n            break;\n    }\n\n    return 0;\n}\n\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nEnter a number between 1 and 3: 2\nYou selected option 2.\n\nEnter a number between 1 and 3: 5\nInvalid option.\n\nEnter a number between 1 and 3: 2.1\nYou selected option 2.\n\n```\n\n## 控制语句：循环\n\n### for循环\n\nfor循环是C语言中常用的一种迭代控制结构，它可以用于重复执行一段代码块，且提供了更灵活的循环控制。以下是for循环的语法：\n\n```c\nfor (initialization; condition; increment/decrement) {\n    // 循环体代码块\n}\n```\n\nfor循环包含以下四个部分：\n\n1. initialization：在循环开始前执行的初始化表达式，用于初始化循环计数器或其他变量。\n\n2. condition：在每次循环迭代前进行判断的条件表达式。只有当条件为真时，循环体中的代码块才会执行。如果条件为假，循环将结束，程序将继续执行循环后的代码。\n\n3. increment/decrement：在每次循环迭代后执行的增量或减量操作。它用于更新循环计数器或其他变量的值，以控制循环的进程。\n\n4. 循环体代码块：在 for 循环的花括号内部，是需要重复执行的代码块。这些代码将按照循环条件和增量/减量操作的规则反复执行。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        printf(\"Count: %d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nCount: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5\n```\n\n需要注意的是，for循环的各个部分都是可选的。如果省略了某个部分，相应的功能将被忽略，但循环仍然可以正常工作。例如，可以省略初始化表达式或增量操作，只保留条件表达式，以及在循环体内手动控制循环变量的更新。这样的灵活性使得for循环非常适用于各种迭代场景。\n\n### while循环和do-while循环\n\n`while`循环是C语言中的一种迭代控制结构，它用于重复执行一段代码块，只要给定的条件为真。以下是`while`循环的语法\n\n```c\nwhile (condition) {\n    // 循环体代码块\n}\n```\n\nwhile 循环包含以下两个部分：\n\n1. condition：一个条件表达式，用于判断循环是否继续执行。如果条件为真，循环将继续执行循环体中的代码块；如果条件为假，循环将结束，程序将继续执行循环后的代码。\n\n2. 循环体代码块：在 while 循环的花括号内部，是需要重复执行的代码块。这些代码将反复执行，直到条件为假。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int count = 0;\n\n    while (count < 5) {\n        printf(\"Count: %d\\n\", count);\n        count++;\n    }\n\n    return 0;\n}\n```\n\n在上述示例中，`while`循环的条件是`count<5`，只要`count`的值小于5，循环体中的代码块将被重复执行。每次循环，`count`的值会递增，并打印出当前的值。当`count`的值达到或超过5时，条件为假，循环结束。\n\n需要注意的是，如果条件一开始就为假，循环体中的代码块将不会执行，循环将被跳过。因此，在使用`while`循环时，请确保循环条件能够在某个时刻变为假，以避免陷入无限循环。通常，在循环体中需要修改条件表达式或使用控制语句（如`break`）来终止循环。\n\n### continue语句和break语句\n\ncontinue语句用于跳过当前循环迭代中剩余的代码，直接进行下一次迭代。它的作用是终止当前迭代的剩余代码，然后重新开始下一次循环迭代。continue语句通常与条件语句结合使用，用于在满足特定条件时跳过当前迭代。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        if (i == 3) {\n            continue; // 当 i 等于 3 时跳过当前迭代\n        }\n\n        printf(\"Count: %d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nCount: 1\nCount: 2\nCount: 4\nCount: 5\n```\n\n在上述示例中，当`i`等于`3`时，`continue`语句将跳过`printf`语句，直接进入下一次循环迭代。因此，输出结果中不会包含数字`3`。\n\n`break`语句用于完全终止当前的循环，不再执行循环中的任何代码，并跳出循环体继续执行循环后的代码。它通常与条件语句结合使用，用于在满足特定条件时提前结束循环。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        if (i == 3) {\n            break; // 当 i 等于 3 时终止循环\n        }\n\n        printf(\"Count: %d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nCount: 1\nCount: 2\n```\n\n在上述示例中，当`i`等于`3`时，`break`语句将完全终止循环，不再执行任何循环代码。因此，输出结果中只包含数字`1`和`2`，循环在此处结束。\n","source":"_posts/c_program/3.第三周.md","raw":"---\ntitle: 第三周\ndate: 2023-06-16 22:22:10\ntags: \n---\n\n## C语言中的输入输出函数\n\nC语言有很多函数能够实现各种信息的输入和输出，信息的输入主要来源是标准输入（键盘），信息的输出主要目标是标准输出（屏幕），下面介绍几种常见的输入输出函数。\n\n### printf和scanf\n\n1. printf用于将数据格式化输出到标准输出（通常是屏幕）\n\n    printf函数原型如下：\n\n    ```c\n    int printf(const char *format, ...);\n    ```\n\n    printf() 函数接受一个格式化字符串`format`和可变数量的参数，根据格式化字符串中的占位符将参数格式化为字符串并输出到标准输出（通常是控制台）。返回值为输出的字符数。\n\n    常见的格式化占位符以及含义：\n\n    ```text\n    %d：输出有符号十进制整数。\n    %u：输出无符号十进制整数。\n    %f：输出浮点数。\n    %c：输出字符。\n    %s：输出字符串。\n    %x：输出无符号十六进制整数。\n    %o：输出无符号八进制整数。\n    %e：以指数形式输出浮点数。\n    %p：输出指针的地址。\n    %%：输出一个百分号。\n    ```\n\n    创建test.c文件并编辑以下代码，注释部分为运行结果：\n\n    ```c print用法示例\n    #include <stdio.h>\n\n    int main() {\n    int num = 10;\n    float pi = 3.14159;\n    char ch = 'A';\n    char str[] = \"Hello, World!\";\n    \n    printf(\"Integer: %d\\n\", num);   //Integer: 10\n    printf(\"Float: %.2f\\n\", pi);    //Float: 3.14\n    printf(\"Integer: %d\\nFloat: %.2f\\n\", num, pi);\n    printf(\"Character: %c\\n\", ch);  //Character: A\n    printf(\"String: %s\\n\", str);    //String: Hello, World!\n    \n    return 0;\n\n    }\n\n    ```\n\n2. scanf用于从标准输入（通常是键盘）读取格式化的数据\n\n    scanf原型如下：\n\n    ```c\n    int scanf(const char *format, ...);\n    ```\n\n    scanf() 函数接受一个格式化字符串`format`和对应的参数列表，根据格式化字符串中的占位符从输入流中读取数据，并将读取到的数据存储到对应的变量中。返回值为成功读取的变量的数量。\n\n    创建test.c文件并编辑以下代码：\n\n    ```c scanf用法示例\n    #include <stdio.h>\n\n    int main() {\n        int num;\n        float pi;\n        char ch;\n        char str[100];\n        \n        printf(\"Enter an integer: \");\n        scanf(\"%d\", &num);\n        \n        printf(\"Enter a float: \");\n        scanf(\"%f\", &pi);\n        \n        printf(\"Enter a character: \");\n        scanf(\" %c\", &ch);\n        \n        printf(\"Enter a string: \");\n        scanf(\"%s\", str);\n        \n        printf(\"Integer: %d\\n\", num);\n        printf(\"Float: %.2f\\n\", pi);\n        printf(\"Character: %c\\n\", ch);\n        printf(\"String: %s\\n\", str);\n        \n        return 0;\n    }\n\n    ```\n\n    使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n    ```text\n    Enter an integer: 10\n    Enter a float: 10.1\n    Enter a character: d\n    Enter a string: string\n    Integer: 10\n    Float: 10.10\n    Character: d\n    String: string\n    ```\n\n### getchar和putchar\n\n1. getchar用于从输入流中读取单个字符\n\n    getchar函数原型如下：\n\n    ```c\n    int getchar(void);\n    ```\n\n    getchar() 函数没有参数，它从标准输入（通常是键盘）读取一个字符，并返回读取到的字符的ASCII码值（作为整数）。\n\n    创建test.c文件并编辑以下代码：\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        char ch;\n        \n        printf(\"Enter a character: \");\n        ch = getchar();\n        \n        printf(\"You entered: %c\\n\", ch);\n        \n        return 0;\n    }\n\n    ```\n\n    使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n    ```text\n    Enter a character: d\n    You entered: d\n\n    Enter a character: dd\n    You entered: d\n    ```\n\n2. putchar用于将一个字符输出到标准输出（通常是屏幕）\n\n    putchar函数原型如下：\n\n    ```c\n    int putchar(int c);\n    ```\n\n    putchar()函数接受一个整数参数`c`，它表示要输出的字符的ASCII码值。函数将该字符输出到标准输出，并返回输出的字符。\n\n    创建test.c文件并编辑以下代码：\n\n    ```c\n    #include <stdio.h>\n\n    int main() {\n        char ch = 'A';\n        \n        printf(\"Character: \");\n        putchar(ch);\n        putchar('\\n');\n        \n        return 0;\n    }\n \n    ```\n\n    使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n    ```text\n   Character: A\n \n    ```\n\n### 其他输入输出函数\n\n- 标准输入输出（stdio.h库）：\n\n  - printf()：用于将数据格式化输出到标准输出（通常是控制台）。\n  - scanf()：用于从标准输入（键盘）读取格式化的数据。\n  - getchar()：用于从标准输入（键盘）读取单个字符。\n  - puts()：用于将字符串输出到标准输出（控制台）并自动换行。\n  - gets()：用于从标准输入（键盘）读取字符串（已被弃用，请使用 fgets()）。\n\n- 文件输入输出（stdio.h库）：\n\n  - fopen()：打开文件并返回文件指针。\n  - fclose()：关闭文件。\n  - fprintf()：将数据格式化输出到文件。\n  - fscanf()：从文件读取格式化的数据。\n  - fgets()：从文件读取一行字符串。\n\n- 字符输入输出（ctype.h库）：\n\n  - putc()：将一个字符写入指定的文件。\n  - getc()：从指定的文件读取一个字符。\n\n- 格式化输出（stdarg.h库）：\n\n  - sprintf()：将数据格式化输出到字符串。\n  - printf()：将数据格式化输出到字符串或标准输出。\n\n## 控制语句：分支和跳转\n\n### if语句\n\nif语句的语法格式：\n\n```c\nif(boolean_expression)\n{\n   /* 如果布尔表达式为真将执行的语句 */\n}\n```\n\n如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。\nC 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int num;\n\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\n\n    if (num > 0) {\n        printf(\"The number is positive.\\n\");\n    } else if (num < 0) {\n        printf(\"The number is negative.\\n\");\n    } else {\n        printf(\"The number is zero.\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n可以使用各种类型的运算符来构建表达式：\n\n1. 关系运算符：\n\n    ```c\n        int a = 5, b = 10;\n        if (a == b) {\n        // 执行代码块\n        }\n    ```\n\n2. 逻辑运算符：\n\n    ```c\n        int x = 5, y = 10;\n        if (x > 0 && y > 0) {\n            // 执行代码块\n    }\n    ```\n\n3. 位运算符：\n\n    ```c\n    unsigned int flags = 0b1011;\n    if (flags & 0b1000) {\n        // 执行代码块\n    }\n\n    ```\n\n### switch语句\n\n`switch`语句是C语言中用于多路分支的控制语句，它根据表达式的值，选择性地执行与每个选项相关联的代码块。以下是`switch`语句的基本用法：\n\n```c\nswitch (expression) {\n    case constant1:\n        // 与 constant1 相关的代码块\n        break;\n    case constant2:\n        // 与 constant2 相关的代码块\n        break;\n    // 更多的 case 分支...\n    default:\n        // 默认情况的代码块\n        break;\n}\n\n```\n\n`switch`语句包含以下几个部分：\n\n1. `expression`：一个表达式，其结果将与每个case分支的常量值进行比较。\n\n2. `case`分支：每个case后面跟着一个常量表达式，用于与expression进行比较。如果expression的值与某个case的常量值匹配，将执行与该case相关联的代码块。\n\n3. `break`语句：在每个case分支的代码块结束时使用break语句，以终止switch语句的执行。如果忽略了break语句，将会发生\"穿透\"现象，即会继续执行下一个case分支中的代码块，直到遇到break或switch语句结束。\n\n4. `default`分支：在所有的case分支都不匹配时，将执行default分支中的代码块。default是可选的，可以省略。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int choice;\n\n    printf(\"Enter a number between 1 and 3: \");\n    scanf(\"%d\", &choice);\n\n    switch (choice) {\n        case 1:\n            printf(\"You selected option 1.\\n\");\n            break;\n        case 2:\n            printf(\"You selected option 2.\\n\");\n            break;\n        case 3:\n            printf(\"You selected option 3.\\n\");\n            break;\n        default:\n            printf(\"Invalid option.\\n\");\n            break;\n    }\n\n    return 0;\n}\n\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nEnter a number between 1 and 3: 2\nYou selected option 2.\n\nEnter a number between 1 and 3: 5\nInvalid option.\n\nEnter a number between 1 and 3: 2.1\nYou selected option 2.\n\n```\n\n## 控制语句：循环\n\n### for循环\n\nfor循环是C语言中常用的一种迭代控制结构，它可以用于重复执行一段代码块，且提供了更灵活的循环控制。以下是for循环的语法：\n\n```c\nfor (initialization; condition; increment/decrement) {\n    // 循环体代码块\n}\n```\n\nfor循环包含以下四个部分：\n\n1. initialization：在循环开始前执行的初始化表达式，用于初始化循环计数器或其他变量。\n\n2. condition：在每次循环迭代前进行判断的条件表达式。只有当条件为真时，循环体中的代码块才会执行。如果条件为假，循环将结束，程序将继续执行循环后的代码。\n\n3. increment/decrement：在每次循环迭代后执行的增量或减量操作。它用于更新循环计数器或其他变量的值，以控制循环的进程。\n\n4. 循环体代码块：在 for 循环的花括号内部，是需要重复执行的代码块。这些代码将按照循环条件和增量/减量操作的规则反复执行。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        printf(\"Count: %d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nCount: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5\n```\n\n需要注意的是，for循环的各个部分都是可选的。如果省略了某个部分，相应的功能将被忽略，但循环仍然可以正常工作。例如，可以省略初始化表达式或增量操作，只保留条件表达式，以及在循环体内手动控制循环变量的更新。这样的灵活性使得for循环非常适用于各种迭代场景。\n\n### while循环和do-while循环\n\n`while`循环是C语言中的一种迭代控制结构，它用于重复执行一段代码块，只要给定的条件为真。以下是`while`循环的语法\n\n```c\nwhile (condition) {\n    // 循环体代码块\n}\n```\n\nwhile 循环包含以下两个部分：\n\n1. condition：一个条件表达式，用于判断循环是否继续执行。如果条件为真，循环将继续执行循环体中的代码块；如果条件为假，循环将结束，程序将继续执行循环后的代码。\n\n2. 循环体代码块：在 while 循环的花括号内部，是需要重复执行的代码块。这些代码将反复执行，直到条件为假。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int count = 0;\n\n    while (count < 5) {\n        printf(\"Count: %d\\n\", count);\n        count++;\n    }\n\n    return 0;\n}\n```\n\n在上述示例中，`while`循环的条件是`count<5`，只要`count`的值小于5，循环体中的代码块将被重复执行。每次循环，`count`的值会递增，并打印出当前的值。当`count`的值达到或超过5时，条件为假，循环结束。\n\n需要注意的是，如果条件一开始就为假，循环体中的代码块将不会执行，循环将被跳过。因此，在使用`while`循环时，请确保循环条件能够在某个时刻变为假，以避免陷入无限循环。通常，在循环体中需要修改条件表达式或使用控制语句（如`break`）来终止循环。\n\n### continue语句和break语句\n\ncontinue语句用于跳过当前循环迭代中剩余的代码，直接进行下一次迭代。它的作用是终止当前迭代的剩余代码，然后重新开始下一次循环迭代。continue语句通常与条件语句结合使用，用于在满足特定条件时跳过当前迭代。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        if (i == 3) {\n            continue; // 当 i 等于 3 时跳过当前迭代\n        }\n\n        printf(\"Count: %d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nCount: 1\nCount: 2\nCount: 4\nCount: 5\n```\n\n在上述示例中，当`i`等于`3`时，`continue`语句将跳过`printf`语句，直接进入下一次循环迭代。因此，输出结果中不会包含数字`3`。\n\n`break`语句用于完全终止当前的循环，不再执行循环中的任何代码，并跳出循环体继续执行循环后的代码。它通常与条件语句结合使用，用于在满足特定条件时提前结束循环。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n\n    for (i = 1; i <= 5; i++) {\n        if (i == 3) {\n            break; // 当 i 等于 3 时终止循环\n        }\n\n        printf(\"Count: %d\\n\", i);\n    }\n\n    return 0;\n}\n```\n\n使用`gcc -o test test.c`命令编译后使用`./test`运行代码，按提示信息输入相应类型的数据：\n\n```text\nCount: 1\nCount: 2\n```\n\n在上述示例中，当`i`等于`3`时，`break`语句将完全终止循环，不再执行任何循环代码。因此，输出结果中只包含数字`1`和`2`，循环在此处结束。\n","slug":"c_program/3.第三周","published":1,"updated":"2023-06-17T01:06:48.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04d00031dnzbz327nlh","content":"<h2 id=\"C语言中的输入输出函数\"><a href=\"#C语言中的输入输出函数\" class=\"headerlink\" title=\"C语言中的输入输出函数\"></a>C语言中的输入输出函数</h2><p>C语言有很多函数能够实现各种信息的输入和输出，信息的输入主要来源是标准输入（键盘），信息的输出主要目标是标准输出（屏幕），下面介绍几种常见的输入输出函数。</p>\n<h3 id=\"printf和scanf\"><a href=\"#printf和scanf\" class=\"headerlink\" title=\"printf和scanf\"></a>printf和scanf</h3><ol>\n<li><p>printf用于将数据格式化输出到标准输出（通常是屏幕）</p>\n<p> printf函数原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> printf() 函数接受一个格式化字符串<code>format</code>和可变数量的参数，根据格式化字符串中的占位符将参数格式化为字符串并输出到标准输出（通常是控制台）。返回值为输出的字符数。</p>\n<p> 常见的格式化占位符以及含义：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">%d：输出有符号十进制整数。\n%u：输出无符号十进制整数。\n%f：输出浮点数。\n%c：输出字符。\n%s：输出字符串。\n%x：输出无符号十六进制整数。\n%o：输出无符号八进制整数。\n%e：以指数形式输出浮点数。\n%p：输出指针的地址。\n%%：输出一个百分号。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 创建test.c文件并编辑以下代码，注释部分为运行结果：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><div class=\"caption\"><span>print用法示例</span></div><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14159</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, World!\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//Integer: 10</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Float: %.2f\\n\"</span><span class=\"token punctuation\">,</span> pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//Float: 3.14</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer: %d\\nFloat: %.2f\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">,</span> pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Character: %c\\n\"</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//Character: A</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String: %s\\n\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//String: Hello, World!</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>scanf用于从标准输入（通常是键盘）读取格式化的数据</p>\n<p> scanf原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> scanf() 函数接受一个格式化字符串<code>format</code>和对应的参数列表，根据格式化字符串中的占位符从输入流中读取数据，并将读取到的数据存储到对应的变量中。返回值为成功读取的变量的数量。</p>\n<p> 创建test.c文件并编辑以下代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><div class=\"caption\"><span>scanf用法示例</span></div><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> pi<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter an integer: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a float: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%f\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a character: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %c\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a string: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Float: %.2f\\n\"</span><span class=\"token punctuation\">,</span> pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Character: %c\\n\"</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String: %s\\n\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Enter an integer: 10\nEnter a float: 10.1\nEnter a character: d\nEnter a string: string\nInteger: 10\nFloat: 10.10\nCharacter: d\nString: string<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"getchar和putchar\"><a href=\"#getchar和putchar\" class=\"headerlink\" title=\"getchar和putchar\"></a>getchar和putchar</h3><ol>\n<li><p>getchar用于从输入流中读取单个字符</p>\n<p> getchar函数原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> getchar() 函数没有参数，它从标准输入（通常是键盘）读取一个字符，并返回读取到的字符的ASCII码值（作为整数）。</p>\n<p> 创建test.c文件并编辑以下代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a character: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ch <span class=\"token operator\">=</span> <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You entered: %c\\n\"</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Enter a character: d\nYou entered: d\n\nEnter a character: dd\nYou entered: d<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>putchar用于将一个字符输出到标准输出（通常是屏幕）</p>\n<p> putchar函数原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> putchar()函数接受一个整数参数<code>c</code>，它表示要输出的字符的ASCII码值。函数将该字符输出到标准输出，并返回输出的字符。</p>\n<p> 创建test.c文件并编辑以下代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Character: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span><span class=\"token char\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Character: A\n <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"其他输入输出函数\"><a href=\"#其他输入输出函数\" class=\"headerlink\" title=\"其他输入输出函数\"></a>其他输入输出函数</h3><ul>\n<li><p>标准输入输出（stdio.h库）：</p>\n<ul>\n<li>printf()：用于将数据格式化输出到标准输出（通常是控制台）。</li>\n<li>scanf()：用于从标准输入（键盘）读取格式化的数据。</li>\n<li>getchar()：用于从标准输入（键盘）读取单个字符。</li>\n<li>puts()：用于将字符串输出到标准输出（控制台）并自动换行。</li>\n<li>gets()：用于从标准输入（键盘）读取字符串（已被弃用，请使用 fgets()）。</li>\n</ul>\n</li>\n<li><p>文件输入输出（stdio.h库）：</p>\n<ul>\n<li>fopen()：打开文件并返回文件指针。</li>\n<li>fclose()：关闭文件。</li>\n<li>fprintf()：将数据格式化输出到文件。</li>\n<li>fscanf()：从文件读取格式化的数据。</li>\n<li>fgets()：从文件读取一行字符串。</li>\n</ul>\n</li>\n<li><p>字符输入输出（ctype.h库）：</p>\n<ul>\n<li>putc()：将一个字符写入指定的文件。</li>\n<li>getc()：从指定的文件读取一个字符。</li>\n</ul>\n</li>\n<li><p>格式化输出（stdarg.h库）：</p>\n<ul>\n<li>sprintf()：将数据格式化输出到字符串。</li>\n<li>printf()：将数据格式化输出到字符串或标准输出。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"控制语句：分支和跳转\"><a href=\"#控制语句：分支和跳转\" class=\"headerlink\" title=\"控制语句：分支和跳转\"></a>控制语句：分支和跳转</h2><h3 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h3><p>if语句的语法格式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>boolean_expression<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token comment\">/* 如果布尔表达式为真将执行的语句 */</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。<br>C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a number: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The number is positive.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The number is negative.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The number is zero.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以使用各种类型的运算符来构建表达式：</p>\n<ol>\n<li><p>关系运算符：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">// 执行代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逻辑运算符：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> y <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 执行代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>位运算符：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> flags <span class=\"token operator\">=</span> <span class=\"token number\">0</span>b1011<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flags <span class=\"token operator\">&amp;</span> <span class=\"token number\">0</span>b1000<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 执行代码块</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><p><code>switch</code>语句是C语言中用于多路分支的控制语句，它根据表达式的值，选择性地执行与每个选项相关联的代码块。以下是<code>switch</code>语句的基本用法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">case</span> constant1<span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 与 constant1 相关的代码块</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> constant2<span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 与 constant2 相关的代码块</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 更多的 case 分支...</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 默认情况的代码块</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>switch</code>语句包含以下几个部分：</p>\n<ol>\n<li><p><code>expression</code>：一个表达式，其结果将与每个case分支的常量值进行比较。</p>\n</li>\n<li><p><code>case</code>分支：每个case后面跟着一个常量表达式，用于与expression进行比较。如果expression的值与某个case的常量值匹配，将执行与该case相关联的代码块。</p>\n</li>\n<li><p><code>break</code>语句：在每个case分支的代码块结束时使用break语句，以终止switch语句的执行。如果忽略了break语句，将会发生”穿透”现象，即会继续执行下一个case分支中的代码块，直到遇到break或switch语句结束。</p>\n</li>\n<li><p><code>default</code>分支：在所有的case分支都不匹配时，将执行default分支中的代码块。default是可选的，可以省略。</p>\n</li>\n</ol>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> choice<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a number between 1 and 3: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>choice<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>choice<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You selected option 1.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You selected option 2.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">3</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You selected option 3.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid option.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Enter a number between 1 and 3: 2\nYou selected option 2.\n\nEnter a number between 1 and 3: 5\nInvalid option.\n\nEnter a number between 1 and 3: 2.1\nYou selected option 2.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"控制语句：循环\"><a href=\"#控制语句：循环\" class=\"headerlink\" title=\"控制语句：循环\"></a>控制语句：循环</h2><h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p>for循环是C语言中常用的一种迭代控制结构，它可以用于重复执行一段代码块，且提供了更灵活的循环控制。以下是for循环的语法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>initialization<span class=\"token punctuation\">;</span> condition<span class=\"token punctuation\">;</span> increment<span class=\"token operator\">/</span>decrement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 循环体代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>for循环包含以下四个部分：</p>\n<ol>\n<li><p>initialization：在循环开始前执行的初始化表达式，用于初始化循环计数器或其他变量。</p>\n</li>\n<li><p>condition：在每次循环迭代前进行判断的条件表达式。只有当条件为真时，循环体中的代码块才会执行。如果条件为假，循环将结束，程序将继续执行循环后的代码。</p>\n</li>\n<li><p>increment&#x2F;decrement：在每次循环迭代后执行的增量或减量操作。它用于更新循环计数器或其他变量的值，以控制循环的进程。</p>\n</li>\n<li><p>循环体代码块：在 for 循环的花括号内部，是需要重复执行的代码块。这些代码将按照循环条件和增量&#x2F;减量操作的规则反复执行。</p>\n</li>\n</ol>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Count: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，for循环的各个部分都是可选的。如果省略了某个部分，相应的功能将被忽略，但循环仍然可以正常工作。例如，可以省略初始化表达式或增量操作，只保留条件表达式，以及在循环体内手动控制循环变量的更新。这样的灵活性使得for循环非常适用于各种迭代场景。</p>\n<h3 id=\"while循环和do-while循环\"><a href=\"#while循环和do-while循环\" class=\"headerlink\" title=\"while循环和do-while循环\"></a>while循环和do-while循环</h3><p><code>while</code>循环是C语言中的一种迭代控制结构，它用于重复执行一段代码块，只要给定的条件为真。以下是<code>while</code>循环的语法</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 循环体代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>while 循环包含以下两个部分：</p>\n<ol>\n<li><p>condition：一个条件表达式，用于判断循环是否继续执行。如果条件为真，循环将继续执行循环体中的代码块；如果条件为假，循环将结束，程序将继续执行循环后的代码。</p>\n</li>\n<li><p>循环体代码块：在 while 循环的花括号内部，是需要重复执行的代码块。这些代码将反复执行，直到条件为假。</p>\n</li>\n</ol>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述示例中，<code>while</code>循环的条件是<code>count&lt;5</code>，只要<code>count</code>的值小于5，循环体中的代码块将被重复执行。每次循环，<code>count</code>的值会递增，并打印出当前的值。当<code>count</code>的值达到或超过5时，条件为假，循环结束。</p>\n<p>需要注意的是，如果条件一开始就为假，循环体中的代码块将不会执行，循环将被跳过。因此，在使用<code>while</code>循环时，请确保循环条件能够在某个时刻变为假，以避免陷入无限循环。通常，在循环体中需要修改条件表达式或使用控制语句（如<code>break</code>）来终止循环。</p>\n<h3 id=\"continue语句和break语句\"><a href=\"#continue语句和break语句\" class=\"headerlink\" title=\"continue语句和break语句\"></a>continue语句和break语句</h3><p>continue语句用于跳过当前循环迭代中剩余的代码，直接进行下一次迭代。它的作用是终止当前迭代的剩余代码，然后重新开始下一次循环迭代。continue语句通常与条件语句结合使用，用于在满足特定条件时跳过当前迭代。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当 i 等于 3 时跳过当前迭代</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Count: 1\nCount: 2\nCount: 4\nCount: 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述示例中，当<code>i</code>等于<code>3</code>时，<code>continue</code>语句将跳过<code>printf</code>语句，直接进入下一次循环迭代。因此，输出结果中不会包含数字<code>3</code>。</p>\n<p><code>break</code>语句用于完全终止当前的循环，不再执行循环中的任何代码，并跳出循环体继续执行循环后的代码。它通常与条件语句结合使用，用于在满足特定条件时提前结束循环。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当 i 等于 3 时终止循环</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Count: 1\nCount: 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>在上述示例中，当<code>i</code>等于<code>3</code>时，<code>break</code>语句将完全终止循环，不再执行任何循环代码。因此，输出结果中只包含数字<code>1</code>和<code>2</code>，循环在此处结束。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C语言中的输入输出函数\"><a href=\"#C语言中的输入输出函数\" class=\"headerlink\" title=\"C语言中的输入输出函数\"></a>C语言中的输入输出函数</h2><p>C语言有很多函数能够实现各种信息的输入和输出，信息的输入主要来源是标准输入（键盘），信息的输出主要目标是标准输出（屏幕），下面介绍几种常见的输入输出函数。</p>\n<h3 id=\"printf和scanf\"><a href=\"#printf和scanf\" class=\"headerlink\" title=\"printf和scanf\"></a>printf和scanf</h3><ol>\n<li><p>printf用于将数据格式化输出到标准输出（通常是屏幕）</p>\n<p> printf函数原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> printf() 函数接受一个格式化字符串<code>format</code>和可变数量的参数，根据格式化字符串中的占位符将参数格式化为字符串并输出到标准输出（通常是控制台）。返回值为输出的字符数。</p>\n<p> 常见的格式化占位符以及含义：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">%d：输出有符号十进制整数。\n%u：输出无符号十进制整数。\n%f：输出浮点数。\n%c：输出字符。\n%s：输出字符串。\n%x：输出无符号十六进制整数。\n%o：输出无符号八进制整数。\n%e：以指数形式输出浮点数。\n%p：输出指针的地址。\n%%：输出一个百分号。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 创建test.c文件并编辑以下代码，注释部分为运行结果：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><div class=\"caption\"><span>print用法示例</span></div><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14159</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, World!\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//Integer: 10</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Float: %.2f\\n\"</span><span class=\"token punctuation\">,</span> pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//Float: 3.14</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer: %d\\nFloat: %.2f\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">,</span> pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Character: %c\\n\"</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//Character: A</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String: %s\\n\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//String: Hello, World!</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>scanf用于从标准输入（通常是键盘）读取格式化的数据</p>\n<p> scanf原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> scanf() 函数接受一个格式化字符串<code>format</code>和对应的参数列表，根据格式化字符串中的占位符从输入流中读取数据，并将读取到的数据存储到对应的变量中。返回值为成功读取的变量的数量。</p>\n<p> 创建test.c文件并编辑以下代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><div class=\"caption\"><span>scanf用法示例</span></div><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> pi<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter an integer: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a float: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%f\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a character: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %c\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a string: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Integer: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Float: %.2f\\n\"</span><span class=\"token punctuation\">,</span> pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Character: %c\\n\"</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String: %s\\n\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Enter an integer: 10\nEnter a float: 10.1\nEnter a character: d\nEnter a string: string\nInteger: 10\nFloat: 10.10\nCharacter: d\nString: string<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"getchar和putchar\"><a href=\"#getchar和putchar\" class=\"headerlink\" title=\"getchar和putchar\"></a>getchar和putchar</h3><ol>\n<li><p>getchar用于从输入流中读取单个字符</p>\n<p> getchar函数原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> getchar() 函数没有参数，它从标准输入（通常是键盘）读取一个字符，并返回读取到的字符的ASCII码值（作为整数）。</p>\n<p> 创建test.c文件并编辑以下代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a character: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ch <span class=\"token operator\">=</span> <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You entered: %c\\n\"</span><span class=\"token punctuation\">,</span> ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Enter a character: d\nYou entered: d\n\nEnter a character: dd\nYou entered: d<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>putchar用于将一个字符输出到标准输出（通常是屏幕）</p>\n<p> putchar函数原型如下：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> putchar()函数接受一个整数参数<code>c</code>，它表示要输出的字符的ASCII码值。函数将该字符输出到标准输出，并返回输出的字符。</p>\n<p> 创建test.c文件并编辑以下代码：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> ch <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Character: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span><span class=\"token char\">'\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Character: A\n <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"其他输入输出函数\"><a href=\"#其他输入输出函数\" class=\"headerlink\" title=\"其他输入输出函数\"></a>其他输入输出函数</h3><ul>\n<li><p>标准输入输出（stdio.h库）：</p>\n<ul>\n<li>printf()：用于将数据格式化输出到标准输出（通常是控制台）。</li>\n<li>scanf()：用于从标准输入（键盘）读取格式化的数据。</li>\n<li>getchar()：用于从标准输入（键盘）读取单个字符。</li>\n<li>puts()：用于将字符串输出到标准输出（控制台）并自动换行。</li>\n<li>gets()：用于从标准输入（键盘）读取字符串（已被弃用，请使用 fgets()）。</li>\n</ul>\n</li>\n<li><p>文件输入输出（stdio.h库）：</p>\n<ul>\n<li>fopen()：打开文件并返回文件指针。</li>\n<li>fclose()：关闭文件。</li>\n<li>fprintf()：将数据格式化输出到文件。</li>\n<li>fscanf()：从文件读取格式化的数据。</li>\n<li>fgets()：从文件读取一行字符串。</li>\n</ul>\n</li>\n<li><p>字符输入输出（ctype.h库）：</p>\n<ul>\n<li>putc()：将一个字符写入指定的文件。</li>\n<li>getc()：从指定的文件读取一个字符。</li>\n</ul>\n</li>\n<li><p>格式化输出（stdarg.h库）：</p>\n<ul>\n<li>sprintf()：将数据格式化输出到字符串。</li>\n<li>printf()：将数据格式化输出到字符串或标准输出。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"控制语句：分支和跳转\"><a href=\"#控制语句：分支和跳转\" class=\"headerlink\" title=\"控制语句：分支和跳转\"></a>控制语句：分支和跳转</h2><h3 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h3><p>if语句的语法格式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>boolean_expression<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n   <span class=\"token comment\">/* 如果布尔表达式为真将执行的语句 */</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。<br>C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a number: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The number is positive.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The number is negative.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The number is zero.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以使用各种类型的运算符来构建表达式：</p>\n<ol>\n<li><p>关系运算符：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token comment\">// 执行代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>逻辑运算符：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> y <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 执行代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>位运算符：</p>\n <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> flags <span class=\"token operator\">=</span> <span class=\"token number\">0</span>b1011<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flags <span class=\"token operator\">&amp;</span> <span class=\"token number\">0</span>b1000<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 执行代码块</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h3><p><code>switch</code>语句是C语言中用于多路分支的控制语句，它根据表达式的值，选择性地执行与每个选项相关联的代码块。以下是<code>switch</code>语句的基本用法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">case</span> constant1<span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 与 constant1 相关的代码块</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> constant2<span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 与 constant2 相关的代码块</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 更多的 case 分支...</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n        <span class=\"token comment\">// 默认情况的代码块</span>\n        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>switch</code>语句包含以下几个部分：</p>\n<ol>\n<li><p><code>expression</code>：一个表达式，其结果将与每个case分支的常量值进行比较。</p>\n</li>\n<li><p><code>case</code>分支：每个case后面跟着一个常量表达式，用于与expression进行比较。如果expression的值与某个case的常量值匹配，将执行与该case相关联的代码块。</p>\n</li>\n<li><p><code>break</code>语句：在每个case分支的代码块结束时使用break语句，以终止switch语句的执行。如果忽略了break语句，将会发生”穿透”现象，即会继续执行下一个case分支中的代码块，直到遇到break或switch语句结束。</p>\n</li>\n<li><p><code>default</code>分支：在所有的case分支都不匹配时，将执行default分支中的代码块。default是可选的，可以省略。</p>\n</li>\n</ol>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> choice<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Enter a number between 1 and 3: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>choice<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>choice<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You selected option 1.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You selected option 2.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> <span class=\"token number\">3</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You selected option 3.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid option.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Enter a number between 1 and 3: 2\nYou selected option 2.\n\nEnter a number between 1 and 3: 5\nInvalid option.\n\nEnter a number between 1 and 3: 2.1\nYou selected option 2.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"控制语句：循环\"><a href=\"#控制语句：循环\" class=\"headerlink\" title=\"控制语句：循环\"></a>控制语句：循环</h2><h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><p>for循环是C语言中常用的一种迭代控制结构，它可以用于重复执行一段代码块，且提供了更灵活的循环控制。以下是for循环的语法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>initialization<span class=\"token punctuation\">;</span> condition<span class=\"token punctuation\">;</span> increment<span class=\"token operator\">/</span>decrement<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 循环体代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>for循环包含以下四个部分：</p>\n<ol>\n<li><p>initialization：在循环开始前执行的初始化表达式，用于初始化循环计数器或其他变量。</p>\n</li>\n<li><p>condition：在每次循环迭代前进行判断的条件表达式。只有当条件为真时，循环体中的代码块才会执行。如果条件为假，循环将结束，程序将继续执行循环后的代码。</p>\n</li>\n<li><p>increment&#x2F;decrement：在每次循环迭代后执行的增量或减量操作。它用于更新循环计数器或其他变量的值，以控制循环的进程。</p>\n</li>\n<li><p>循环体代码块：在 for 循环的花括号内部，是需要重复执行的代码块。这些代码将按照循环条件和增量&#x2F;减量操作的规则反复执行。</p>\n</li>\n</ol>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Count: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，for循环的各个部分都是可选的。如果省略了某个部分，相应的功能将被忽略，但循环仍然可以正常工作。例如，可以省略初始化表达式或增量操作，只保留条件表达式，以及在循环体内手动控制循环变量的更新。这样的灵活性使得for循环非常适用于各种迭代场景。</p>\n<h3 id=\"while循环和do-while循环\"><a href=\"#while循环和do-while循环\" class=\"headerlink\" title=\"while循环和do-while循环\"></a>while循环和do-while循环</h3><p><code>while</code>循环是C语言中的一种迭代控制结构，它用于重复执行一段代码块，只要给定的条件为真。以下是<code>while</code>循环的语法</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 循环体代码块</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>while 循环包含以下两个部分：</p>\n<ol>\n<li><p>condition：一个条件表达式，用于判断循环是否继续执行。如果条件为真，循环将继续执行循环体中的代码块；如果条件为假，循环将结束，程序将继续执行循环后的代码。</p>\n</li>\n<li><p>循环体代码块：在 while 循环的花括号内部，是需要重复执行的代码块。这些代码将反复执行，直到条件为假。</p>\n</li>\n</ol>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述示例中，<code>while</code>循环的条件是<code>count&lt;5</code>，只要<code>count</code>的值小于5，循环体中的代码块将被重复执行。每次循环，<code>count</code>的值会递增，并打印出当前的值。当<code>count</code>的值达到或超过5时，条件为假，循环结束。</p>\n<p>需要注意的是，如果条件一开始就为假，循环体中的代码块将不会执行，循环将被跳过。因此，在使用<code>while</code>循环时，请确保循环条件能够在某个时刻变为假，以避免陷入无限循环。通常，在循环体中需要修改条件表达式或使用控制语句（如<code>break</code>）来终止循环。</p>\n<h3 id=\"continue语句和break语句\"><a href=\"#continue语句和break语句\" class=\"headerlink\" title=\"continue语句和break语句\"></a>continue语句和break语句</h3><p>continue语句用于跳过当前循环迭代中剩余的代码，直接进行下一次迭代。它的作用是终止当前迭代的剩余代码，然后重新开始下一次循环迭代。continue语句通常与条件语句结合使用，用于在满足特定条件时跳过当前迭代。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当 i 等于 3 时跳过当前迭代</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Count: 1\nCount: 2\nCount: 4\nCount: 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述示例中，当<code>i</code>等于<code>3</code>时，<code>continue</code>语句将跳过<code>printf</code>语句，直接进入下一次循环迭代。因此，输出结果中不会包含数字<code>3</code>。</p>\n<p><code>break</code>语句用于完全终止当前的循环，不再执行循环中的任何代码，并跳出循环体继续执行循环后的代码。它通常与条件语句结合使用，用于在满足特定条件时提前结束循环。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当 i 等于 3 时终止循环</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>gcc -o test test.c</code>命令编译后使用<code>./test</code>运行代码，按提示信息输入相应类型的数据：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Count: 1\nCount: 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>在上述示例中，当<code>i</code>等于<code>3</code>时，<code>break</code>语句将完全终止循环，不再执行任何循环代码。因此，输出结果中只包含数字<code>1</code>和<code>2</code>，循环在此处结束。</p>\n"},{"title":"第四周","date":"2023-06-20T05:15:40.000Z","_content":"\n## 一维数组\n\n### 一维数组的定义和初始化\n\n数组属于一种构造数据类型，由一定数量的相同类型的元素构成。\n\n* 一维数组定义的语法格式：\n\n    ```c\n    <数据类型> <数组名称>[<大小>] = {<元素1>, <元素2>, ..., <元素N>};\n    ```\n\n    其中：\n    1. <数据类型> 指定数组中元素的数据类型，可以是基本类型（如 int、float、char 等）或自定义类型。  \n    2. <数组名称> 是数组的标识符，用于在程序中引用该数组。  \n    3. <大小> 指定数组的大小，即数组中元素的个数。  \n    4. {<元素1>, <元素2>, ..., <元素N>} 是可选的初始化列表，用于初始化数组中的元素。  \n\n    数组定义举例：\n\n    ```c\n    // 定义一个包含 5个整数的数组\n    int numbers[5] = {1, 2, 3, 4, 5};\n    // 定义一个包含 4个字符的数组\n    char characters[4] = {'A', 'B', 'C', 'D'};\n    // 定义一个包含 6个浮点数的数组\n    float values[6];\n    ```\n\n* 一维数组的初始化\n\n    创建test.c文件，编辑以下内容，可以通过IDE的调试功能观察数组的初始化:\n\n    ```c\n    #include <stdio.h>\n\n    int main(void)\n    {\n        int number[5] = {1, 2, 3, 4, 5};\n        //定义一个包含4个字符的数组并对前三个元素进行初始化\n        char characters[4] = {'A', 'B', 'C'};\n        //定义一个包含6个浮点数的数组并对第一个元素进行初始化\n        float values[6] = {1.0};\n\n        return 0;\n    }\n    ```\n\n### 一维数组的引用\n\n![4.第四周-2023-06-24-00-05-18](https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-05-18.png)\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main(void)\n{\n    int number[5] = {1, 2, 3, 4, 5};\n\n    printf(\"第一个元素是：%d\\n\", number[0]);    //输出：第一个元素是：1\n    printf(\"第二个元素是：%d\\n\", number[1]);    //输出：第二个元素是：2\n    printf(\"第三个元素是：%d\\n\", number[2]);    //输出：第三个元素是：3\n\n    return 0;\n}\n```\n\n## 二维数组\n\n二维数组是由多个一维数组组成的数据结构，在C语言中可以使用以下方式进行定义和初始化：\n\n```text\n数据类型 数组名[行数][列数];\n```\n\n![4.第四周-2023-06-24-00-40-55](https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-40-55.png)\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    // 定义一个 3x4 的整数二维数组\n    int number[3][4];\n\n    // 初始化二维数组的元素\n    number[0][0] = 1;\n    number[0][1] = 2;\n    number[0][2] = 3;\n    number[0][3] = 4;\n\n    //在定义时初始化数组\n    int num[3][4] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12}\n    };\n\n\n    // 打印输出二维数组的元素\n    printf(\"number:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%d \", number[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n## 字符串与字符数组\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(void)\n{\n    /*字符数组赋初值*/\n    char cArr[] = {'I','L','O','V','E','C'};\n    /*字符串赋初值\n    编译时会自动在末尾增加一个 null 字符*/\n    char sArr[] = \"ILOVEC\";\n    /*用sizeof（）求长度*/\n    printf(\"cArr的长度=%d\\n\", sizeof(cArr));    //输出：cArr的长度=6\n    printf(\"sArr的长度=%d\\n\", sizeof(sArr));    //输出：sArr的长度=7\n    /*用strlen（）求长度*/\n    printf(\"cArr的长度=%d\\n\", strlen(cArr));    //输出：cArr的长度=12\n    printf(\"sArr的长度=%d\\n\", strlen(sArr));    //输出：sArr的长度=6\n    /*用printf的%s打印内容*/\n    printf(\"cArr的内容=%s\\n\", cArr);            //输出：cArr的内容=ILOVECILOVEC\n    printf(\"sArr的内容=%s\\n\", sArr);            //输出：sArr的内容=ILOVEC\n    return 0;\n}\n```\n\n* 对于字符数组，其长度是固定的，其中任何一个数组元素都可以为 null 字符。因此，字符数组不一定是字符串。\n* 对于字符串，它必须以 null 结尾，其后的字符不属于该字符串。字符串一定是字符数组，它是最后一个字符为 null 字符的字符数组。\n\n## 函数的定义和调用\n\n函数定义的一般格式：\n\n```c\n返回值类型 函数名(参数列表) {\n    // 函数体\n    // 执行特定的功能代码\n    // 可能包含 return 语句用于返回结果\n}\n```\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\n// 用户自定义函数，计算两个整数的和\nint sum(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\nint main() {\n    int num1 = 5;\n    int num2 = 7;\n\n    // 调用自定义函数\n    int result = sum(num1, num2);\n    \n    printf(\"The sum is: %d\\n\", result);\n\n    return 0;\n}\n```\n\n需要注意以下几点：\n\n1. 返回值类型：指定函数返回的结果的类型，可以是整数类型、浮点类型、字符类型或指针类型等。\n1. 函数名：用于标识函数的名称，在调用函数时使用该名称。\n1. 参数列表：列出函数接受的参数类型和参数名称，多个参数之间用逗号分隔。\n1. 函数体：包含了执行特定功能的代码，可以是一条或多条语句。\n1. 返回值：使用return语句将结果返回给调用者。返回值类型必须与函数定义中的返回值类型匹配。\n\n函数声明的用法：\n\n```c\n#include <stdio.h>\n\n// 函数声明\nint sum(int a, int b);\n\nint main() {\n    int num1 = 5;\n    int num2 = 7;\n\n    // 调用自定义函数\n    int result = sum(num1, num2);\n    \n    printf(\"The sum is: %d\\n\", result);\n\n    return 0;\n}\n\n// 函数定义\nint sum(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\n```\n\n### 函数的值传递\n\n在 C 语言中，函数参数的传递方式是值传递（pass-by-value）。这意味着在函数调用时，实际参数的值会被复制给形式参数（函数定义中的参数），并在函数内部使用。因此，函数内部对形式参数的修改不会影响到实际参数的值。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nvoid modifyValue(int x) {\n    x = 10;  // 修改形式参数 x 的值\n}\n\nint main() {\n    int num = 5;\n\n    printf(\"Before function call: %d\\n\", num);  //输出结果：Before function call: 5\n\n    modifyValue(num);  // 调用函数，传递实际参数 num\n\n    printf(\"After function call: %d\\n\", num);   //输出结果：After function call: 5\n\n    return 0;\n}\n\n```\n\n需要注意的是，如果实际参数是指针类型，函数可以通过指针间接地修改实际参数所指向的值。这是因为指针本身也是一个值，通过复制指针的值，函数可以访问和修改指针所指向的内存。但是，这并不改变值传递的本质，只是通过指针来间接地修改了实际参数的值。\n\n```c\n#include <stdio.h>\n\nvoid modifyValue(int *ptr) {\n    *ptr = 10;  // 通过指针修改实际参数的值\n}\n\nint main() {\n    int num = 5;\n\n    printf(\"Before function call: %d\\n\", num);\n\n    modifyValue(&num);  // 传递实际参数的地址作为指针参数\n\n    printf(\"After function call: %d\\n\", num);\n\n    return 0;\n}\n```\n\n### 递归调用\n\n在 C 语言中，递归调用是指一个函数直接或间接地调用自身。递归调用通常用于解决可以分解为相同问题的子问题的情况，每次递归调用都在更小的范围内解决问题，直到达到终止条件。\n\n下面是一个示例，演示了在 C 语言中使用递归调用计算斐波那契数列的第 n 个数字（斐波那契数列前11位：1，1，2，3，5，8，13，21，34，55，89）：\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    // 终止条件\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    }\n  \n    // 递归调用\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int n = 10;\n    int result = fibonacci(n);\n\n    printf(\"The %dth Fibonacci number is: %d\\n\", n, result);\n\n    return 0;\n}\n```\n\n### 全局变量和局部变量\n\n在C语言中，局部变量和全局变量是两种不同的变量类型，它们具有不同的作用域和生存周期。\n\n* 局部变量\n\n    1. 局部变量是在函数内部声明的变量，它只在函数的作用域内可见。\n    1. 局部变量的作用域仅限于声明它的函数内部，函数执行结束后，局部变量将被销毁。\n    1. 局部变量必须在使用之前先进行声明。\n    1. 局部变量的生命周期随着函数的调用和执行而开始和结束。\n\n    示例代码：\n\n    ```c\n    # include <stdio.h>\n\n    void foo() {\n        int x = 10;  // 局部变量 x\n        printf(\"Inside foo: %d\\n\", x);\n    }\n\n    int main() {\n        foo();\n        // printf(\"%d\\n\", x);  // 错误，无法访问 foo 函数内的局部变量 x\n\n        return 0;\n    }\n    ```\n\n* 全局变量\n\n    1. 全局变量是在函数外部声明的变量，它可以在整个程序的任何地方访问。\n    1. 全局变量的作用域从声明开始，延伸到文件的末尾，可以在程序的任何地方使用和修改它。\n    1. 全局变量在程序启动时创建，在程序结束时销毁。\n    1. 全局变量可以在任何函数内部进行访问，但需要通过关键字 extern 进行声明。\n\n    示例代码：\n\n    ```c\n    # include <stdio.h>\n\n    int globalVar = 20;  // 全局变量\n\n    void foo() {\n        printf(\"Inside foo: %d\\n\", globalVar);\n    }\n\n    int main() {\n        foo();\n        printf(\"Inside main: %d\\n\", globalVar);\n\n        return 0;\n    }\n    ```\n\n 需要注意的是，全局变量的使用应谨慎，因为全局变量的可见性和可修改性可能会导致程序的可维护性和可理解性下降。一般来说，应该尽量避免过度使用全局变量，而是优先使用局部变量来限制变量的作用范围，以提高代码的可读性和可维护性。\n","source":"_posts/c_program/4.第四周.md","raw":"---\ntitle: 第四周\ndate: 2023-06-20 13:15:40\ntags: \n---\n\n## 一维数组\n\n### 一维数组的定义和初始化\n\n数组属于一种构造数据类型，由一定数量的相同类型的元素构成。\n\n* 一维数组定义的语法格式：\n\n    ```c\n    <数据类型> <数组名称>[<大小>] = {<元素1>, <元素2>, ..., <元素N>};\n    ```\n\n    其中：\n    1. <数据类型> 指定数组中元素的数据类型，可以是基本类型（如 int、float、char 等）或自定义类型。  \n    2. <数组名称> 是数组的标识符，用于在程序中引用该数组。  \n    3. <大小> 指定数组的大小，即数组中元素的个数。  \n    4. {<元素1>, <元素2>, ..., <元素N>} 是可选的初始化列表，用于初始化数组中的元素。  \n\n    数组定义举例：\n\n    ```c\n    // 定义一个包含 5个整数的数组\n    int numbers[5] = {1, 2, 3, 4, 5};\n    // 定义一个包含 4个字符的数组\n    char characters[4] = {'A', 'B', 'C', 'D'};\n    // 定义一个包含 6个浮点数的数组\n    float values[6];\n    ```\n\n* 一维数组的初始化\n\n    创建test.c文件，编辑以下内容，可以通过IDE的调试功能观察数组的初始化:\n\n    ```c\n    #include <stdio.h>\n\n    int main(void)\n    {\n        int number[5] = {1, 2, 3, 4, 5};\n        //定义一个包含4个字符的数组并对前三个元素进行初始化\n        char characters[4] = {'A', 'B', 'C'};\n        //定义一个包含6个浮点数的数组并对第一个元素进行初始化\n        float values[6] = {1.0};\n\n        return 0;\n    }\n    ```\n\n### 一维数组的引用\n\n![4.第四周-2023-06-24-00-05-18](https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-05-18.png)\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main(void)\n{\n    int number[5] = {1, 2, 3, 4, 5};\n\n    printf(\"第一个元素是：%d\\n\", number[0]);    //输出：第一个元素是：1\n    printf(\"第二个元素是：%d\\n\", number[1]);    //输出：第二个元素是：2\n    printf(\"第三个元素是：%d\\n\", number[2]);    //输出：第三个元素是：3\n\n    return 0;\n}\n```\n\n## 二维数组\n\n二维数组是由多个一维数组组成的数据结构，在C语言中可以使用以下方式进行定义和初始化：\n\n```text\n数据类型 数组名[行数][列数];\n```\n\n![4.第四周-2023-06-24-00-40-55](https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-40-55.png)\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nint main() {\n    // 定义一个 3x4 的整数二维数组\n    int number[3][4];\n\n    // 初始化二维数组的元素\n    number[0][0] = 1;\n    number[0][1] = 2;\n    number[0][2] = 3;\n    number[0][3] = 4;\n\n    //在定义时初始化数组\n    int num[3][4] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12}\n    };\n\n\n    // 打印输出二维数组的元素\n    printf(\"number:\\n\");\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            printf(\"%d \", number[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n## 字符串与字符数组\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(void)\n{\n    /*字符数组赋初值*/\n    char cArr[] = {'I','L','O','V','E','C'};\n    /*字符串赋初值\n    编译时会自动在末尾增加一个 null 字符*/\n    char sArr[] = \"ILOVEC\";\n    /*用sizeof（）求长度*/\n    printf(\"cArr的长度=%d\\n\", sizeof(cArr));    //输出：cArr的长度=6\n    printf(\"sArr的长度=%d\\n\", sizeof(sArr));    //输出：sArr的长度=7\n    /*用strlen（）求长度*/\n    printf(\"cArr的长度=%d\\n\", strlen(cArr));    //输出：cArr的长度=12\n    printf(\"sArr的长度=%d\\n\", strlen(sArr));    //输出：sArr的长度=6\n    /*用printf的%s打印内容*/\n    printf(\"cArr的内容=%s\\n\", cArr);            //输出：cArr的内容=ILOVECILOVEC\n    printf(\"sArr的内容=%s\\n\", sArr);            //输出：sArr的内容=ILOVEC\n    return 0;\n}\n```\n\n* 对于字符数组，其长度是固定的，其中任何一个数组元素都可以为 null 字符。因此，字符数组不一定是字符串。\n* 对于字符串，它必须以 null 结尾，其后的字符不属于该字符串。字符串一定是字符数组，它是最后一个字符为 null 字符的字符数组。\n\n## 函数的定义和调用\n\n函数定义的一般格式：\n\n```c\n返回值类型 函数名(参数列表) {\n    // 函数体\n    // 执行特定的功能代码\n    // 可能包含 return 语句用于返回结果\n}\n```\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\n// 用户自定义函数，计算两个整数的和\nint sum(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\nint main() {\n    int num1 = 5;\n    int num2 = 7;\n\n    // 调用自定义函数\n    int result = sum(num1, num2);\n    \n    printf(\"The sum is: %d\\n\", result);\n\n    return 0;\n}\n```\n\n需要注意以下几点：\n\n1. 返回值类型：指定函数返回的结果的类型，可以是整数类型、浮点类型、字符类型或指针类型等。\n1. 函数名：用于标识函数的名称，在调用函数时使用该名称。\n1. 参数列表：列出函数接受的参数类型和参数名称，多个参数之间用逗号分隔。\n1. 函数体：包含了执行特定功能的代码，可以是一条或多条语句。\n1. 返回值：使用return语句将结果返回给调用者。返回值类型必须与函数定义中的返回值类型匹配。\n\n函数声明的用法：\n\n```c\n#include <stdio.h>\n\n// 函数声明\nint sum(int a, int b);\n\nint main() {\n    int num1 = 5;\n    int num2 = 7;\n\n    // 调用自定义函数\n    int result = sum(num1, num2);\n    \n    printf(\"The sum is: %d\\n\", result);\n\n    return 0;\n}\n\n// 函数定义\nint sum(int a, int b) {\n    int result = a + b;\n    return result;\n}\n\n```\n\n### 函数的值传递\n\n在 C 语言中，函数参数的传递方式是值传递（pass-by-value）。这意味着在函数调用时，实际参数的值会被复制给形式参数（函数定义中的参数），并在函数内部使用。因此，函数内部对形式参数的修改不会影响到实际参数的值。\n\n创建test.c文件，编辑以下代码：\n\n```c\n#include <stdio.h>\n\nvoid modifyValue(int x) {\n    x = 10;  // 修改形式参数 x 的值\n}\n\nint main() {\n    int num = 5;\n\n    printf(\"Before function call: %d\\n\", num);  //输出结果：Before function call: 5\n\n    modifyValue(num);  // 调用函数，传递实际参数 num\n\n    printf(\"After function call: %d\\n\", num);   //输出结果：After function call: 5\n\n    return 0;\n}\n\n```\n\n需要注意的是，如果实际参数是指针类型，函数可以通过指针间接地修改实际参数所指向的值。这是因为指针本身也是一个值，通过复制指针的值，函数可以访问和修改指针所指向的内存。但是，这并不改变值传递的本质，只是通过指针来间接地修改了实际参数的值。\n\n```c\n#include <stdio.h>\n\nvoid modifyValue(int *ptr) {\n    *ptr = 10;  // 通过指针修改实际参数的值\n}\n\nint main() {\n    int num = 5;\n\n    printf(\"Before function call: %d\\n\", num);\n\n    modifyValue(&num);  // 传递实际参数的地址作为指针参数\n\n    printf(\"After function call: %d\\n\", num);\n\n    return 0;\n}\n```\n\n### 递归调用\n\n在 C 语言中，递归调用是指一个函数直接或间接地调用自身。递归调用通常用于解决可以分解为相同问题的子问题的情况，每次递归调用都在更小的范围内解决问题，直到达到终止条件。\n\n下面是一个示例，演示了在 C 语言中使用递归调用计算斐波那契数列的第 n 个数字（斐波那契数列前11位：1，1，2，3，5，8，13，21，34，55，89）：\n\n```c\n#include <stdio.h>\n\nint fibonacci(int n) {\n    // 终止条件\n    if (n == 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    }\n  \n    // 递归调用\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    int n = 10;\n    int result = fibonacci(n);\n\n    printf(\"The %dth Fibonacci number is: %d\\n\", n, result);\n\n    return 0;\n}\n```\n\n### 全局变量和局部变量\n\n在C语言中，局部变量和全局变量是两种不同的变量类型，它们具有不同的作用域和生存周期。\n\n* 局部变量\n\n    1. 局部变量是在函数内部声明的变量，它只在函数的作用域内可见。\n    1. 局部变量的作用域仅限于声明它的函数内部，函数执行结束后，局部变量将被销毁。\n    1. 局部变量必须在使用之前先进行声明。\n    1. 局部变量的生命周期随着函数的调用和执行而开始和结束。\n\n    示例代码：\n\n    ```c\n    # include <stdio.h>\n\n    void foo() {\n        int x = 10;  // 局部变量 x\n        printf(\"Inside foo: %d\\n\", x);\n    }\n\n    int main() {\n        foo();\n        // printf(\"%d\\n\", x);  // 错误，无法访问 foo 函数内的局部变量 x\n\n        return 0;\n    }\n    ```\n\n* 全局变量\n\n    1. 全局变量是在函数外部声明的变量，它可以在整个程序的任何地方访问。\n    1. 全局变量的作用域从声明开始，延伸到文件的末尾，可以在程序的任何地方使用和修改它。\n    1. 全局变量在程序启动时创建，在程序结束时销毁。\n    1. 全局变量可以在任何函数内部进行访问，但需要通过关键字 extern 进行声明。\n\n    示例代码：\n\n    ```c\n    # include <stdio.h>\n\n    int globalVar = 20;  // 全局变量\n\n    void foo() {\n        printf(\"Inside foo: %d\\n\", globalVar);\n    }\n\n    int main() {\n        foo();\n        printf(\"Inside main: %d\\n\", globalVar);\n\n        return 0;\n    }\n    ```\n\n 需要注意的是，全局变量的使用应谨慎，因为全局变量的可见性和可修改性可能会导致程序的可维护性和可理解性下降。一般来说，应该尽量避免过度使用全局变量，而是优先使用局部变量来限制变量的作用范围，以提高代码的可读性和可维护性。\n","slug":"c_program/4.第四周","published":1,"updated":"2023-06-23T18:07:42.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04e00041dnz2z8mcxnv","content":"<h2 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h2><h3 id=\"一维数组的定义和初始化\"><a href=\"#一维数组的定义和初始化\" class=\"headerlink\" title=\"一维数组的定义和初始化\"></a>一维数组的定义和初始化</h3><p>数组属于一种构造数据类型，由一定数量的相同类型的元素构成。</p>\n<ul>\n<li><p>一维数组定义的语法格式：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token operator\">&lt;</span>数据类型<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>数组名称<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>大小<span class=\"token operator\">></span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token operator\">&lt;</span>元素<span class=\"token number\">1</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span>元素<span class=\"token number\">2</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span>元素N<span class=\"token operator\">></span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  其中：</p>\n<ol>\n<li>&lt;数据类型&gt; 指定数组中元素的数据类型，可以是基本类型（如 int、float、char 等）或自定义类型。  </li>\n<li>&lt;数组名称&gt; 是数组的标识符，用于在程序中引用该数组。  </li>\n<li>&lt;大小&gt; 指定数组的大小，即数组中元素的个数。  </li>\n<li>{&lt;元素1&gt;, &lt;元素2&gt;, …, &lt;元素N&gt;} 是可选的初始化列表，用于初始化数组中的元素。</li>\n</ol>\n<p>  数组定义举例：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// 定义一个包含 5个整数的数组</span>\n<span class=\"token keyword\">int</span> numbers<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 定义一个包含 4个字符的数组</span>\n<span class=\"token keyword\">char</span> characters<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'C'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'D'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 定义一个包含 6个浮点数的数组</span>\n<span class=\"token keyword\">float</span> values<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>一维数组的初始化</p>\n<p>  创建test.c文件，编辑以下内容，可以通过IDE的调试功能观察数组的初始化:</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//定义一个包含4个字符的数组并对前三个元素进行初始化</span>\n    <span class=\"token keyword\">char</span> characters<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'C'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//定义一个包含6个浮点数的数组并对第一个元素进行初始化</span>\n    <span class=\"token keyword\">float</span> values<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"一维数组的引用\"><a href=\"#一维数组的引用\" class=\"headerlink\" title=\"一维数组的引用\"></a>一维数组的引用</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-05-18.png\" alt=\"4.第四周-2023-06-24-00-05-18\"></p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第一个元素是：%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：第一个元素是：1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第二个元素是：%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：第二个元素是：2</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第三个元素是：%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：第三个元素是：3</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><p>二维数组是由多个一维数组组成的数据结构，在C语言中可以使用以下方式进行定义和初始化：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">数据类型 数组名[行数][列数];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-40-55.png\" alt=\"4.第四周-2023-06-24-00-40-55\"></p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 定义一个 3x4 的整数二维数组</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 初始化二维数组的元素</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//在定义时初始化数组</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token comment\">// 打印输出二维数组的元素</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"number:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"字符串与字符数组\"><a href=\"#字符串与字符数组\" class=\"headerlink\" title=\"字符串与字符数组\"></a>字符串与字符数组</h2><p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/*字符数组赋初值*/</span>\n    <span class=\"token keyword\">char</span> cArr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'I'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'L'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'O'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'V'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'E'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'C'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/*字符串赋初值\n    编译时会自动在末尾增加一个 null 字符*/</span>\n    <span class=\"token keyword\">char</span> sArr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"ILOVEC\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/*用sizeof（）求长度*/</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>cArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：cArr的长度=6</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>sArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：sArr的长度=7</span>\n    <span class=\"token comment\">/*用strlen（）求长度*/</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>cArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：cArr的长度=12</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>sArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：sArr的长度=6</span>\n    <span class=\"token comment\">/*用printf的%s打印内容*/</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cArr的内容=%s\\n\"</span><span class=\"token punctuation\">,</span> cArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">//输出：cArr的内容=ILOVECILOVEC</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sArr的内容=%s\\n\"</span><span class=\"token punctuation\">,</span> sArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">//输出：sArr的内容=ILOVEC</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>对于字符数组，其长度是固定的，其中任何一个数组元素都可以为 null 字符。因此，字符数组不一定是字符串。</li>\n<li>对于字符串，它必须以 null 结尾，其后的字符不属于该字符串。字符串一定是字符数组，它是最后一个字符为 null 字符的字符数组。</li>\n</ul>\n<h2 id=\"函数的定义和调用\"><a href=\"#函数的定义和调用\" class=\"headerlink\" title=\"函数的定义和调用\"></a>函数的定义和调用</h2><p>函数定义的一般格式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">返回值类型 函数名<span class=\"token punctuation\">(</span>参数列表<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 函数体</span>\n    <span class=\"token comment\">// 执行特定的功能代码</span>\n    <span class=\"token comment\">// 可能包含 return 语句用于返回结果</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\">// 用户自定义函数，计算两个整数的和</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 调用自定义函数</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The sum is: %d\\n\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意以下几点：</p>\n<ol>\n<li>返回值类型：指定函数返回的结果的类型，可以是整数类型、浮点类型、字符类型或指针类型等。</li>\n<li>函数名：用于标识函数的名称，在调用函数时使用该名称。</li>\n<li>参数列表：列出函数接受的参数类型和参数名称，多个参数之间用逗号分隔。</li>\n<li>函数体：包含了执行特定功能的代码，可以是一条或多条语句。</li>\n<li>返回值：使用return语句将结果返回给调用者。返回值类型必须与函数定义中的返回值类型匹配。</li>\n</ol>\n<p>函数声明的用法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\">// 函数声明</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 调用自定义函数</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The sum is: %d\\n\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 函数定义</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"函数的值传递\"><a href=\"#函数的值传递\" class=\"headerlink\" title=\"函数的值传递\"></a>函数的值传递</h3><p>在 C 语言中，函数参数的传递方式是值传递（pass-by-value）。这意味着在函数调用时，实际参数的值会被复制给形式参数（函数定义中的参数），并在函数内部使用。因此，函数内部对形式参数的修改不会影响到实际参数的值。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 修改形式参数 x 的值</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//输出结果：Before function call: 5</span>\n\n    <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 调用函数，传递实际参数 num</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//输出结果：After function call: 5</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，如果实际参数是指针类型，函数可以通过指针间接地修改实际参数所指向的值。这是因为指针本身也是一个值，通过复制指针的值，函数可以访问和修改指针所指向的内存。但是，这并不改变值传递的本质，只是通过指针来间接地修改了实际参数的值。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 通过指针修改实际参数的值</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 传递实际参数的地址作为指针参数</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"递归调用\"><a href=\"#递归调用\" class=\"headerlink\" title=\"递归调用\"></a>递归调用</h3><p>在 C 语言中，递归调用是指一个函数直接或间接地调用自身。递归调用通常用于解决可以分解为相同问题的子问题的情况，每次递归调用都在更小的范围内解决问题，直到达到终止条件。</p>\n<p>下面是一个示例，演示了在 C 语言中使用递归调用计算斐波那契数列的第 n 个数字（斐波那契数列前11位：1，1，2，3，5，8，13，21，34，55，89）：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 终止条件</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  \n    <span class=\"token comment\">// 递归调用</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The %dth Fibonacci number is: %d\\n\"</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"全局变量和局部变量\"><a href=\"#全局变量和局部变量\" class=\"headerlink\" title=\"全局变量和局部变量\"></a>全局变量和局部变量</h3><p>在C语言中，局部变量和全局变量是两种不同的变量类型，它们具有不同的作用域和生存周期。</p>\n<ul>\n<li><p>局部变量</p>\n<ol>\n<li>局部变量是在函数内部声明的变量，它只在函数的作用域内可见。</li>\n<li>局部变量的作用域仅限于声明它的函数内部，函数执行结束后，局部变量将被销毁。</li>\n<li>局部变量必须在使用之前先进行声明。</li>\n<li>局部变量的生命周期随着函数的调用和执行而开始和结束。</li>\n</ol>\n<p>  示例代码：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 局部变量 x</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside foo: %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// printf(\"%d\\n\", x);  // 错误，无法访问 foo 函数内的局部变量 x</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>全局变量</p>\n<ol>\n<li>全局变量是在函数外部声明的变量，它可以在整个程序的任何地方访问。</li>\n<li>全局变量的作用域从声明开始，延伸到文件的末尾，可以在程序的任何地方使用和修改它。</li>\n<li>全局变量在程序启动时创建，在程序结束时销毁。</li>\n<li>全局变量可以在任何函数内部进行访问，但需要通过关键字 extern 进行声明。</li>\n</ol>\n<p>  示例代码：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> globalVar <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 全局变量</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside foo: %d\\n\"</span><span class=\"token punctuation\">,</span> globalVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside main: %d\\n\"</span><span class=\"token punctuation\">,</span> globalVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p> 需要注意的是，全局变量的使用应谨慎，因为全局变量的可见性和可修改性可能会导致程序的可维护性和可理解性下降。一般来说，应该尽量避免过度使用全局变量，而是优先使用局部变量来限制变量的作用范围，以提高代码的可读性和可维护性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h2><h3 id=\"一维数组的定义和初始化\"><a href=\"#一维数组的定义和初始化\" class=\"headerlink\" title=\"一维数组的定义和初始化\"></a>一维数组的定义和初始化</h3><p>数组属于一种构造数据类型，由一定数量的相同类型的元素构成。</p>\n<ul>\n<li><p>一维数组定义的语法格式：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token operator\">&lt;</span>数据类型<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>数组名称<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>大小<span class=\"token operator\">></span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token operator\">&lt;</span>元素<span class=\"token number\">1</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span>元素<span class=\"token number\">2</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span>元素N<span class=\"token operator\">></span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  其中：</p>\n<ol>\n<li>&lt;数据类型&gt; 指定数组中元素的数据类型，可以是基本类型（如 int、float、char 等）或自定义类型。  </li>\n<li>&lt;数组名称&gt; 是数组的标识符，用于在程序中引用该数组。  </li>\n<li>&lt;大小&gt; 指定数组的大小，即数组中元素的个数。  </li>\n<li>{&lt;元素1&gt;, &lt;元素2&gt;, …, &lt;元素N&gt;} 是可选的初始化列表，用于初始化数组中的元素。</li>\n</ol>\n<p>  数组定义举例：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">// 定义一个包含 5个整数的数组</span>\n<span class=\"token keyword\">int</span> numbers<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 定义一个包含 4个字符的数组</span>\n<span class=\"token keyword\">char</span> characters<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'C'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'D'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 定义一个包含 6个浮点数的数组</span>\n<span class=\"token keyword\">float</span> values<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>一维数组的初始化</p>\n<p>  创建test.c文件，编辑以下内容，可以通过IDE的调试功能观察数组的初始化:</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//定义一个包含4个字符的数组并对前三个元素进行初始化</span>\n    <span class=\"token keyword\">char</span> characters<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'C'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//定义一个包含6个浮点数的数组并对第一个元素进行初始化</span>\n    <span class=\"token keyword\">float</span> values<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"一维数组的引用\"><a href=\"#一维数组的引用\" class=\"headerlink\" title=\"一维数组的引用\"></a>一维数组的引用</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-05-18.png\" alt=\"4.第四周-2023-06-24-00-05-18\"></p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第一个元素是：%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：第一个元素是：1</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第二个元素是：%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：第二个元素是：2</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第三个元素是：%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：第三个元素是：3</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><p>二维数组是由多个一维数组组成的数据结构，在C语言中可以使用以下方式进行定义和初始化：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">数据类型 数组名[行数][列数];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note4.%E7%AC%AC%E5%9B%9B%E5%91%A8-2023-06-24-00-40-55.png\" alt=\"4.第四周-2023-06-24-00-40-55\"></p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 定义一个 3x4 的整数二维数组</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 初始化二维数组的元素</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    number<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//在定义时初始化数组</span>\n    <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">&#123;</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token comment\">// 打印输出二维数组的元素</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"number:\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span> number<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"字符串与字符数组\"><a href=\"#字符串与字符数组\" class=\"headerlink\" title=\"字符串与字符数组\"></a>字符串与字符数组</h2><p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/*字符数组赋初值*/</span>\n    <span class=\"token keyword\">char</span> cArr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token char\">'I'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'L'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'O'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'V'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'E'</span><span class=\"token punctuation\">,</span><span class=\"token char\">'C'</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/*字符串赋初值\n    编译时会自动在末尾增加一个 null 字符*/</span>\n    <span class=\"token keyword\">char</span> sArr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"ILOVEC\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/*用sizeof（）求长度*/</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>cArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：cArr的长度=6</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>sArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：sArr的长度=7</span>\n    <span class=\"token comment\">/*用strlen（）求长度*/</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>cArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：cArr的长度=12</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sArr的长度=%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>sArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//输出：sArr的长度=6</span>\n    <span class=\"token comment\">/*用printf的%s打印内容*/</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cArr的内容=%s\\n\"</span><span class=\"token punctuation\">,</span> cArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">//输出：cArr的内容=ILOVECILOVEC</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sArr的内容=%s\\n\"</span><span class=\"token punctuation\">,</span> sArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">//输出：sArr的内容=ILOVEC</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>对于字符数组，其长度是固定的，其中任何一个数组元素都可以为 null 字符。因此，字符数组不一定是字符串。</li>\n<li>对于字符串，它必须以 null 结尾，其后的字符不属于该字符串。字符串一定是字符数组，它是最后一个字符为 null 字符的字符数组。</li>\n</ul>\n<h2 id=\"函数的定义和调用\"><a href=\"#函数的定义和调用\" class=\"headerlink\" title=\"函数的定义和调用\"></a>函数的定义和调用</h2><p>函数定义的一般格式：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">返回值类型 函数名<span class=\"token punctuation\">(</span>参数列表<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 函数体</span>\n    <span class=\"token comment\">// 执行特定的功能代码</span>\n    <span class=\"token comment\">// 可能包含 return 语句用于返回结果</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\">// 用户自定义函数，计算两个整数的和</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 调用自定义函数</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The sum is: %d\\n\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意以下几点：</p>\n<ol>\n<li>返回值类型：指定函数返回的结果的类型，可以是整数类型、浮点类型、字符类型或指针类型等。</li>\n<li>函数名：用于标识函数的名称，在调用函数时使用该名称。</li>\n<li>参数列表：列出函数接受的参数类型和参数名称，多个参数之间用逗号分隔。</li>\n<li>函数体：包含了执行特定功能的代码，可以是一条或多条语句。</li>\n<li>返回值：使用return语句将结果返回给调用者。返回值类型必须与函数定义中的返回值类型匹配。</li>\n</ol>\n<p>函数声明的用法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\">// 函数声明</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 调用自定义函数</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The sum is: %d\\n\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 函数定义</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"函数的值传递\"><a href=\"#函数的值传递\" class=\"headerlink\" title=\"函数的值传递\"></a>函数的值传递</h3><p>在 C 语言中，函数参数的传递方式是值传递（pass-by-value）。这意味着在函数调用时，实际参数的值会被复制给形式参数（函数定义中的参数），并在函数内部使用。因此，函数内部对形式参数的修改不会影响到实际参数的值。</p>\n<p>创建test.c文件，编辑以下代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 修改形式参数 x 的值</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//输出结果：Before function call: 5</span>\n\n    <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 调用函数，传递实际参数 num</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//输出结果：After function call: 5</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，如果实际参数是指针类型，函数可以通过指针间接地修改实际参数所指向的值。这是因为指针本身也是一个值，通过复制指针的值，函数可以访问和修改指针所指向的内存。但是，这并不改变值传递的本质，只是通过指针来间接地修改了实际参数的值。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 通过指针修改实际参数的值</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> num <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">modifyValue</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 传递实际参数的地址作为指针参数</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"After function call: %d\\n\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"递归调用\"><a href=\"#递归调用\" class=\"headerlink\" title=\"递归调用\"></a>递归调用</h3><p>在 C 语言中，递归调用是指一个函数直接或间接地调用自身。递归调用通常用于解决可以分解为相同问题的子问题的情况，每次递归调用都在更小的范围内解决问题，直到达到终止条件。</p>\n<p>下面是一个示例，演示了在 C 语言中使用递归调用计算斐波那契数列的第 n 个数字（斐波那契数列前11位：1，1，2，3，5，8，13，21，34，55，89）：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 终止条件</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  \n    <span class=\"token comment\">// 递归调用</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The %dth Fibonacci number is: %d\\n\"</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"全局变量和局部变量\"><a href=\"#全局变量和局部变量\" class=\"headerlink\" title=\"全局变量和局部变量\"></a>全局变量和局部变量</h3><p>在C语言中，局部变量和全局变量是两种不同的变量类型，它们具有不同的作用域和生存周期。</p>\n<ul>\n<li><p>局部变量</p>\n<ol>\n<li>局部变量是在函数内部声明的变量，它只在函数的作用域内可见。</li>\n<li>局部变量的作用域仅限于声明它的函数内部，函数执行结束后，局部变量将被销毁。</li>\n<li>局部变量必须在使用之前先进行声明。</li>\n<li>局部变量的生命周期随着函数的调用和执行而开始和结束。</li>\n</ol>\n<p>  示例代码：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 局部变量 x</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside foo: %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// printf(\"%d\\n\", x);  // 错误，无法访问 foo 函数内的局部变量 x</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>全局变量</p>\n<ol>\n<li>全局变量是在函数外部声明的变量，它可以在整个程序的任何地方访问。</li>\n<li>全局变量的作用域从声明开始，延伸到文件的末尾，可以在程序的任何地方使用和修改它。</li>\n<li>全局变量在程序启动时创建，在程序结束时销毁。</li>\n<li>全局变量可以在任何函数内部进行访问，但需要通过关键字 extern 进行声明。</li>\n</ol>\n<p>  示例代码：</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">int</span> globalVar <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 全局变量</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside foo: %d\\n\"</span><span class=\"token punctuation\">,</span> globalVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Inside main: %d\\n\"</span><span class=\"token punctuation\">,</span> globalVar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p> 需要注意的是，全局变量的使用应谨慎，因为全局变量的可见性和可修改性可能会导致程序的可维护性和可理解性下降。一般来说，应该尽量避免过度使用全局变量，而是优先使用局部变量来限制变量的作用范围，以提高代码的可读性和可维护性。</p>\n"},{"title":"Shell初始,编辑器使用","date":"2023-04-18T03:31:25.000Z","_content":"\n## 什么是Shell\n\n现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。  \n\n![1.Shell初识，编辑器使用-2023-04-19-18-53-43](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png)\n\n## Shell的各种版本\n\n1. Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。\n2. Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。\n3. zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。\n\n**练习**：\n\n```shell 查看Shell版本、更换默认Shell并生效设置\n##查看当前Shell版本\n[centos@host1 ~]$ echo $SHELL\n/bin/bash\n##查看系统当前可用Shell\n[centos@host1 ~]$ cat /etc/shells\n/bin/sh\n/bin/bash\n/usr/bin/sh\n/usr/bin/bash\n##更换默认Shell\n[centos@host1 ~]$ chsh -s /bin/sh\nChanging shell for root.\nShell changed.\n##退出当前登录状态重新登录\n[centos@host1 ~]$ logout\n```\n\n## Shell的启动方式和提示符\n\n1. 终端上启动\n    Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。  \n    用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。  \n    在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。\n\n2. 脚本启动\n    脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：\n    （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。\n    （2）将脚本文件保存到磁盘上，并赋予执行权限。\n    （3）在终端中输入脚本文件的路径，并按下回车键。\n    （4）Shell会读取脚本文件中的命令，并依次执行这些命令。\n    脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。\n\n3. 练习修改系统提示符: `vim ~/.bashrc` 中的PS1变量  \n\n![1.Shell初识，编辑器使用-2023-04-19-19-21-30](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png)\n\n## Linux的文件系统和权限信息\n\n- Linux和Windows文件目录的比较\n- Linux根目录各子目录的作用\n- 遍历目录\n\n### 文件权限  \n\n![1.Shell初识，编辑器使用-2023-04-19-23-41-03](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png)\n\n- Linux基本文件和目录命令使用综合练习\n\n    1. 新建一个名为`test`的目录，进入该目录并新建一个名为`file.txt`的文件。\n    2. 将`file.txt`复制到`test`目录下，并将其重命名为`file2.txt`。\n    3. 在当前目录下，新建一个名为`newdir`的目录。\n    4. 将`file2.txt`移动到`newdir`目录下。\n    5. 在当前目录下，使用`touch`命令创建一个名为`empty.txt`的空文件。\n    6. 在`newdir`目录下，使用`find`命令查找以`.txt`结尾的文件，并将结果输出到名为`result.txt`的文件中。\n    7. 在`newdir`目录下，使用`chmod`命令将`file2.txt`的所有用户的权限设置为可读可写可执行。\n    8. 在当前目录下，使用`mkdir`命令递归创建一个名为`parent/child/grandchild`的目录树。\n\n    答案：\n\n    ```bash\n    #1\n    mkdir test\n    cd test\n    touch file.txt\n    \n    #2\n    cp file.txt file2.txt\n    \n    #3\n    mkdir newdir\n    \n    #4\n    mv file2.txt newdir/\n    \n    #5\n    touch empty.txt\n    \n    #6\n    cd newdir\n    find . -name \"*.txt\" -type f > result.txt\n    \n    #7\n    chmod 777 file2.txt\n    \n    #8\n    mkdir -p parent/child/grandchild\n    \n    ```\n\n## VIM使用\n\n1. 学习平台：\n\n    [VIM官方文档](https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt)\n\n    [VIM基础练习平台](https://command-lab.com/cat-vim-ch-s/)\n\n    [VIM进阶](https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84)\n\n2. vim常用命令\n\n    ![1.Shell初识，编辑器使用-2023-04-19-23-41-33](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png)\n","source":"_posts/linux_shell/1.Shell初识，编辑器使用.md","raw":"---\ntitle: Shell初始,编辑器使用\ndate: 2023-04-18 11:31:25\ntags: \n---\n\n## 什么是Shell\n\n现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。  \n\n![1.Shell初识，编辑器使用-2023-04-19-18-53-43](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png)\n\n## Shell的各种版本\n\n1. Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。\n2. Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。\n3. zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。\n\n**练习**：\n\n```shell 查看Shell版本、更换默认Shell并生效设置\n##查看当前Shell版本\n[centos@host1 ~]$ echo $SHELL\n/bin/bash\n##查看系统当前可用Shell\n[centos@host1 ~]$ cat /etc/shells\n/bin/sh\n/bin/bash\n/usr/bin/sh\n/usr/bin/bash\n##更换默认Shell\n[centos@host1 ~]$ chsh -s /bin/sh\nChanging shell for root.\nShell changed.\n##退出当前登录状态重新登录\n[centos@host1 ~]$ logout\n```\n\n## Shell的启动方式和提示符\n\n1. 终端上启动\n    Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。  \n    用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。  \n    在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。\n\n2. 脚本启动\n    脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：\n    （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。\n    （2）将脚本文件保存到磁盘上，并赋予执行权限。\n    （3）在终端中输入脚本文件的路径，并按下回车键。\n    （4）Shell会读取脚本文件中的命令，并依次执行这些命令。\n    脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。\n\n3. 练习修改系统提示符: `vim ~/.bashrc` 中的PS1变量  \n\n![1.Shell初识，编辑器使用-2023-04-19-19-21-30](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png)\n\n## Linux的文件系统和权限信息\n\n- Linux和Windows文件目录的比较\n- Linux根目录各子目录的作用\n- 遍历目录\n\n### 文件权限  \n\n![1.Shell初识，编辑器使用-2023-04-19-23-41-03](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png)\n\n- Linux基本文件和目录命令使用综合练习\n\n    1. 新建一个名为`test`的目录，进入该目录并新建一个名为`file.txt`的文件。\n    2. 将`file.txt`复制到`test`目录下，并将其重命名为`file2.txt`。\n    3. 在当前目录下，新建一个名为`newdir`的目录。\n    4. 将`file2.txt`移动到`newdir`目录下。\n    5. 在当前目录下，使用`touch`命令创建一个名为`empty.txt`的空文件。\n    6. 在`newdir`目录下，使用`find`命令查找以`.txt`结尾的文件，并将结果输出到名为`result.txt`的文件中。\n    7. 在`newdir`目录下，使用`chmod`命令将`file2.txt`的所有用户的权限设置为可读可写可执行。\n    8. 在当前目录下，使用`mkdir`命令递归创建一个名为`parent/child/grandchild`的目录树。\n\n    答案：\n\n    ```bash\n    #1\n    mkdir test\n    cd test\n    touch file.txt\n    \n    #2\n    cp file.txt file2.txt\n    \n    #3\n    mkdir newdir\n    \n    #4\n    mv file2.txt newdir/\n    \n    #5\n    touch empty.txt\n    \n    #6\n    cd newdir\n    find . -name \"*.txt\" -type f > result.txt\n    \n    #7\n    chmod 777 file2.txt\n    \n    #8\n    mkdir -p parent/child/grandchild\n    \n    ```\n\n## VIM使用\n\n1. 学习平台：\n\n    [VIM官方文档](https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt)\n\n    [VIM基础练习平台](https://command-lab.com/cat-vim-ch-s/)\n\n    [VIM进阶](https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84)\n\n2. vim常用命令\n\n    ![1.Shell初识，编辑器使用-2023-04-19-23-41-33](https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png)\n","slug":"linux_shell/1.Shell初识，编辑器使用","published":1,"updated":"2023-06-16T03:10:44.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04f00051dnz69ekai1l","content":"<h2 id=\"什么是Shell\"><a href=\"#什么是Shell\" class=\"headerlink\" title=\"什么是Shell\"></a>什么是Shell</h2><p>现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。  </p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-18-53-43\"></p>\n<h2 id=\"Shell的各种版本\"><a href=\"#Shell的各种版本\" class=\"headerlink\" title=\"Shell的各种版本\"></a>Shell的各种版本</h2><ol>\n<li>Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。</li>\n<li>Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。</li>\n<li>zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。</li>\n</ol>\n<p><strong>练习</strong>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><div class=\"caption\"><span>查看Shell版本、更换默认Shell并生效设置</span></div><code class=\"language-bash\"><span class=\"token comment\">##查看当前Shell版本</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$SHELL</span>\n/bin/bash\n<span class=\"token comment\">##查看系统当前可用Shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">cat</span> /etc/shells\n/bin/sh\n/bin/bash\n/usr/bin/sh\n/usr/bin/bash\n<span class=\"token comment\">##更换默认Shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ chsh <span class=\"token parameter variable\">-s</span> /bin/sh\nChanging shell <span class=\"token keyword\">for</span> root.\nShell changed.\n<span class=\"token comment\">##退出当前登录状态重新登录</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">logout</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Shell的启动方式和提示符\"><a href=\"#Shell的启动方式和提示符\" class=\"headerlink\" title=\"Shell的启动方式和提示符\"></a>Shell的启动方式和提示符</h2><ol>\n<li><p>终端上启动<br> Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。<br> 用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。<br> 在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。</p>\n</li>\n<li><p>脚本启动<br> 脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：<br> （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。<br> （2）将脚本文件保存到磁盘上，并赋予执行权限。<br> （3）在终端中输入脚本文件的路径，并按下回车键。<br> （4）Shell会读取脚本文件中的命令，并依次执行这些命令。<br> 脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。</p>\n</li>\n<li><p>练习修改系统提示符: <code>vim ~/.bashrc</code> 中的PS1变量</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-19-21-30\"></p>\n<h2 id=\"Linux的文件系统和权限信息\"><a href=\"#Linux的文件系统和权限信息\" class=\"headerlink\" title=\"Linux的文件系统和权限信息\"></a>Linux的文件系统和权限信息</h2><ul>\n<li>Linux和Windows文件目录的比较</li>\n<li>Linux根目录各子目录的作用</li>\n<li>遍历目录</li>\n</ul>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-03\"></p>\n<ul>\n<li><p>Linux基本文件和目录命令使用综合练习</p>\n<ol>\n<li>新建一个名为<code>test</code>的目录，进入该目录并新建一个名为<code>file.txt</code>的文件。</li>\n<li>将<code>file.txt</code>复制到<code>test</code>目录下，并将其重命名为<code>file2.txt</code>。</li>\n<li>在当前目录下，新建一个名为<code>newdir</code>的目录。</li>\n<li>将<code>file2.txt</code>移动到<code>newdir</code>目录下。</li>\n<li>在当前目录下，使用<code>touch</code>命令创建一个名为<code>empty.txt</code>的空文件。</li>\n<li>在<code>newdir</code>目录下，使用<code>find</code>命令查找以<code>.txt</code>结尾的文件，并将结果输出到名为<code>result.txt</code>的文件中。</li>\n<li>在<code>newdir</code>目录下，使用<code>chmod</code>命令将<code>file2.txt</code>的所有用户的权限设置为可读可写可执行。</li>\n<li>在当前目录下，使用<code>mkdir</code>命令递归创建一个名为<code>parent/child/grandchild</code>的目录树。</li>\n</ol>\n<p>  答案：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#1</span>\n<span class=\"token function\">mkdir</span> <span class=\"token builtin class-name\">test</span>\n<span class=\"token builtin class-name\">cd</span> <span class=\"token builtin class-name\">test</span>\n<span class=\"token function\">touch</span> file.txt\n\n<span class=\"token comment\">#2</span>\n<span class=\"token function\">cp</span> file.txt file2.txt\n\n<span class=\"token comment\">#3</span>\n<span class=\"token function\">mkdir</span> newdir\n\n<span class=\"token comment\">#4</span>\n<span class=\"token function\">mv</span> file2.txt newdir/\n\n<span class=\"token comment\">#5</span>\n<span class=\"token function\">touch</span> empty.txt\n\n<span class=\"token comment\">#6</span>\n<span class=\"token builtin class-name\">cd</span> newdir\n<span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.txt\"</span> <span class=\"token parameter variable\">-type</span> f <span class=\"token operator\">></span> result.txt\n\n<span class=\"token comment\">#7</span>\n<span class=\"token function\">chmod</span> <span class=\"token number\">777</span> file2.txt\n\n<span class=\"token comment\">#8</span>\n<span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> parent/child/grandchild\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"VIM使用\"><a href=\"#VIM使用\" class=\"headerlink\" title=\"VIM使用\"></a>VIM使用</h2><ol>\n<li><p>学习平台：</p>\n<p> <a href=\"https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt\">VIM官方文档</a></p>\n<p> <a href=\"https://command-lab.com/cat-vim-ch-s/\">VIM基础练习平台</a></p>\n<p> <a href=\"https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84\">VIM进阶</a></p>\n</li>\n<li><p>vim常用命令</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-33\"></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Shell\"><a href=\"#什么是Shell\" class=\"headerlink\" title=\"什么是Shell\"></a>什么是Shell</h2><p>现在人们使用的操作系统（Windows、Android、iOS等）都带有图形界面，简单直观，容易上手。然而早期的计算机并没有图形界面，人们只能使用烦琐的命令来控制计算机。其实，真正能够控制计算机硬件（CPU、内存、显示器）的只有操作系统内核（Kernel），图形界面和命令行都是架设在用户和内核之间的桥梁，是为了方便用户控制计算机而存在的。由于安全等原因，用户不能直接接触内核，因此需要在用户和内核之间增加“命令解释器”，既能简化用户的操作，又能保障内核的安全。在Linux下的命令解释器叫作“Shell”，它能让用户更加高效、安全、低成本地使用Linux内核。  </p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-18-53-43.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-18-53-43\"></p>\n<h2 id=\"Shell的各种版本\"><a href=\"#Shell的各种版本\" class=\"headerlink\" title=\"Shell的各种版本\"></a>Shell的各种版本</h2><ol>\n<li>Bourne shell（sh）是Unix系统中最古老的shell，也是现在大多数shell的基础。它的命令行语法较为简单，缺乏一些高级特性，但是在大多数Unix系统中都内置了这个shell，因此可以保证可移植性。尽管Bourne shell已经被多种先进的shell所取代，但它作为shell编程的鼻祖，仍然具有重要的历史和学习价值。</li>\n<li>Bourne Again Shell （bash）是Linux操作系统所使用的Shell，它是Bourne Shell的扩展，简称bash。bash与Bourne Shell完全向下兼容，也就是说bash可以兼容相同版本的Bourne Shell。bash在Bourne Shell的基础上增加、增强了很多特性，所以它比Bourne Shell能力更强。</li>\n<li>zsh（Z shell）是Bourne shell（sh）的一个增强版本。与bash相比，zsh具有更好的命令补全功能、更好的主题和插件支持、更好的脚本语言、更好的历史命令管理和更好的可定制性。它还有许多其他功能，如自动提示，文件名扩展，别名扩展等。zsh是一种功能强大、易于使用和高度可定制的Shell，适用于任何需要使用命令行的用户。</li>\n</ol>\n<p><strong>练习</strong>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><div class=\"caption\"><span>查看Shell版本、更换默认Shell并生效设置</span></div><code class=\"language-bash\"><span class=\"token comment\">##查看当前Shell版本</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$SHELL</span>\n/bin/bash\n<span class=\"token comment\">##查看系统当前可用Shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">cat</span> /etc/shells\n/bin/sh\n/bin/bash\n/usr/bin/sh\n/usr/bin/bash\n<span class=\"token comment\">##更换默认Shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ chsh <span class=\"token parameter variable\">-s</span> /bin/sh\nChanging shell <span class=\"token keyword\">for</span> root.\nShell changed.\n<span class=\"token comment\">##退出当前登录状态重新登录</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">logout</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Shell的启动方式和提示符\"><a href=\"#Shell的启动方式和提示符\" class=\"headerlink\" title=\"Shell的启动方式和提示符\"></a>Shell的启动方式和提示符</h2><ol>\n<li><p>终端上启动<br> Shell会以交互模式启动，提示符会显示在屏幕上，等待用户输入命令。<br> 用户输入命令后，Shell会解释和执行这些命令，并将执行结果输出到终端上。<br> 在终端启动模式下，Shell会自动设置一些环境变量，如PATH等，以便用户可以方便地执行命令。</p>\n</li>\n<li><p>脚本启动<br> 脚本启动是将Shell命令写入一个脚本文件中，然后通过执行这个脚本文件来启动Shell。它的基本过程如下：<br> （1）创建一个包含Shell命令的脚本文件（通常以.sh作为扩展名）。<br> （2）将脚本文件保存到磁盘上，并赋予执行权限。<br> （3）在终端中输入脚本文件的路径，并按下回车键。<br> （4）Shell会读取脚本文件中的命令，并依次执行这些命令。<br> 脚本启动模式适用于需要重复执行的一系列命令，可以将这些命令写入脚本文件中，并通过脚本文件来执行这些命令。此外，脚本启动模式还支持各种Shell的内置命令和选项。</p>\n</li>\n<li><p>练习修改系统提示符: <code>vim ~/.bashrc</code> 中的PS1变量</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-19-21-30.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-19-21-30\"></p>\n<h2 id=\"Linux的文件系统和权限信息\"><a href=\"#Linux的文件系统和权限信息\" class=\"headerlink\" title=\"Linux的文件系统和权限信息\"></a>Linux的文件系统和权限信息</h2><ul>\n<li>Linux和Windows文件目录的比较</li>\n<li>Linux根目录各子目录的作用</li>\n<li>遍历目录</li>\n</ul>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-03.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-03\"></p>\n<ul>\n<li><p>Linux基本文件和目录命令使用综合练习</p>\n<ol>\n<li>新建一个名为<code>test</code>的目录，进入该目录并新建一个名为<code>file.txt</code>的文件。</li>\n<li>将<code>file.txt</code>复制到<code>test</code>目录下，并将其重命名为<code>file2.txt</code>。</li>\n<li>在当前目录下，新建一个名为<code>newdir</code>的目录。</li>\n<li>将<code>file2.txt</code>移动到<code>newdir</code>目录下。</li>\n<li>在当前目录下，使用<code>touch</code>命令创建一个名为<code>empty.txt</code>的空文件。</li>\n<li>在<code>newdir</code>目录下，使用<code>find</code>命令查找以<code>.txt</code>结尾的文件，并将结果输出到名为<code>result.txt</code>的文件中。</li>\n<li>在<code>newdir</code>目录下，使用<code>chmod</code>命令将<code>file2.txt</code>的所有用户的权限设置为可读可写可执行。</li>\n<li>在当前目录下，使用<code>mkdir</code>命令递归创建一个名为<code>parent/child/grandchild</code>的目录树。</li>\n</ol>\n<p>  答案：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#1</span>\n<span class=\"token function\">mkdir</span> <span class=\"token builtin class-name\">test</span>\n<span class=\"token builtin class-name\">cd</span> <span class=\"token builtin class-name\">test</span>\n<span class=\"token function\">touch</span> file.txt\n\n<span class=\"token comment\">#2</span>\n<span class=\"token function\">cp</span> file.txt file2.txt\n\n<span class=\"token comment\">#3</span>\n<span class=\"token function\">mkdir</span> newdir\n\n<span class=\"token comment\">#4</span>\n<span class=\"token function\">mv</span> file2.txt newdir/\n\n<span class=\"token comment\">#5</span>\n<span class=\"token function\">touch</span> empty.txt\n\n<span class=\"token comment\">#6</span>\n<span class=\"token builtin class-name\">cd</span> newdir\n<span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.txt\"</span> <span class=\"token parameter variable\">-type</span> f <span class=\"token operator\">></span> result.txt\n\n<span class=\"token comment\">#7</span>\n<span class=\"token function\">chmod</span> <span class=\"token number\">777</span> file2.txt\n\n<span class=\"token comment\">#8</span>\n<span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> parent/child/grandchild\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"VIM使用\"><a href=\"#VIM使用\" class=\"headerlink\" title=\"VIM使用\"></a>VIM使用</h2><ol>\n<li><p>学习平台：</p>\n<p> <a href=\"https://yianwillis.github.io/vimcdoc/doc/intro.html#intro.txt\">VIM官方文档</a></p>\n<p> <a href=\"https://command-lab.com/cat-vim-ch-s/\">VIM基础练习平台</a></p>\n<p> <a href=\"https://github.com/MeiTianT/vim-galore-zh_cn#%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84\">VIM进阶</a></p>\n</li>\n<li><p>vim常用命令</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.Shell%E5%88%9D%E8%AF%86%EF%BC%8C%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8-2023-04-19-23-41-33.png\" alt=\"1.Shell初识，编辑器使用-2023-04-19-23-41-33\"></p>\n</li>\n</ol>\n"},{"title":"文本处理工具awk","date":"2023-04-23T05:26:57.000Z","_content":"\n## awk简介\n\nawk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。\nawk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。\n\n## awk版本\n\nawk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为`/bin/gawk`或`/usr/bin/gawk`提供，是GNU工具集中的一部分，可以在多个平台上使用。\n不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。\n\n## awk格式\n\nawk基本格式如下：\n\n```text\nawk 'pattern { action }' file\nawk '{ action }' file\nawk 'pattern' file\n```\n\n* `pattern`: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行\n* `action`: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 `;` 分隔\n* `file`: 是输入文件的名称，没有`file`参数时从标准输入读取数据\n\n在awk命令中，`pattern`和`action`之间通过大括号 `{}` 进行分隔，`pattern`用于匹配文本行，当匹配成功时，对应的`action`将被执行。\n\nawk还支持在处理数据前和处理数据后运行命令，完整格式如下：\n\n```text\nawk 'BEGIN {command} pattern { action } END {command}' file\n```\n\n```sh\necho \"10 20 30 40 50\" | awk 'BEGIN {sum = 0; print \"sum:\", sum} {sum += $1} END {print \"Sum:\", sum}'\n```\n\n![10.text-processing-tools-awk-2023-04-24-09-42-32](https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png)\n\n## 从标准输入读取数据\n\n### 从命令行读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Hello World\"}'\ntest\nHello World\nabc\nHello World\n```\n\n以上awk命令没有指定`file`参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用`Ctrl+D`产生一个EOF字符，此时会返回到命令行下。\n\n### 通过管道符号从命令读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ ps -aux|awk '/bash/'\nroot           1  0.0  0.0  18228  3012 pts/0    Ss+  Apr22   0:00 /bin/bash\nroot          11  0.0  0.0  18232  3240 pts/1    Ss   13:36   0:00 /bin/bash\nubuntu       269  0.0  0.0  18228  3144 pts/1    S    13:39   0:00 bash\n```\n\n以上awk命令通过管道符号`|`从前面一个命令的输出结果从读取数据进行处理。\n\n## 从文件中读取数据和命令\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice,25,Female,New York\nubuntu@6e455ed15da7:~$ awk '/Male/' example.txt\nBob,30,Male,Los Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\n```\n\n以上awk命令指定了`file`参数，awk会从文件中以行为单位读取数据并且使用`pattern`所表示的匹配模式进行数据匹配，由于没有指定`action`参数，awk将匹配到的数据直接输出到标准输出。\n\nawk和sed一样可以从文件中读取命令：\n\n```sh\nawk -f script_file.awk example.txt\n```\n\n## awk工作原理\n\n1. awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0\n2. 这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。\n\n以以下数据为例：\n\n```text\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\n```\n\n以下awk命令的运行结果：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print $1,$3}' example.txt\nName Gender\nAlice Female\nBob Male\nCharlie Male\nDavid Male\nEve Female\n```\n\n1. awk首先将第一行数据存放在变量$0中进行处理。\n2. 将`$0`中的数据以空格为分隔符（内部变量`FS`所定义）进行分解，分别存放在从`$1`开始的内部变量中。\n3. 在输出结果的每一行中第一个字段是存放在`$1`中的数据，第二个字段是存放在`$3`中的数据。\n4. awk命令中的逗号映射为一个内部变量-输出字段分隔符`OFS`（默认为空格）两个字段之间由空格间隔。\n5. 处理完一行数据后读取下一行数据到`$0`中进行处理直到所以数据处理完毕。\n\n## 格式化输出\n\n### print函数\n\nprint函数用于打印不需要特别编排格式的简单输出。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"Age:\" $2}' example.txt\nName:NameAge:Age\nName:AliceAge:25\nName:BobAge:30\nName:CharlieAge:22\nName:DavidAge:35\nName:EveAge:28\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n逗号`,`表示内部变量`OFS`（用来表示输出字段的分隔符，默认为空格）。\nprint还支持以下转义序列：\n\n```text\n\\b：退格符（ASCII 008）\n\\t：制表符（ASCII 009）\n\\n：换行符（ASCII 010）\n\\f：换页符（ASCII 012）\n\\r：回车符（ASCII 013）\n```\n\nprint中使用转义序列进行数据输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"\\tAge:\" $2}' example.txt\nName:Name       Age:Age\nName:Alice      Age:25\nName:Bob        Age:30\nName:Charlie    Age:22\nName:David      Age:35\nName:Eve        Age:28\n```\n\n### printf函数\n\n`printf`函数能够进行更加精细的格式化输出，用法和C语言中`printf`函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。`printf`会根据控制串来编排表达式的格式。\n`printf`和`print`不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符`\\n`\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age[Name:Alice     ]        Age:25[Name:Bob       ] Age:30[Name:Charlie   ]      Age:22[Name:David     ] Age:35[Name:Eve       ] Age:28ubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\\n\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age\n[Name:Alice     ]       Age:25\n[Name:Bob       ]       Age:30\n[Name:Charlie   ]       Age:22\n[Name:David     ]       Age:35\n[Name:Eve       ]       Age:28\n```\n\n## 记录与字段\n\n### 记录\n\n在awk中每一行数据称为一条记录，以换行符结束。\n\n* 记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量`ORS`和`RS`中。\n* 变量`$0`表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NR,$0}' example.txt\n1 Name Age Gender City\n2 Alice 25 Female New York\n3 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n5 David 35 Male Houston\n6 Eve 28 Female Miami\n```\n\n### 字段\n\n每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。`NF`变量保存每个记录的字段数量。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NF,$0}' example.txt\n4 Name Age Gender City\n5 Alice 25 Female New York\n5 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n4 David 35 Male Houston\n4 Eve 28 Female Miami\n```\n\n### 字段分隔符\n\n字段分隔符由内部变量`FS`保存，可以在命令中通过`-F`选项修改`FS`的值。\n先使用`sed`命令将`example.txt`文件中的空格替换为逗号：\n\n```sh\nubuntu@6e455ed15da7:~$ sed -i 's/ /,/g' example.txt\nubuntu@6e455ed15da7:~$ cat example.txt\nName,Age,Gender,City\nAlice,25,Female,New,York\nBob,30,Male,Los,Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\nEve,28,Female,Miami\n```\n\n然后使用awk并通过`-F`选项替换分隔符进行输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name,Age,Gender,City Age:\nName:Alice,25,Female,New,York Age:\nName:Bob,30,Male,Los,Angeles Age:\nName:Charlie,22,Male,Chicago Age:\nName:David,35,Male,Houston Age:\nName:Eve,28,Female,Miami Age:\nubuntu@6e455ed15da7:~$ awk -F, '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n## 匹配模式与正则表达式\n\n### 匹配模式\n\nawk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。\n\n使用`Alice`进行数据匹配：\n\n```shell\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice 25 Female New York\n```\n\n使用条件表达式进行数据匹配：\n\n```shell\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '$2 < 25' example.txt\nCharlie 22 Male Chicago\n```\n\n### 正则表达式模式与操作\n\n使用正则表达式模式`Alice`进行数据匹配，然后通过`print`函数进行格式化输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\n```\n\n格式化输出`example.txt`文件中所有以大写字母`A-C`开头的行：\n\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/^[A-C]+.*/{print \"Name:\" $1}' example.txt\nName:Alice\nName:Bob\nName:Charlie\n```\n\n## 练习\n\n### 显示系统下各用户所使用的shell\n\n查看当前`/etc/passwd`格式：\n\n```sh\nubuntu@6e455ed15da7:~$ cat /etc/passwd|head\nroot:x:0:0:root:/root:/bin/bash\n```\n\n使用awk显示各用户使用的shell:\n\n```sh\nUser:root Shell:/bin/bash\nUser:daemon Shell:/usr/sbin/nologin\nUser:bin Shell:/usr/sbin/nologin\nUser:sys Shell:/usr/sbin/nologin\nUser:sync Shell:/bin/sync\nUser:games Shell:/usr/sbin/nologin\nUser:man Shell:/usr/sbin/nologin\nUser:lp Shell:/usr/sbin/nologin\nUser:mail Shell:/usr/sbin/nologin\nUser:news Shell:/usr/sbin/nologin\n```\n","source":"_posts/linux_shell/10.文本处理工具awk.md","raw":"---\ntitle: 文本处理工具awk \ndate: 2023-04-23 13:26:57\ntags:\n---\n\n## awk简介\n\nawk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。\nawk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。\n\n## awk版本\n\nawk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为`/bin/gawk`或`/usr/bin/gawk`提供，是GNU工具集中的一部分，可以在多个平台上使用。\n不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。\n\n## awk格式\n\nawk基本格式如下：\n\n```text\nawk 'pattern { action }' file\nawk '{ action }' file\nawk 'pattern' file\n```\n\n* `pattern`: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行\n* `action`: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 `;` 分隔\n* `file`: 是输入文件的名称，没有`file`参数时从标准输入读取数据\n\n在awk命令中，`pattern`和`action`之间通过大括号 `{}` 进行分隔，`pattern`用于匹配文本行，当匹配成功时，对应的`action`将被执行。\n\nawk还支持在处理数据前和处理数据后运行命令，完整格式如下：\n\n```text\nawk 'BEGIN {command} pattern { action } END {command}' file\n```\n\n```sh\necho \"10 20 30 40 50\" | awk 'BEGIN {sum = 0; print \"sum:\", sum} {sum += $1} END {print \"Sum:\", sum}'\n```\n\n![10.text-processing-tools-awk-2023-04-24-09-42-32](https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png)\n\n## 从标准输入读取数据\n\n### 从命令行读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Hello World\"}'\ntest\nHello World\nabc\nHello World\n```\n\n以上awk命令没有指定`file`参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用`Ctrl+D`产生一个EOF字符，此时会返回到命令行下。\n\n### 通过管道符号从命令读取数据\n\n```sh\nubuntu@6e455ed15da7:~$ ps -aux|awk '/bash/'\nroot           1  0.0  0.0  18228  3012 pts/0    Ss+  Apr22   0:00 /bin/bash\nroot          11  0.0  0.0  18232  3240 pts/1    Ss   13:36   0:00 /bin/bash\nubuntu       269  0.0  0.0  18228  3144 pts/1    S    13:39   0:00 bash\n```\n\n以上awk命令通过管道符号`|`从前面一个命令的输出结果从读取数据进行处理。\n\n## 从文件中读取数据和命令\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice,25,Female,New York\nubuntu@6e455ed15da7:~$ awk '/Male/' example.txt\nBob,30,Male,Los Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\n```\n\n以上awk命令指定了`file`参数，awk会从文件中以行为单位读取数据并且使用`pattern`所表示的匹配模式进行数据匹配，由于没有指定`action`参数，awk将匹配到的数据直接输出到标准输出。\n\nawk和sed一样可以从文件中读取命令：\n\n```sh\nawk -f script_file.awk example.txt\n```\n\n## awk工作原理\n\n1. awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0\n2. 这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。\n\n以以下数据为例：\n\n```text\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\n```\n\n以下awk命令的运行结果：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print $1,$3}' example.txt\nName Gender\nAlice Female\nBob Male\nCharlie Male\nDavid Male\nEve Female\n```\n\n1. awk首先将第一行数据存放在变量$0中进行处理。\n2. 将`$0`中的数据以空格为分隔符（内部变量`FS`所定义）进行分解，分别存放在从`$1`开始的内部变量中。\n3. 在输出结果的每一行中第一个字段是存放在`$1`中的数据，第二个字段是存放在`$3`中的数据。\n4. awk命令中的逗号映射为一个内部变量-输出字段分隔符`OFS`（默认为空格）两个字段之间由空格间隔。\n5. 处理完一行数据后读取下一行数据到`$0`中进行处理直到所以数据处理完毕。\n\n## 格式化输出\n\n### print函数\n\nprint函数用于打印不需要特别编排格式的简单输出。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"Age:\" $2}' example.txt\nName:NameAge:Age\nName:AliceAge:25\nName:BobAge:30\nName:CharlieAge:22\nName:DavidAge:35\nName:EveAge:28\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n逗号`,`表示内部变量`OFS`（用来表示输出字段的分隔符，默认为空格）。\nprint还支持以下转义序列：\n\n```text\n\\b：退格符（ASCII 008）\n\\t：制表符（ASCII 009）\n\\n：换行符（ASCII 010）\n\\f：换页符（ASCII 012）\n\\r：回车符（ASCII 013）\n```\n\nprint中使用转义序列进行数据输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1 \"\\tAge:\" $2}' example.txt\nName:Name       Age:Age\nName:Alice      Age:25\nName:Bob        Age:30\nName:Charlie    Age:22\nName:David      Age:35\nName:Eve        Age:28\n```\n\n### printf函数\n\n`printf`函数能够进行更加精细的格式化输出，用法和C语言中`printf`函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。`printf`会根据控制串来编排表达式的格式。\n`printf`和`print`不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符`\\n`\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age[Name:Alice     ]        Age:25[Name:Bob       ] Age:30[Name:Charlie   ]      Age:22[Name:David     ] Age:35[Name:Eve       ] Age:28ubuntu@6e455ed15da7:~$ awk '{printf \"[Name:%-10s]\\tAge:%s\\n\", $1, $2}' example.txt\n[Name:Name      ]       Age:Age\n[Name:Alice     ]       Age:25\n[Name:Bob       ]       Age:30\n[Name:Charlie   ]       Age:22\n[Name:David     ]       Age:35\n[Name:Eve       ]       Age:28\n```\n\n## 记录与字段\n\n### 记录\n\n在awk中每一行数据称为一条记录，以换行符结束。\n\n* 记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量`ORS`和`RS`中。\n* 变量`$0`表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NR,$0}' example.txt\n1 Name Age Gender City\n2 Alice 25 Female New York\n3 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n5 David 35 Male Houston\n6 Eve 28 Female Miami\n```\n\n### 字段\n\n每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。`NF`变量保存每个记录的字段数量。\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print NF,$0}' example.txt\n4 Name Age Gender City\n5 Alice 25 Female New York\n5 Bob 30 Male Los Angeles\n4 Charlie 22 Male Chicago\n4 David 35 Male Houston\n4 Eve 28 Female Miami\n```\n\n### 字段分隔符\n\n字段分隔符由内部变量`FS`保存，可以在命令中通过`-F`选项修改`FS`的值。\n先使用`sed`命令将`example.txt`文件中的空格替换为逗号：\n\n```sh\nubuntu@6e455ed15da7:~$ sed -i 's/ /,/g' example.txt\nubuntu@6e455ed15da7:~$ cat example.txt\nName,Age,Gender,City\nAlice,25,Female,New,York\nBob,30,Male,Los,Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\nEve,28,Female,Miami\n```\n\n然后使用awk并通过`-F`选项替换分隔符进行输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name,Age,Gender,City Age:\nName:Alice,25,Female,New,York Age:\nName:Bob,30,Male,Los,Angeles Age:\nName:Charlie,22,Male,Chicago Age:\nName:David,35,Male,Houston Age:\nName:Eve,28,Female,Miami Age:\nubuntu@6e455ed15da7:~$ awk -F, '{print \"Name:\" $1, \"Age:\" $2}' example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28\n```\n\n## 匹配模式与正则表达式\n\n### 匹配模式\n\nawk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。\n\n使用`Alice`进行数据匹配：\n\n```shell\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/' example.txt\nAlice 25 Female New York\n```\n\n使用条件表达式进行数据匹配：\n\n```shell\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '$2 < 25' example.txt\nCharlie 22 Male Chicago\n```\n\n### 正则表达式模式与操作\n\n使用正则表达式模式`Alice`进行数据匹配，然后通过`print`函数进行格式化输出：\n\n```sh\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/Alice/{print \"Name:\" $1}' example.txt\nName:Alice\n```\n\n格式化输出`example.txt`文件中所有以大写字母`A-C`开头的行：\n\n```sh\nubuntu@6e455ed15da7:~$ cat example.txt\nName Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami\nubuntu@6e455ed15da7:~$ awk '/^[A-C]+.*/{print \"Name:\" $1}' example.txt\nName:Alice\nName:Bob\nName:Charlie\n```\n\n## 练习\n\n### 显示系统下各用户所使用的shell\n\n查看当前`/etc/passwd`格式：\n\n```sh\nubuntu@6e455ed15da7:~$ cat /etc/passwd|head\nroot:x:0:0:root:/root:/bin/bash\n```\n\n使用awk显示各用户使用的shell:\n\n```sh\nUser:root Shell:/bin/bash\nUser:daemon Shell:/usr/sbin/nologin\nUser:bin Shell:/usr/sbin/nologin\nUser:sys Shell:/usr/sbin/nologin\nUser:sync Shell:/bin/sync\nUser:games Shell:/usr/sbin/nologin\nUser:man Shell:/usr/sbin/nologin\nUser:lp Shell:/usr/sbin/nologin\nUser:mail Shell:/usr/sbin/nologin\nUser:news Shell:/usr/sbin/nologin\n```\n","slug":"linux_shell/10.文本处理工具awk","published":1,"updated":"2023-06-16T13:29:48.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04g00061dnzakln7931","content":"<h2 id=\"awk简介\"><a href=\"#awk简介\" class=\"headerlink\" title=\"awk简介\"></a>awk简介</h2><p>awk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。<br>awk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。</p>\n<h2 id=\"awk版本\"><a href=\"#awk版本\" class=\"headerlink\" title=\"awk版本\"></a>awk版本</h2><p>awk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为<code>/bin/gawk</code>或<code>/usr/bin/gawk</code>提供，是GNU工具集中的一部分，可以在多个平台上使用。<br>不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。</p>\n<h2 id=\"awk格式\"><a href=\"#awk格式\" class=\"headerlink\" title=\"awk格式\"></a>awk格式</h2><p>awk基本格式如下：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">awk 'pattern &#123; action &#125;' file\nawk '&#123; action &#125;' file\nawk 'pattern' file<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><code>pattern</code>: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行</li>\n<li><code>action</code>: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 <code>;</code> 分隔</li>\n<li><code>file</code>: 是输入文件的名称，没有<code>file</code>参数时从标准输入读取数据</li>\n</ul>\n<p>在awk命令中，<code>pattern</code>和<code>action</code>之间通过大括号 <code>&#123;&#125;</code> 进行分隔，<code>pattern</code>用于匹配文本行，当匹配成功时，对应的<code>action</code>将被执行。</p>\n<p>awk还支持在处理数据前和处理数据后运行命令，完整格式如下：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">awk 'BEGIN &#123;command&#125; pattern &#123; action &#125; END &#123;command&#125;' file<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"10 20 30 40 50\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">awk</span> <span class=\"token string\">'BEGIN &#123;sum = 0; print \"sum:\", sum&#125; &#123;sum += $1&#125; END &#123;print \"Sum:\", sum&#125;'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png\" alt=\"10.text-processing-tools-awk-2023-04-24-09-42-32\"></p>\n<h2 id=\"从标准输入读取数据\"><a href=\"#从标准输入读取数据\" class=\"headerlink\" title=\"从标准输入读取数据\"></a>从标准输入读取数据</h2><h3 id=\"从命令行读取数据\"><a href=\"#从命令行读取数据\" class=\"headerlink\" title=\"从命令行读取数据\"></a>从命令行读取数据</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Hello World\"&#125;'</span>\n<span class=\"token builtin class-name\">test</span>\nHello World\nabc\nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上awk命令没有指定<code>file</code>参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用<code>Ctrl+D</code>产生一个EOF字符，此时会返回到命令行下。</p>\n<h3 id=\"通过管道符号从命令读取数据\"><a href=\"#通过管道符号从命令读取数据\" class=\"headerlink\" title=\"通过管道符号从命令读取数据\"></a>通过管道符号从命令读取数据</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">ps</span> -aux<span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'/bash/'</span>\nroot           <span class=\"token number\">1</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">18228</span>  <span class=\"token number\">3012</span> pts/0    Ss+  Apr22   <span class=\"token number\">0</span>:00 /bin/bash\nroot          <span class=\"token number\">11</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">18232</span>  <span class=\"token number\">3240</span> pts/1    Ss   <span class=\"token number\">13</span>:36   <span class=\"token number\">0</span>:00 /bin/bash\nubuntu       <span class=\"token number\">269</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">18228</span>  <span class=\"token number\">3144</span> pts/1    S    <span class=\"token number\">13</span>:39   <span class=\"token number\">0</span>:00 <span class=\"token function\">bash</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上awk命令通过管道符号<code>|</code>从前面一个命令的输出结果从读取数据进行处理。</p>\n<h2 id=\"从文件中读取数据和命令\"><a href=\"#从文件中读取数据和命令\" class=\"headerlink\" title=\"从文件中读取数据和命令\"></a>从文件中读取数据和命令</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/'</span> example.txt\nAlice,25,Female,New York\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Male/'</span> example.txt\nBob,30,Male,Los Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上awk命令指定了<code>file</code>参数，awk会从文件中以行为单位读取数据并且使用<code>pattern</code>所表示的匹配模式进行数据匹配，由于没有指定<code>action</code>参数，awk将匹配到的数据直接输出到标准输出。</p>\n<p>awk和sed一样可以从文件中读取命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">awk</span> <span class=\"token parameter variable\">-f</span> script_file.awk example.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"awk工作原理\"><a href=\"#awk工作原理\" class=\"headerlink\" title=\"awk工作原理\"></a>awk工作原理</h2><ol>\n<li>awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0</li>\n<li>这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。</li>\n</ol>\n<p>以以下数据为例：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Name Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下awk命令的运行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print $1,$3&#125;'</span> example.txt\nName Gender\nAlice Female\nBob Male\nCharlie Male\nDavid Male\nEve Female<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>awk首先将第一行数据存放在变量$0中进行处理。</li>\n<li>将<code>$0</code>中的数据以空格为分隔符（内部变量<code>FS</code>所定义）进行分解，分别存放在从<code>$1</code>开始的内部变量中。</li>\n<li>在输出结果的每一行中第一个字段是存放在<code>$1</code>中的数据，第二个字段是存放在<code>$3</code>中的数据。</li>\n<li>awk命令中的逗号映射为一个内部变量-输出字段分隔符<code>OFS</code>（默认为空格）两个字段之间由空格间隔。</li>\n<li>处理完一行数据后读取下一行数据到<code>$0</code>中进行处理直到所以数据处理完毕。</li>\n</ol>\n<h2 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h2><h3 id=\"print函数\"><a href=\"#print函数\" class=\"headerlink\" title=\"print函数\"></a>print函数</h3><p>print函数用于打印不需要特别编排格式的简单输出。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1 \"Age:\" $2&#125;'</span> example.txt\nName:NameAge:Age\nName:AliceAge:25\nName:BobAge:30\nName:CharlieAge:22\nName:DavidAge:35\nName:EveAge:28\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1, \"Age:\" $2&#125;'</span> example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>逗号<code>,</code>表示内部变量<code>OFS</code>（用来表示输出字段的分隔符，默认为空格）。<br>print还支持以下转义序列：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">\\b：退格符（ASCII 008）\n\\t：制表符（ASCII 009）\n\\n：换行符（ASCII 010）\n\\f：换页符（ASCII 012）\n\\r：回车符（ASCII 013）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>print中使用转义序列进行数据输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1 \"\\tAge:\" $2&#125;'</span> example.txt\nName:Name       Age:Age\nName:Alice      Age:25\nName:Bob        Age:30\nName:Charlie    Age:22\nName:David      Age:35\nName:Eve        Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"printf函数\"><a href=\"#printf函数\" class=\"headerlink\" title=\"printf函数\"></a>printf函数</h3><p><code>printf</code>函数能够进行更加精细的格式化输出，用法和C语言中<code>printf</code>函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。<code>printf</code>会根据控制串来编排表达式的格式。<br><code>printf</code>和<code>print</code>不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符<code>\\n</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;printf \"[Name:%-10s]\\tAge:%s\", $1, $2&#125;'</span> example.txt\n<span class=\"token punctuation\">[</span>Name:Name      <span class=\"token punctuation\">]</span>       Age:Age<span class=\"token punctuation\">[</span>Name:Alice     <span class=\"token punctuation\">]</span>        Age:25<span class=\"token punctuation\">[</span>Name:Bob       <span class=\"token punctuation\">]</span> Age:30<span class=\"token punctuation\">[</span>Name:Charlie   <span class=\"token punctuation\">]</span>      Age:22<span class=\"token punctuation\">[</span>Name:David     <span class=\"token punctuation\">]</span> Age:35<span class=\"token punctuation\">[</span>Name:Eve       <span class=\"token punctuation\">]</span> Age:28ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;printf \"[Name:%-10s]\\tAge:%s\\n\", $1, $2&#125;'</span> example.txt\n<span class=\"token punctuation\">[</span>Name:Name      <span class=\"token punctuation\">]</span>       Age:Age\n<span class=\"token punctuation\">[</span>Name:Alice     <span class=\"token punctuation\">]</span>       Age:25\n<span class=\"token punctuation\">[</span>Name:Bob       <span class=\"token punctuation\">]</span>       Age:30\n<span class=\"token punctuation\">[</span>Name:Charlie   <span class=\"token punctuation\">]</span>       Age:22\n<span class=\"token punctuation\">[</span>Name:David     <span class=\"token punctuation\">]</span>       Age:35\n<span class=\"token punctuation\">[</span>Name:Eve       <span class=\"token punctuation\">]</span>       Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"记录与字段\"><a href=\"#记录与字段\" class=\"headerlink\" title=\"记录与字段\"></a>记录与字段</h2><h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><p>在awk中每一行数据称为一条记录，以换行符结束。</p>\n<ul>\n<li>记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量<code>ORS</code>和<code>RS</code>中。</li>\n<li>变量<code>$0</code>表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print NR,$0&#125;'</span> example.txt\n<span class=\"token number\">1</span> Name Age Gender City\n<span class=\"token number\">2</span> Alice <span class=\"token number\">25</span> Female New York\n<span class=\"token number\">3</span> Bob <span class=\"token number\">30</span> Male Los Angeles\n<span class=\"token number\">4</span> Charlie <span class=\"token number\">22</span> Male Chicago\n<span class=\"token number\">5</span> David <span class=\"token number\">35</span> Male Houston\n<span class=\"token number\">6</span> Eve <span class=\"token number\">28</span> Female Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h3><p>每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。<code>NF</code>变量保存每个记录的字段数量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print NF,$0&#125;'</span> example.txt\n<span class=\"token number\">4</span> Name Age Gender City\n<span class=\"token number\">5</span> Alice <span class=\"token number\">25</span> Female New York\n<span class=\"token number\">5</span> Bob <span class=\"token number\">30</span> Male Los Angeles\n<span class=\"token number\">4</span> Charlie <span class=\"token number\">22</span> Male Chicago\n<span class=\"token number\">4</span> David <span class=\"token number\">35</span> Male Houston\n<span class=\"token number\">4</span> Eve <span class=\"token number\">28</span> Female Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"字段分隔符\"><a href=\"#字段分隔符\" class=\"headerlink\" title=\"字段分隔符\"></a>字段分隔符</h3><p>字段分隔符由内部变量<code>FS</code>保存，可以在命令中通过<code>-F</code>选项修改<code>FS</code>的值。<br>先使用<code>sed</code>命令将<code>example.txt</code>文件中的空格替换为逗号：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">sed</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">'s/ /,/g'</span> example.txt\nubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName,Age,Gender,City\nAlice,25,Female,New,York\nBob,30,Male,Los,Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\nEve,28,Female,Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后使用awk并通过<code>-F</code>选项替换分隔符进行输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1, \"Age:\" $2&#125;'</span> example.txt\nName:Name,Age,Gender,City Age:\nName:Alice,25,Female,New,York Age:\nName:Bob,30,Male,Los,Angeles Age:\nName:Charlie,22,Male,Chicago Age:\nName:David,35,Male,Houston Age:\nName:Eve,28,Female,Miami Age:\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> -F, <span class=\"token string\">'&#123;print \"Name:\" $1, \"Age:\" $2&#125;'</span> example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"匹配模式与正则表达式\"><a href=\"#匹配模式与正则表达式\" class=\"headerlink\" title=\"匹配模式与正则表达式\"></a>匹配模式与正则表达式</h2><h3 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h3><p>awk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。</p>\n<p>使用<code>Alice</code>进行数据匹配：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/'</span> example.txt\nAlice <span class=\"token number\">25</span> Female New York<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用条件表达式进行数据匹配：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'$2 &lt; 25'</span> example.txt\nCharlie <span class=\"token number\">22</span> Male Chicago<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"正则表达式模式与操作\"><a href=\"#正则表达式模式与操作\" class=\"headerlink\" title=\"正则表达式模式与操作\"></a>正则表达式模式与操作</h3><p>使用正则表达式模式<code>Alice</code>进行数据匹配，然后通过<code>print</code>函数进行格式化输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/&#123;print \"Name:\" $1&#125;'</span> example.txt\nName:Alice\nubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/&#123;print \"Name:\" $1&#125;'</span> example.txt\nName:Alice<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>格式化输出<code>example.txt</code>文件中所有以大写字母<code>A-C</code>开头的行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/^[A-C]+.*/&#123;print \"Name:\" $1&#125;'</span> example.txt\nName:Alice\nName:Bob\nName:Charlie<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"显示系统下各用户所使用的shell\"><a href=\"#显示系统下各用户所使用的shell\" class=\"headerlink\" title=\"显示系统下各用户所使用的shell\"></a>显示系统下各用户所使用的shell</h3><p>查看当前<code>/etc/passwd</code>格式：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> /etc/passwd<span class=\"token operator\">|</span><span class=\"token function\">head</span>\nroot:x:0:0:root:/root:/bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用awk显示各用户使用的shell:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">User:root Shell:/bin/bash\nUser:daemon Shell:/usr/sbin/nologin\nUser:bin Shell:/usr/sbin/nologin\nUser:sys Shell:/usr/sbin/nologin\nUser:sync Shell:/bin/sync\nUser:games Shell:/usr/sbin/nologin\nUser:man Shell:/usr/sbin/nologin\nUser:lp Shell:/usr/sbin/nologin\nUser:mail Shell:/usr/sbin/nologin\nUser:news Shell:/usr/sbin/nologin<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"awk简介\"><a href=\"#awk简介\" class=\"headerlink\" title=\"awk简介\"></a>awk简介</h2><p>awk是一种用于处理文本数据的工具，可以从文本文件或者标准输入、一个或多个文件中提取和处理数据。<br>awk以逐行扫描方式处理数据，从第一行到最后一行以查找匹配某个特定模式的文本行，并且对这些文本行执行指定动作。</p>\n<h2 id=\"awk版本\"><a href=\"#awk版本\" class=\"headerlink\" title=\"awk版本\"></a>awk版本</h2><p>awk有众多版本包括传统awk、新版awk、gawk等，其中gawk是GNU组织开发的版本，也是目前最流行和最广泛使用的awk版本。gawk在传统awk和nawk的基础上添加了许多新功能和改进，例如更丰富的正则表达式支持、高级的数学和字符串处理函数、用户自定义函数等。gawk通常作为<code>/bin/gawk</code>或<code>/usr/bin/gawk</code>提供，是GNU工具集中的一部分，可以在多个平台上使用。<br>不同的awk可能在语法、功能和性能方面略有不同，在使用awk时应注意选择合适的版本，根据具体需求和系统环境来决定使用哪个版本。</p>\n<h2 id=\"awk格式\"><a href=\"#awk格式\" class=\"headerlink\" title=\"awk格式\"></a>awk格式</h2><p>awk基本格式如下：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">awk 'pattern &#123; action &#125;' file\nawk '&#123; action &#125;' file\nawk 'pattern' file<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><code>pattern</code>: 可以是一个正则表达式，也可以是一个字符串或数字，用于匹配文本中的某个字段或整行</li>\n<li><code>action</code>: 是在匹配到的文本上执行的操作，可以是一个或多个命令，多个命令之间用换行或分号 <code>;</code> 分隔</li>\n<li><code>file</code>: 是输入文件的名称，没有<code>file</code>参数时从标准输入读取数据</li>\n</ul>\n<p>在awk命令中，<code>pattern</code>和<code>action</code>之间通过大括号 <code>&#123;&#125;</code> 进行分隔，<code>pattern</code>用于匹配文本行，当匹配成功时，对应的<code>action</code>将被执行。</p>\n<p>awk还支持在处理数据前和处理数据后运行命令，完整格式如下：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">awk 'BEGIN &#123;command&#125; pattern &#123; action &#125; END &#123;command&#125;' file<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"10 20 30 40 50\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">awk</span> <span class=\"token string\">'BEGIN &#123;sum = 0; print \"sum:\", sum&#125; &#123;sum += $1&#125; END &#123;print \"Sum:\", sum&#125;'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note10.text-processing-tools-awk-2023-04-24-09-42-32.png\" alt=\"10.text-processing-tools-awk-2023-04-24-09-42-32\"></p>\n<h2 id=\"从标准输入读取数据\"><a href=\"#从标准输入读取数据\" class=\"headerlink\" title=\"从标准输入读取数据\"></a>从标准输入读取数据</h2><h3 id=\"从命令行读取数据\"><a href=\"#从命令行读取数据\" class=\"headerlink\" title=\"从命令行读取数据\"></a>从命令行读取数据</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Hello World\"&#125;'</span>\n<span class=\"token builtin class-name\">test</span>\nHello World\nabc\nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上awk命令没有指定<code>file</code>参数，awk不会直接给出运行结果，它会等待标准输入的数据，当用户输入字符后awk会执行相应的命令并产生输出。如果要终止awk程序需要使用<code>Ctrl+D</code>产生一个EOF字符，此时会返回到命令行下。</p>\n<h3 id=\"通过管道符号从命令读取数据\"><a href=\"#通过管道符号从命令读取数据\" class=\"headerlink\" title=\"通过管道符号从命令读取数据\"></a>通过管道符号从命令读取数据</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">ps</span> -aux<span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'/bash/'</span>\nroot           <span class=\"token number\">1</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">18228</span>  <span class=\"token number\">3012</span> pts/0    Ss+  Apr22   <span class=\"token number\">0</span>:00 /bin/bash\nroot          <span class=\"token number\">11</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">18232</span>  <span class=\"token number\">3240</span> pts/1    Ss   <span class=\"token number\">13</span>:36   <span class=\"token number\">0</span>:00 /bin/bash\nubuntu       <span class=\"token number\">269</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">18228</span>  <span class=\"token number\">3144</span> pts/1    S    <span class=\"token number\">13</span>:39   <span class=\"token number\">0</span>:00 <span class=\"token function\">bash</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上awk命令通过管道符号<code>|</code>从前面一个命令的输出结果从读取数据进行处理。</p>\n<h2 id=\"从文件中读取数据和命令\"><a href=\"#从文件中读取数据和命令\" class=\"headerlink\" title=\"从文件中读取数据和命令\"></a>从文件中读取数据和命令</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/'</span> example.txt\nAlice,25,Female,New York\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Male/'</span> example.txt\nBob,30,Male,Los Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上awk命令指定了<code>file</code>参数，awk会从文件中以行为单位读取数据并且使用<code>pattern</code>所表示的匹配模式进行数据匹配，由于没有指定<code>action</code>参数，awk将匹配到的数据直接输出到标准输出。</p>\n<p>awk和sed一样可以从文件中读取命令：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">awk</span> <span class=\"token parameter variable\">-f</span> script_file.awk example.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"awk工作原理\"><a href=\"#awk工作原理\" class=\"headerlink\" title=\"awk工作原理\"></a>awk工作原理</h2><ol>\n<li>awk对文件或者标准输入的内容一次只处理一行，将获取到的这一行数据赋给变量$0</li>\n<li>这一行的内容按awk内部变量FS定义的分隔符（缺省为空格，包括制表符tab）分解成多个字段，每一个字段存储在从$1开始的变量中。</li>\n</ol>\n<p>以以下数据为例：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Name Age Gender City\nAlice 25 Female New York\nBob 30 Male Los Angeles\nCharlie 22 Male Chicago\nDavid 35 Male Houston\nEve 28 Female Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下awk命令的运行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print $1,$3&#125;'</span> example.txt\nName Gender\nAlice Female\nBob Male\nCharlie Male\nDavid Male\nEve Female<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>awk首先将第一行数据存放在变量$0中进行处理。</li>\n<li>将<code>$0</code>中的数据以空格为分隔符（内部变量<code>FS</code>所定义）进行分解，分别存放在从<code>$1</code>开始的内部变量中。</li>\n<li>在输出结果的每一行中第一个字段是存放在<code>$1</code>中的数据，第二个字段是存放在<code>$3</code>中的数据。</li>\n<li>awk命令中的逗号映射为一个内部变量-输出字段分隔符<code>OFS</code>（默认为空格）两个字段之间由空格间隔。</li>\n<li>处理完一行数据后读取下一行数据到<code>$0</code>中进行处理直到所以数据处理完毕。</li>\n</ol>\n<h2 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h2><h3 id=\"print函数\"><a href=\"#print函数\" class=\"headerlink\" title=\"print函数\"></a>print函数</h3><p>print函数用于打印不需要特别编排格式的简单输出。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1 \"Age:\" $2&#125;'</span> example.txt\nName:NameAge:Age\nName:AliceAge:25\nName:BobAge:30\nName:CharlieAge:22\nName:DavidAge:35\nName:EveAge:28\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1, \"Age:\" $2&#125;'</span> example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>逗号<code>,</code>表示内部变量<code>OFS</code>（用来表示输出字段的分隔符，默认为空格）。<br>print还支持以下转义序列：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">\\b：退格符（ASCII 008）\n\\t：制表符（ASCII 009）\n\\n：换行符（ASCII 010）\n\\f：换页符（ASCII 012）\n\\r：回车符（ASCII 013）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>print中使用转义序列进行数据输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1 \"\\tAge:\" $2&#125;'</span> example.txt\nName:Name       Age:Age\nName:Alice      Age:25\nName:Bob        Age:30\nName:Charlie    Age:22\nName:David      Age:35\nName:Eve        Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"printf函数\"><a href=\"#printf函数\" class=\"headerlink\" title=\"printf函数\"></a>printf函数</h3><p><code>printf</code>函数能够进行更加精细的格式化输出，用法和C语言中<code>printf</code>函数的用法一样。语句中包含一个加引号的控制串，控制串中包含若干格式说明和修饰符。控制串后面跟一个逗号，之后是一列由逗号分隔的表达式。<code>printf</code>会根据控制串来编排表达式的格式。<br><code>printf</code>和<code>print</code>不同的是printf在行尾不会自动换行，如果要换行必须使用转义字符<code>\\n</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;printf \"[Name:%-10s]\\tAge:%s\", $1, $2&#125;'</span> example.txt\n<span class=\"token punctuation\">[</span>Name:Name      <span class=\"token punctuation\">]</span>       Age:Age<span class=\"token punctuation\">[</span>Name:Alice     <span class=\"token punctuation\">]</span>        Age:25<span class=\"token punctuation\">[</span>Name:Bob       <span class=\"token punctuation\">]</span> Age:30<span class=\"token punctuation\">[</span>Name:Charlie   <span class=\"token punctuation\">]</span>      Age:22<span class=\"token punctuation\">[</span>Name:David     <span class=\"token punctuation\">]</span> Age:35<span class=\"token punctuation\">[</span>Name:Eve       <span class=\"token punctuation\">]</span> Age:28ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;printf \"[Name:%-10s]\\tAge:%s\\n\", $1, $2&#125;'</span> example.txt\n<span class=\"token punctuation\">[</span>Name:Name      <span class=\"token punctuation\">]</span>       Age:Age\n<span class=\"token punctuation\">[</span>Name:Alice     <span class=\"token punctuation\">]</span>       Age:25\n<span class=\"token punctuation\">[</span>Name:Bob       <span class=\"token punctuation\">]</span>       Age:30\n<span class=\"token punctuation\">[</span>Name:Charlie   <span class=\"token punctuation\">]</span>       Age:22\n<span class=\"token punctuation\">[</span>Name:David     <span class=\"token punctuation\">]</span>       Age:35\n<span class=\"token punctuation\">[</span>Name:Eve       <span class=\"token punctuation\">]</span>       Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"记录与字段\"><a href=\"#记录与字段\" class=\"headerlink\" title=\"记录与字段\"></a>记录与字段</h2><h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><p>在awk中每一行数据称为一条记录，以换行符结束。</p>\n<ul>\n<li>记录分隔符：默认情况下，输入和输出记录的分隔符都是回车符，分别保存在内部变量<code>ORS</code>和<code>RS</code>中。</li>\n<li>变量<code>$0</code>表示当前整条记录，变量NR表示当前记录的记录号，每处理一条记录，NR值加一。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print NR,$0&#125;'</span> example.txt\n<span class=\"token number\">1</span> Name Age Gender City\n<span class=\"token number\">2</span> Alice <span class=\"token number\">25</span> Female New York\n<span class=\"token number\">3</span> Bob <span class=\"token number\">30</span> Male Los Angeles\n<span class=\"token number\">4</span> Charlie <span class=\"token number\">22</span> Male Chicago\n<span class=\"token number\">5</span> David <span class=\"token number\">35</span> Male Houston\n<span class=\"token number\">6</span> Eve <span class=\"token number\">28</span> Female Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"字段\"><a href=\"#字段\" class=\"headerlink\" title=\"字段\"></a>字段</h3><p>每一条记录都是由称为字段的词组成，默认情况下字段之间用空白符（空格或者制表符）分隔。<code>NF</code>变量保存每个记录的字段数量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print NF,$0&#125;'</span> example.txt\n<span class=\"token number\">4</span> Name Age Gender City\n<span class=\"token number\">5</span> Alice <span class=\"token number\">25</span> Female New York\n<span class=\"token number\">5</span> Bob <span class=\"token number\">30</span> Male Los Angeles\n<span class=\"token number\">4</span> Charlie <span class=\"token number\">22</span> Male Chicago\n<span class=\"token number\">4</span> David <span class=\"token number\">35</span> Male Houston\n<span class=\"token number\">4</span> Eve <span class=\"token number\">28</span> Female Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"字段分隔符\"><a href=\"#字段分隔符\" class=\"headerlink\" title=\"字段分隔符\"></a>字段分隔符</h3><p>字段分隔符由内部变量<code>FS</code>保存，可以在命令中通过<code>-F</code>选项修改<code>FS</code>的值。<br>先使用<code>sed</code>命令将<code>example.txt</code>文件中的空格替换为逗号：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">sed</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">'s/ /,/g'</span> example.txt\nubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName,Age,Gender,City\nAlice,25,Female,New,York\nBob,30,Male,Los,Angeles\nCharlie,22,Male,Chicago\nDavid,35,Male,Houston\nEve,28,Female,Miami<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后使用awk并通过<code>-F</code>选项替换分隔符进行输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'&#123;print \"Name:\" $1, \"Age:\" $2&#125;'</span> example.txt\nName:Name,Age,Gender,City Age:\nName:Alice,25,Female,New,York Age:\nName:Bob,30,Male,Los,Angeles Age:\nName:Charlie,22,Male,Chicago Age:\nName:David,35,Male,Houston Age:\nName:Eve,28,Female,Miami Age:\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> -F, <span class=\"token string\">'&#123;print \"Name:\" $1, \"Age:\" $2&#125;'</span> example.txt\nName:Name Age:Age\nName:Alice Age:25\nName:Bob Age:30\nName:Charlie Age:22\nName:David Age:35\nName:Eve Age:28<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"匹配模式与正则表达式\"><a href=\"#匹配模式与正则表达式\" class=\"headerlink\" title=\"匹配模式与正则表达式\"></a>匹配模式与正则表达式</h2><h3 id=\"匹配模式\"><a href=\"#匹配模式\" class=\"headerlink\" title=\"匹配模式\"></a>匹配模式</h3><p>awk中的模式可以是一个正则表达式或者用来判定条件真伪的表达式。</p>\n<p>使用<code>Alice</code>进行数据匹配：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/'</span> example.txt\nAlice <span class=\"token number\">25</span> Female New York<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用条件表达式进行数据匹配：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'$2 &lt; 25'</span> example.txt\nCharlie <span class=\"token number\">22</span> Male Chicago<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"正则表达式模式与操作\"><a href=\"#正则表达式模式与操作\" class=\"headerlink\" title=\"正则表达式模式与操作\"></a>正则表达式模式与操作</h3><p>使用正则表达式模式<code>Alice</code>进行数据匹配，然后通过<code>print</code>函数进行格式化输出：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/&#123;print \"Name:\" $1&#125;'</span> example.txt\nName:Alice\nubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/Alice/&#123;print \"Name:\" $1&#125;'</span> example.txt\nName:Alice<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>格式化输出<code>example.txt</code>文件中所有以大写字母<code>A-C</code>开头的行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> example.txt\nName Age Gender City\nAlice <span class=\"token number\">25</span> Female New York\nBob <span class=\"token number\">30</span> Male Los Angeles\nCharlie <span class=\"token number\">22</span> Male Chicago\nDavid <span class=\"token number\">35</span> Male Houston\nEve <span class=\"token number\">28</span> Female Miami\nubuntu@6e455ed15da7:~$ <span class=\"token function\">awk</span> <span class=\"token string\">'/^[A-C]+.*/&#123;print \"Name:\" $1&#125;'</span> example.txt\nName:Alice\nName:Bob\nName:Charlie<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"显示系统下各用户所使用的shell\"><a href=\"#显示系统下各用户所使用的shell\" class=\"headerlink\" title=\"显示系统下各用户所使用的shell\"></a>显示系统下各用户所使用的shell</h3><p>查看当前<code>/etc/passwd</code>格式：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@6e455ed15da7:~$ <span class=\"token function\">cat</span> /etc/passwd<span class=\"token operator\">|</span><span class=\"token function\">head</span>\nroot:x:0:0:root:/root:/bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用awk显示各用户使用的shell:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">User:root Shell:/bin/bash\nUser:daemon Shell:/usr/sbin/nologin\nUser:bin Shell:/usr/sbin/nologin\nUser:sys Shell:/usr/sbin/nologin\nUser:sync Shell:/bin/sync\nUser:games Shell:/usr/sbin/nologin\nUser:man Shell:/usr/sbin/nologin\nUser:lp Shell:/usr/sbin/nologin\nUser:mail Shell:/usr/sbin/nologin\nUser:news Shell:/usr/sbin/nologin<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"title":"系统资源性能瓶颈脚本构建","date":"2023-06-16T13:35:08.000Z","_content":"\n## 常见的系统性能分析工具\n\n- 为什么利用Shell脚本进行系统资源性能分析\n    1. 在系统性能分析中，我们需要收集大量的数据并进行分析，而手动操作比较繁琐且容易出错，而且不易重复。使用shell脚本可以自动化执行这些操作，提高效率和准确性。\n    2. 由于shell脚本的灵活性和可编程性，可以根据不同需求和环境对脚本进行维护和扩展，实现各种不同的性能分析操作，可以大大提高工作效率和准确性。\n\n### vmstat\n\nvmstat是一个用于Linux系统的性能分析工具，它能够实时地监测CPU、内存、I/O、交换分区等系统性能数据，并将这些数据以一定的时间间隔（默认为2秒）输出到终端或日志文件中，提供给用户进行分析和优化。\n\n- vmstat输出信息含义：\n\n    ```text\n    r：等待运行的进程数目，即运行队列长度；\n    b：处于不可中断状态（blocked）的进程数目；\n    swpd：使用虚拟内存的大小，单位为KB；\n    free：空闲物理内存的大小，单位为KB；\n    buff：用作缓存的内存大小，单位为KB；\n    cache：用作缓存的页缓存的大小，单位为KB；\n    si：从磁盘交换入的内存大小，单位为KB/s；\n    so：向磁盘交换出的内存大小，单位为KB/s；\n    bi：从块设备读取的块数，单位为块/s；\n    bo：向块设备写入的块数，单位为块/s；\n    in：每秒中断数，包括时钟中断；\n    cs：每秒上下文切换次数；\n    us：用户进程占用CPU时间百分比；\n    sy：系统内核占用CPU时间百分比；\n    id：CPU空闲时间百分比；\n    wa：等待I/O完成时间百分比;\n    st：虚拟机占用CPU时间百分比；\n    ```\n\n- 查看系统的整体性能信息： `vmstat`\n- 每隔一段时间查看系统的整体性能信息： `vmstat 5 1`\n- 输出带有时间戳的系统整体性能信息： `vmstat -t`\n- 显示磁盘信息： `vmstat -d`\n- 显示指定的硬盘分区状态： `vmstat -p disk part`\n- 修改输出信息的单位： `vmstat -S M`\n\n### iostat\n\niostat是一个常用的性能分析工具，它可以监测CPU、磁盘、网络等系统资源的使用情况。\n\n- 输出信息含义：\n\n    ```text\n    rrqm/s：    每秒合并读操作的次数\n    wrqm/s：    每秒合并写操作的次数\n    r/s：       每秒读操作的次数 （IOPS）\n    w/s：       每秒写操作的次数 （IOPS）\n    rMB/s：     每秒读带宽\n    wMB/s：     每秒写带宽\n    avgrq-sz：  I/O请求的平均大小（扇区数）\n    avgqu-sz：  I/O请求队列的平均长度\n    await：     每个I/O平均耗时，单位是ms，这个时间包括I/O在队列中等待耗时，以及最终被磁盘设备处理的时间\n    r_await：   每个读操作的平均耗时\n    w_await：   每个写操作的平均耗时\n    %util：     该磁盘设备的繁忙度，该设备有I/O（即非空闲）的时间比率，不考虑I/O有多少，只考虑有没有。\n    ```\n\n- iostat常见选项：\n\n    ```text\n    -c 表示显示cpu使用情况，默认不写也会显示cpu使用情况\n    -d 表示显示磁盘使用情况，默认不写也会显示disk使用情况\n    -h  友好显示\n    -x 表示显示额外的统计信息\n    -k 表示以kb为单位显示磁盘请求数\n    -m 表示以M为单位显示磁盘请求数\n    -V 显示版本信\n    -p  [磁盘] 显示磁盘和分区的情况\n    ```\n\n### netstat\n\n`netstat` 是一个用于显示网络连接、路由表、网络接口状态等网络相关信息的命令行工具。它可用于查看当前系统的网络状态、连接情况以及网络性能信息。\n\n- 常见选项以及含义\n\n    ```bash\n    -a (all)显示所有选项，默认不显示LISTEN相关\n    -t (tcp)仅显示tcp相关选项\n    -u (udp)仅显示udp相关选项\n    -n 拒绝显示别名，能显示数字的全部转化成数字。\n    -l 仅列出有在 Listen (监听) 的服務状态\n    -p 显示建立相关链接的程序名\n    -r 显示路由信息，路由表\n    -e 显示扩展信息，例如uid等\n    -s 按各个协议进行统计\n    -c 每隔一个固定时间，执行该netstat命令。\n    ```\n\n### ps\n\nLinux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。\n\n- ps命令常用选项\n\n    ```text\n    -A 列出所有的进程\n    -w 显示加宽可以显示较多的资讯\n    -au 显示较详细的资讯\n    -aux 显示所有包含其他使用者的进程\n    ```\n\n- ps命令输出字段含义\n\n    ```text\n    USER: 行程拥有者\n    PID: pid\n    %CPU: 占用的 CPU 使用率\n    %MEM: 占用的记忆体使用率\n    VSZ: 占用的虚拟记忆体大小\n    RSS: 占用的记忆体大小\n    TTY: 终端的次要装置号码 (minor device number of tty)\n    STAT: 该行程的状态:\n    \n    D: 无法中断的休眠状态 (通常 IO 的进程)\n    R: 正在执行中\n    S: 静止状态\n    T: 暂停执行\n    Z: 不存在但暂时无法消除\n    W: 没有足够的记忆体分页可分配\n    <: 高优先序的行程\n    N: 低优先序的行程\n    L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\n    START: 行程开始时间\n    TIME: 执行的时间\n    COMMAND:所执行的指令\n    ```\n\n## Shell基础回顾\n\n### 变量赋值\n\n- 引用用户变量和环境变量\n- 命令替换\n- 从键盘读入赋值\n\n### 函数定义\n\n```bash\nfunction 函数名 {\n    函数体\n}\n\n函数名() {\n    函数体\n}\n```\n\n### if条件测试\n\n```bash\nif [ condition ]\nthen\n commands\nfi\n```\n\ncondition可以判断三种条件：\n\n1. 文件比较\n\n    ![3.Shell条件测试-2023-06-16-20-43-25](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png)\n\n2. 字符串比较\n\n    ![3.Shell条件测试-2023-06-16-20-46-41](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png)\n\n3. 数值比较\n\n    ![3.Shell条件测试-2023-06-16-21-06-44](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png)\n\n- if多条件测试：\n\n    ```bash\n    if (( a > b )) && (( a < c )) \n    或者\n    if [[ $a > $b ]] && [[ $a < $c ]] \n    或者 \n    if [ $a -gt $b -a $a -lt $c ]\n    ```\n\n### while循环\n\n```bash\nwhile [ 条件 ]\ndo\n    循环体\ndone\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。\n\n例如，下面的代码中，`while` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n```\n\n### for循环\n\n```bash\nfor 变量名 in 列表\ndo\n    循环体\ndone\n```\n\n### Shell脚本其他用法\n\n### select in\n\nselect in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。\n\nShell select in 循环的用法如下：\n\n```bash\nselect variable in value_list\ndo\n    statements\ndone\n```\n\n实例：\n\n```bash\n#!/bin/bash\necho \"What is your favourite OS?\"\nselect name in \"Linux\" \"Windows\" \"Mac OS\" \"UNIX\" \"Android\"\ndo\n    echo $name\ndone\necho \"You have selected $name\"\n```\n\nselect in 通常和  `case in` 一起使用，在用户输入不同的编号时可以做出不同的反应。\n\n```bash\n#!/bin/bash\necho \"What is your favourite OS?\"\nselect name in \"Linux\" \"Windows\" \"Mac OS\" \"UNIX\" \"Android\"\ndo\n    case $name in\n        \"Linux\")\n            echo \"Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。\"\n            break\n            ;;\n        \"Windows\")\n            echo \"Windows是微软开发的个人电脑操作系统，它是闭源收费的。\"\n            break\n            ;;\n        \"Mac OS\")\n            echo \"Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。\"\n            break\n            ;;\n        \"UNIX\")\n            echo \"UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。\"\n            break\n            ;;\n        \"Android\")\n            echo \"Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。\"\n            break\n            ;;\n        *)\n            echo \"输入错误，请重新输入\"\n    esac\ndone\n```\n\n### echo -e\n\n在 shell 脚本中，可以使用 `echo` 命令输出信息，但是默认情况下输出的文本是单色的，可能不够直观。如果要在输出中使用颜色，可以使用 `echo -e` 命令。\n\n`echo -e` 可以解析特定的转义序列，其中包括用于设置文本颜色的序列。常用的文本颜色序列如下：\n\n- `\\033[0m`：重置所有属性，包括颜色。\n- `\\033[30m` - `\\033[37m`：设置前景色为黑色到白色。\n- `\\033[40m` - `\\033[47m`：设置背景色为黑色到白色。\n\n```bash\necho -e \"\\033[31mThis is red text\\033[0m\"\n```\n\n### $和${}区别\n\n`$` 符号后跟变量名，表示对变量进行简单的替换。例如，`$var` 表示将变量 `var` 的值替换到命令中或输出中。这种形式适用于大多数简单的变量替换场景。\n\n`${}` 是一种更加复杂的语法形式，它可以用于更精确地定义变量扩展的边界。`${}` 可以用于以下情况：\n\n1. 明确指定变量的边界：`${var}` 表示变量 `var` 的边界，可用于区分变量名与紧随其后的字符。这在与其他字符连接时特别有用，例如`${var}name`。\n2. 执行变量替换时，`${}` 可以使用更复杂的表达式，例如变量的默认值、字符串替换、命令替换等。示例：`${var:-default}`、`${var/foo/bar}`、`${var//pattern/replacement}`。\n\n下面是一些`${}`的用法示例：\n\n- 变量替换：\n\n```bash\nname=\"Alice\"\necho \"Hello, ${name}!\"  # 输出：Hello, Alice!\n```\n\n- 指定变量边界：\n\n```bash\ntext=\"Hello,\"\necho \"${text}world\"  # 输出：Hello, !\n```\n\n- 默认值设定：\n\n```bash\nname=\"\"\necho \"Hello, ${name:-Guest}!\"  # 输出：Hello, Guest!\n```\n\n- 字符串替换：\n\n```bash\ntext=\"Hello, world!\"\necho \"${text/world/Universe}\"  # 输出：Hello, Universe!\n```\n\n`${}` 可以根据需要组合和嵌套，用于更复杂的变量操作和替换。它提供了更大的灵活性和精确性，使变量扩展更加强大。\n\n### sort\n\nLinux sort 命令用于将文本文件内容加以排序。\n\nsort 可针对文本文件的内容，以行为单位来排序。\n\n```text\n-b 忽略每行前面开始出的空格字符。\n-c 检查文件是否已经按照顺序排序。\n-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。\n-f 排序时，将小写字母视为大写字母。\n-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。\n-m 将几个排序好的文件进行合并。\n-M 将前面3个字母依照月份的缩写进行排序。\n-n 依照数值的大小排序。\n-u 意味着是唯一的(unique)，输出的结果是去完重了的。\n-o<输出文件> 将排序后的结果存入指定的文件。\n-r 以相反的顺序来排序。\n-t<分隔字符> 指定排序时所用的栏位分隔字符。\n+<起始栏位>-<结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n--help 显示帮助。\n--version 显示版本信息。\n[-k field1[,field2]] 按指定的列进行排序。\n```\n\n- 用法举例\n\n    ```sh\n    ##原始文件\n    $ cat testfile      # testfile文件原有排序  \n    test 30  \n    Hello 95  \n    Linux 85\n    ```\n\n    使用sort默认的排序方式\n\n    ```sh\n    $ sort testfile # 重排结果  \n    Hello 95  \n    Linux 85  \n    test 30\n    ```\n\n    使用 -k 参数设置对第二列的值进行重排，结果如下：\n\n    ```sh\n    $ sort testfile -k 2\n    test 30  \n    Linux 85 \n    Hello 95\n    ```\n\n## awk工具扩展\n\n### awk内的for循环\n\n在Awk中，for循环用于迭代执行一系列的操作。Awk中的for循环有两种形式：基于条件的for循环和基于集合的for循环。\n\n1. 基于条件的for循环：\n\n    ```bash\n    for (初始化; 条件; 迭代) {\n        # 循环体\n    }\n    ```\n\n    初始化在循环开始前执行，条件在每次迭代前进行检查，如果条件为真，则执行循环体，迭代在每次循环体执行完后执行。\n\n2. 基于集合的for循环：\n\n    ```bash\n    for (变量 in 集合) {\n        # 循环体\n    }\n    ```\n\n### 数组\n\n在awk中，数组是一种常用的数据结构，用于存储和操作数据。\n\n1. 声明数组：使用`arrayName[index] = value`语法来声明数组，并将指定的索引位置赋值为对应的值。例如：`fruits[0] = \"apple\"`。\n2. 访问数组元素：使用`arrayName[index]`语法来访问数组的特定元素。例如：`fruits[0]`表示访问数组`fruits`中索引为0的元素。\n3. 遍历数组：可以使用`for (index in arrayName)`语法来遍历数组中的所有元素。\n\n```bash\nawk -F: '{shells[$NF]++} END{for (i in shells){print i,shells[i]}}' /etc/passwd\n```\n\n## 第一节课代码\n\n```bash\n#!/bin/bash\n#\nos_check() {\n        if [ -e /etc/redhat-release ]; then\n                REDHAT=`cat /etc/redhat-release |cut -d' ' -f1`\n        else\n                DEBIAN=`cat /etc/issue |cut -d' ' -f1`\n        fi\n        if [ \"$REDHAT\" == \"CentOS\" -o \"$REDHAT\" == \"Red\" ]; then\n                P_M=yum\n        elif [ \"$DEBIAN\" == \"Ubuntu\" -o \"$DEBIAN\" == \"ubutnu\" ]; then\n                P_M=apt-get\n        else\n                echo\"Operating system does not support.\"\n                exit 1\n        fi\n}\n#查看登录的用户是否为 root\nif [ $LOGNAME != root ]; then\n        echo \"Please use the root account operation.\"\n        exit 1\nfi\n#查看是否存在 vmstat 命令\nif ! which vmstat &>/dev/null; then\n        echo \"vmstat command not found, now the install.\"\n        sleep 1\n        os_check\n        $P_M install procps -y\n        echo    \"-----------------------------------------------------------------\n        ------\"\nfi\n#查看是否有 iostat 命令\nif ! which iostat &>/dev/null; then\n        echo \"iostat command not found, now the install.\"\n        sleep 1\n        os_check\n        $P_M install sysstat -y\n        echo   \"------------------------------------------------------------------\n        -----\"\nfi\n#打印菜单\nwhile true; do\n        select input in cpu_load disk_load disk_use disk_inode mem_use tcp_status cpu_top10 mem_top10 traffic quit; do\n                case $input in\n                        cpu_load)\n                                #CPU 利用率与负载\n                                echo \"-----------------------------------------------------\"\n                                i=1\n                                while [[ $i -le 3 ]]; do\n                                        echo -e \"\\033[32m 参考值${i}\\033[0m\"\n                                        UTIL=`vmstat |awk '{if(NR==3)print 100-$15\"%\"}'`\n                                        USER=`vmstat |awk '{if(NR==3)print $13\"%\"}'`\n                                        SYS=`vmstat |awk '{if(NR==3)print $14\"%\"}'`\n                                        IOWAIT=`vmstat |awk '{if(NR==3)print $16\"%\"}'`\n                                        echo \"Util: $UTIL\"\n                                        echo \"User use: $USER\"\n                                        echo \"System use: $SYS\"\n                                        echo \"I/O wait: $IOWAIT\" \n                                        i=$(($i+1))\n                                        sleep 1\n                                done\n                                echo \"  -------------------------------------------------------\"\n                                break\n                                ;;\n                        quit)\n                                exit 0\n                                ;;\n                esac\n        done\ndone\n```\n","source":"_posts/linux_shell/11.系统资源性能监控脚本构建.md","raw":"---\ntitle: 系统资源性能瓶颈脚本构建\ndate: 2023-06-16 21:35:08\ntags:\n---\n\n## 常见的系统性能分析工具\n\n- 为什么利用Shell脚本进行系统资源性能分析\n    1. 在系统性能分析中，我们需要收集大量的数据并进行分析，而手动操作比较繁琐且容易出错，而且不易重复。使用shell脚本可以自动化执行这些操作，提高效率和准确性。\n    2. 由于shell脚本的灵活性和可编程性，可以根据不同需求和环境对脚本进行维护和扩展，实现各种不同的性能分析操作，可以大大提高工作效率和准确性。\n\n### vmstat\n\nvmstat是一个用于Linux系统的性能分析工具，它能够实时地监测CPU、内存、I/O、交换分区等系统性能数据，并将这些数据以一定的时间间隔（默认为2秒）输出到终端或日志文件中，提供给用户进行分析和优化。\n\n- vmstat输出信息含义：\n\n    ```text\n    r：等待运行的进程数目，即运行队列长度；\n    b：处于不可中断状态（blocked）的进程数目；\n    swpd：使用虚拟内存的大小，单位为KB；\n    free：空闲物理内存的大小，单位为KB；\n    buff：用作缓存的内存大小，单位为KB；\n    cache：用作缓存的页缓存的大小，单位为KB；\n    si：从磁盘交换入的内存大小，单位为KB/s；\n    so：向磁盘交换出的内存大小，单位为KB/s；\n    bi：从块设备读取的块数，单位为块/s；\n    bo：向块设备写入的块数，单位为块/s；\n    in：每秒中断数，包括时钟中断；\n    cs：每秒上下文切换次数；\n    us：用户进程占用CPU时间百分比；\n    sy：系统内核占用CPU时间百分比；\n    id：CPU空闲时间百分比；\n    wa：等待I/O完成时间百分比;\n    st：虚拟机占用CPU时间百分比；\n    ```\n\n- 查看系统的整体性能信息： `vmstat`\n- 每隔一段时间查看系统的整体性能信息： `vmstat 5 1`\n- 输出带有时间戳的系统整体性能信息： `vmstat -t`\n- 显示磁盘信息： `vmstat -d`\n- 显示指定的硬盘分区状态： `vmstat -p disk part`\n- 修改输出信息的单位： `vmstat -S M`\n\n### iostat\n\niostat是一个常用的性能分析工具，它可以监测CPU、磁盘、网络等系统资源的使用情况。\n\n- 输出信息含义：\n\n    ```text\n    rrqm/s：    每秒合并读操作的次数\n    wrqm/s：    每秒合并写操作的次数\n    r/s：       每秒读操作的次数 （IOPS）\n    w/s：       每秒写操作的次数 （IOPS）\n    rMB/s：     每秒读带宽\n    wMB/s：     每秒写带宽\n    avgrq-sz：  I/O请求的平均大小（扇区数）\n    avgqu-sz：  I/O请求队列的平均长度\n    await：     每个I/O平均耗时，单位是ms，这个时间包括I/O在队列中等待耗时，以及最终被磁盘设备处理的时间\n    r_await：   每个读操作的平均耗时\n    w_await：   每个写操作的平均耗时\n    %util：     该磁盘设备的繁忙度，该设备有I/O（即非空闲）的时间比率，不考虑I/O有多少，只考虑有没有。\n    ```\n\n- iostat常见选项：\n\n    ```text\n    -c 表示显示cpu使用情况，默认不写也会显示cpu使用情况\n    -d 表示显示磁盘使用情况，默认不写也会显示disk使用情况\n    -h  友好显示\n    -x 表示显示额外的统计信息\n    -k 表示以kb为单位显示磁盘请求数\n    -m 表示以M为单位显示磁盘请求数\n    -V 显示版本信\n    -p  [磁盘] 显示磁盘和分区的情况\n    ```\n\n### netstat\n\n`netstat` 是一个用于显示网络连接、路由表、网络接口状态等网络相关信息的命令行工具。它可用于查看当前系统的网络状态、连接情况以及网络性能信息。\n\n- 常见选项以及含义\n\n    ```bash\n    -a (all)显示所有选项，默认不显示LISTEN相关\n    -t (tcp)仅显示tcp相关选项\n    -u (udp)仅显示udp相关选项\n    -n 拒绝显示别名，能显示数字的全部转化成数字。\n    -l 仅列出有在 Listen (监听) 的服務状态\n    -p 显示建立相关链接的程序名\n    -r 显示路由信息，路由表\n    -e 显示扩展信息，例如uid等\n    -s 按各个协议进行统计\n    -c 每隔一个固定时间，执行该netstat命令。\n    ```\n\n### ps\n\nLinux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。\n\n- ps命令常用选项\n\n    ```text\n    -A 列出所有的进程\n    -w 显示加宽可以显示较多的资讯\n    -au 显示较详细的资讯\n    -aux 显示所有包含其他使用者的进程\n    ```\n\n- ps命令输出字段含义\n\n    ```text\n    USER: 行程拥有者\n    PID: pid\n    %CPU: 占用的 CPU 使用率\n    %MEM: 占用的记忆体使用率\n    VSZ: 占用的虚拟记忆体大小\n    RSS: 占用的记忆体大小\n    TTY: 终端的次要装置号码 (minor device number of tty)\n    STAT: 该行程的状态:\n    \n    D: 无法中断的休眠状态 (通常 IO 的进程)\n    R: 正在执行中\n    S: 静止状态\n    T: 暂停执行\n    Z: 不存在但暂时无法消除\n    W: 没有足够的记忆体分页可分配\n    <: 高优先序的行程\n    N: 低优先序的行程\n    L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\n    START: 行程开始时间\n    TIME: 执行的时间\n    COMMAND:所执行的指令\n    ```\n\n## Shell基础回顾\n\n### 变量赋值\n\n- 引用用户变量和环境变量\n- 命令替换\n- 从键盘读入赋值\n\n### 函数定义\n\n```bash\nfunction 函数名 {\n    函数体\n}\n\n函数名() {\n    函数体\n}\n```\n\n### if条件测试\n\n```bash\nif [ condition ]\nthen\n commands\nfi\n```\n\ncondition可以判断三种条件：\n\n1. 文件比较\n\n    ![3.Shell条件测试-2023-06-16-20-43-25](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png)\n\n2. 字符串比较\n\n    ![3.Shell条件测试-2023-06-16-20-46-41](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png)\n\n3. 数值比较\n\n    ![3.Shell条件测试-2023-06-16-21-06-44](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png)\n\n- if多条件测试：\n\n    ```bash\n    if (( a > b )) && (( a < c )) \n    或者\n    if [[ $a > $b ]] && [[ $a < $c ]] \n    或者 \n    if [ $a -gt $b -a $a -lt $c ]\n    ```\n\n### while循环\n\n```bash\nwhile [ 条件 ]\ndo\n    循环体\ndone\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。\n\n例如，下面的代码中，`while` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n```\n\n### for循环\n\n```bash\nfor 变量名 in 列表\ndo\n    循环体\ndone\n```\n\n### Shell脚本其他用法\n\n### select in\n\nselect in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。\n\nShell select in 循环的用法如下：\n\n```bash\nselect variable in value_list\ndo\n    statements\ndone\n```\n\n实例：\n\n```bash\n#!/bin/bash\necho \"What is your favourite OS?\"\nselect name in \"Linux\" \"Windows\" \"Mac OS\" \"UNIX\" \"Android\"\ndo\n    echo $name\ndone\necho \"You have selected $name\"\n```\n\nselect in 通常和  `case in` 一起使用，在用户输入不同的编号时可以做出不同的反应。\n\n```bash\n#!/bin/bash\necho \"What is your favourite OS?\"\nselect name in \"Linux\" \"Windows\" \"Mac OS\" \"UNIX\" \"Android\"\ndo\n    case $name in\n        \"Linux\")\n            echo \"Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。\"\n            break\n            ;;\n        \"Windows\")\n            echo \"Windows是微软开发的个人电脑操作系统，它是闭源收费的。\"\n            break\n            ;;\n        \"Mac OS\")\n            echo \"Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。\"\n            break\n            ;;\n        \"UNIX\")\n            echo \"UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。\"\n            break\n            ;;\n        \"Android\")\n            echo \"Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。\"\n            break\n            ;;\n        *)\n            echo \"输入错误，请重新输入\"\n    esac\ndone\n```\n\n### echo -e\n\n在 shell 脚本中，可以使用 `echo` 命令输出信息，但是默认情况下输出的文本是单色的，可能不够直观。如果要在输出中使用颜色，可以使用 `echo -e` 命令。\n\n`echo -e` 可以解析特定的转义序列，其中包括用于设置文本颜色的序列。常用的文本颜色序列如下：\n\n- `\\033[0m`：重置所有属性，包括颜色。\n- `\\033[30m` - `\\033[37m`：设置前景色为黑色到白色。\n- `\\033[40m` - `\\033[47m`：设置背景色为黑色到白色。\n\n```bash\necho -e \"\\033[31mThis is red text\\033[0m\"\n```\n\n### $和${}区别\n\n`$` 符号后跟变量名，表示对变量进行简单的替换。例如，`$var` 表示将变量 `var` 的值替换到命令中或输出中。这种形式适用于大多数简单的变量替换场景。\n\n`${}` 是一种更加复杂的语法形式，它可以用于更精确地定义变量扩展的边界。`${}` 可以用于以下情况：\n\n1. 明确指定变量的边界：`${var}` 表示变量 `var` 的边界，可用于区分变量名与紧随其后的字符。这在与其他字符连接时特别有用，例如`${var}name`。\n2. 执行变量替换时，`${}` 可以使用更复杂的表达式，例如变量的默认值、字符串替换、命令替换等。示例：`${var:-default}`、`${var/foo/bar}`、`${var//pattern/replacement}`。\n\n下面是一些`${}`的用法示例：\n\n- 变量替换：\n\n```bash\nname=\"Alice\"\necho \"Hello, ${name}!\"  # 输出：Hello, Alice!\n```\n\n- 指定变量边界：\n\n```bash\ntext=\"Hello,\"\necho \"${text}world\"  # 输出：Hello, !\n```\n\n- 默认值设定：\n\n```bash\nname=\"\"\necho \"Hello, ${name:-Guest}!\"  # 输出：Hello, Guest!\n```\n\n- 字符串替换：\n\n```bash\ntext=\"Hello, world!\"\necho \"${text/world/Universe}\"  # 输出：Hello, Universe!\n```\n\n`${}` 可以根据需要组合和嵌套，用于更复杂的变量操作和替换。它提供了更大的灵活性和精确性，使变量扩展更加强大。\n\n### sort\n\nLinux sort 命令用于将文本文件内容加以排序。\n\nsort 可针对文本文件的内容，以行为单位来排序。\n\n```text\n-b 忽略每行前面开始出的空格字符。\n-c 检查文件是否已经按照顺序排序。\n-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。\n-f 排序时，将小写字母视为大写字母。\n-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。\n-m 将几个排序好的文件进行合并。\n-M 将前面3个字母依照月份的缩写进行排序。\n-n 依照数值的大小排序。\n-u 意味着是唯一的(unique)，输出的结果是去完重了的。\n-o<输出文件> 将排序后的结果存入指定的文件。\n-r 以相反的顺序来排序。\n-t<分隔字符> 指定排序时所用的栏位分隔字符。\n+<起始栏位>-<结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n--help 显示帮助。\n--version 显示版本信息。\n[-k field1[,field2]] 按指定的列进行排序。\n```\n\n- 用法举例\n\n    ```sh\n    ##原始文件\n    $ cat testfile      # testfile文件原有排序  \n    test 30  \n    Hello 95  \n    Linux 85\n    ```\n\n    使用sort默认的排序方式\n\n    ```sh\n    $ sort testfile # 重排结果  \n    Hello 95  \n    Linux 85  \n    test 30\n    ```\n\n    使用 -k 参数设置对第二列的值进行重排，结果如下：\n\n    ```sh\n    $ sort testfile -k 2\n    test 30  \n    Linux 85 \n    Hello 95\n    ```\n\n## awk工具扩展\n\n### awk内的for循环\n\n在Awk中，for循环用于迭代执行一系列的操作。Awk中的for循环有两种形式：基于条件的for循环和基于集合的for循环。\n\n1. 基于条件的for循环：\n\n    ```bash\n    for (初始化; 条件; 迭代) {\n        # 循环体\n    }\n    ```\n\n    初始化在循环开始前执行，条件在每次迭代前进行检查，如果条件为真，则执行循环体，迭代在每次循环体执行完后执行。\n\n2. 基于集合的for循环：\n\n    ```bash\n    for (变量 in 集合) {\n        # 循环体\n    }\n    ```\n\n### 数组\n\n在awk中，数组是一种常用的数据结构，用于存储和操作数据。\n\n1. 声明数组：使用`arrayName[index] = value`语法来声明数组，并将指定的索引位置赋值为对应的值。例如：`fruits[0] = \"apple\"`。\n2. 访问数组元素：使用`arrayName[index]`语法来访问数组的特定元素。例如：`fruits[0]`表示访问数组`fruits`中索引为0的元素。\n3. 遍历数组：可以使用`for (index in arrayName)`语法来遍历数组中的所有元素。\n\n```bash\nawk -F: '{shells[$NF]++} END{for (i in shells){print i,shells[i]}}' /etc/passwd\n```\n\n## 第一节课代码\n\n```bash\n#!/bin/bash\n#\nos_check() {\n        if [ -e /etc/redhat-release ]; then\n                REDHAT=`cat /etc/redhat-release |cut -d' ' -f1`\n        else\n                DEBIAN=`cat /etc/issue |cut -d' ' -f1`\n        fi\n        if [ \"$REDHAT\" == \"CentOS\" -o \"$REDHAT\" == \"Red\" ]; then\n                P_M=yum\n        elif [ \"$DEBIAN\" == \"Ubuntu\" -o \"$DEBIAN\" == \"ubutnu\" ]; then\n                P_M=apt-get\n        else\n                echo\"Operating system does not support.\"\n                exit 1\n        fi\n}\n#查看登录的用户是否为 root\nif [ $LOGNAME != root ]; then\n        echo \"Please use the root account operation.\"\n        exit 1\nfi\n#查看是否存在 vmstat 命令\nif ! which vmstat &>/dev/null; then\n        echo \"vmstat command not found, now the install.\"\n        sleep 1\n        os_check\n        $P_M install procps -y\n        echo    \"-----------------------------------------------------------------\n        ------\"\nfi\n#查看是否有 iostat 命令\nif ! which iostat &>/dev/null; then\n        echo \"iostat command not found, now the install.\"\n        sleep 1\n        os_check\n        $P_M install sysstat -y\n        echo   \"------------------------------------------------------------------\n        -----\"\nfi\n#打印菜单\nwhile true; do\n        select input in cpu_load disk_load disk_use disk_inode mem_use tcp_status cpu_top10 mem_top10 traffic quit; do\n                case $input in\n                        cpu_load)\n                                #CPU 利用率与负载\n                                echo \"-----------------------------------------------------\"\n                                i=1\n                                while [[ $i -le 3 ]]; do\n                                        echo -e \"\\033[32m 参考值${i}\\033[0m\"\n                                        UTIL=`vmstat |awk '{if(NR==3)print 100-$15\"%\"}'`\n                                        USER=`vmstat |awk '{if(NR==3)print $13\"%\"}'`\n                                        SYS=`vmstat |awk '{if(NR==3)print $14\"%\"}'`\n                                        IOWAIT=`vmstat |awk '{if(NR==3)print $16\"%\"}'`\n                                        echo \"Util: $UTIL\"\n                                        echo \"User use: $USER\"\n                                        echo \"System use: $SYS\"\n                                        echo \"I/O wait: $IOWAIT\" \n                                        i=$(($i+1))\n                                        sleep 1\n                                done\n                                echo \"  -------------------------------------------------------\"\n                                break\n                                ;;\n                        quit)\n                                exit 0\n                                ;;\n                esac\n        done\ndone\n```\n","slug":"linux_shell/11.系统资源性能监控脚本构建","published":1,"updated":"2023-06-18T07:59:34.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04h00071dnz6rkq179r","content":"<h2 id=\"常见的系统性能分析工具\"><a href=\"#常见的系统性能分析工具\" class=\"headerlink\" title=\"常见的系统性能分析工具\"></a>常见的系统性能分析工具</h2><ul>\n<li>为什么利用Shell脚本进行系统资源性能分析<ol>\n<li>在系统性能分析中，我们需要收集大量的数据并进行分析，而手动操作比较繁琐且容易出错，而且不易重复。使用shell脚本可以自动化执行这些操作，提高效率和准确性。</li>\n<li>由于shell脚本的灵活性和可编程性，可以根据不同需求和环境对脚本进行维护和扩展，实现各种不同的性能分析操作，可以大大提高工作效率和准确性。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h3><p>vmstat是一个用于Linux系统的性能分析工具，它能够实时地监测CPU、内存、I&#x2F;O、交换分区等系统性能数据，并将这些数据以一定的时间间隔（默认为2秒）输出到终端或日志文件中，提供给用户进行分析和优化。</p>\n<ul>\n<li><p>vmstat输出信息含义：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">r：等待运行的进程数目，即运行队列长度；\nb：处于不可中断状态（blocked）的进程数目；\nswpd：使用虚拟内存的大小，单位为KB；\nfree：空闲物理内存的大小，单位为KB；\nbuff：用作缓存的内存大小，单位为KB；\ncache：用作缓存的页缓存的大小，单位为KB；\nsi：从磁盘交换入的内存大小，单位为KB/s；\nso：向磁盘交换出的内存大小，单位为KB/s；\nbi：从块设备读取的块数，单位为块/s；\nbo：向块设备写入的块数，单位为块/s；\nin：每秒中断数，包括时钟中断；\ncs：每秒上下文切换次数；\nus：用户进程占用CPU时间百分比；\nsy：系统内核占用CPU时间百分比；\nid：CPU空闲时间百分比；\nwa：等待I/O完成时间百分比;\nst：虚拟机占用CPU时间百分比；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看系统的整体性能信息： <code>vmstat</code></p>\n</li>\n<li><p>每隔一段时间查看系统的整体性能信息： <code>vmstat 5 1</code></p>\n</li>\n<li><p>输出带有时间戳的系统整体性能信息： <code>vmstat -t</code></p>\n</li>\n<li><p>显示磁盘信息： <code>vmstat -d</code></p>\n</li>\n<li><p>显示指定的硬盘分区状态： <code>vmstat -p disk part</code></p>\n</li>\n<li><p>修改输出信息的单位： <code>vmstat -S M</code></p>\n</li>\n</ul>\n<h3 id=\"iostat\"><a href=\"#iostat\" class=\"headerlink\" title=\"iostat\"></a>iostat</h3><p>iostat是一个常用的性能分析工具，它可以监测CPU、磁盘、网络等系统资源的使用情况。</p>\n<ul>\n<li><p>输出信息含义：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">rrqm/s：    每秒合并读操作的次数\nwrqm/s：    每秒合并写操作的次数\nr/s：       每秒读操作的次数 （IOPS）\nw/s：       每秒写操作的次数 （IOPS）\nrMB/s：     每秒读带宽\nwMB/s：     每秒写带宽\navgrq-sz：  I/O请求的平均大小（扇区数）\navgqu-sz：  I/O请求队列的平均长度\nawait：     每个I/O平均耗时，单位是ms，这个时间包括I/O在队列中等待耗时，以及最终被磁盘设备处理的时间\nr_await：   每个读操作的平均耗时\nw_await：   每个写操作的平均耗时\n%util：     该磁盘设备的繁忙度，该设备有I/O（即非空闲）的时间比率，不考虑I/O有多少，只考虑有没有。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>iostat常见选项：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-c 表示显示cpu使用情况，默认不写也会显示cpu使用情况\n-d 表示显示磁盘使用情况，默认不写也会显示disk使用情况\n-h  友好显示\n-x 表示显示额外的统计信息\n-k 表示以kb为单位显示磁盘请求数\n-m 表示以M为单位显示磁盘请求数\n-V 显示版本信\n-p  [磁盘] 显示磁盘和分区的情况<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h3><p><code>netstat</code> 是一个用于显示网络连接、路由表、网络接口状态等网络相关信息的命令行工具。它可用于查看当前系统的网络状态、连接情况以及网络性能信息。</p>\n<ul>\n<li><p>常见选项以及含义</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-a</span> <span class=\"token punctuation\">(</span>all<span class=\"token punctuation\">)</span>显示所有选项，默认不显示LISTEN相关\n<span class=\"token parameter variable\">-t</span> <span class=\"token punctuation\">(</span>tcp<span class=\"token punctuation\">)</span>仅显示tcp相关选项\n<span class=\"token parameter variable\">-u</span> <span class=\"token punctuation\">(</span>udp<span class=\"token punctuation\">)</span>仅显示udp相关选项\n<span class=\"token parameter variable\">-n</span> 拒绝显示别名，能显示数字的全部转化成数字。\n<span class=\"token parameter variable\">-l</span> 仅列出有在 Listen <span class=\"token punctuation\">(</span>监听<span class=\"token punctuation\">)</span> 的服務状态\n<span class=\"token parameter variable\">-p</span> 显示建立相关链接的程序名\n<span class=\"token parameter variable\">-r</span> 显示路由信息，路由表\n<span class=\"token parameter variable\">-e</span> 显示扩展信息，例如uid等\n<span class=\"token parameter variable\">-s</span> 按各个协议进行统计\n<span class=\"token parameter variable\">-c</span> 每隔一个固定时间，执行该netstat命令。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>\n<ul>\n<li><p>ps命令常用选项</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-A 列出所有的进程\n-w 显示加宽可以显示较多的资讯\n-au 显示较详细的资讯\n-aux 显示所有包含其他使用者的进程<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>ps命令输出字段含义</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">USER: 行程拥有者\nPID: pid\n%CPU: 占用的 CPU 使用率\n%MEM: 占用的记忆体使用率\nVSZ: 占用的虚拟记忆体大小\nRSS: 占用的记忆体大小\nTTY: 终端的次要装置号码 (minor device number of tty)\nSTAT: 该行程的状态:\n\nD: 无法中断的休眠状态 (通常 IO 的进程)\nR: 正在执行中\nS: 静止状态\nT: 暂停执行\nZ: 不存在但暂时无法消除\nW: 没有足够的记忆体分页可分配\n&lt;: 高优先序的行程\nN: 低优先序的行程\nL: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\nSTART: 行程开始时间\nTIME: 执行的时间\nCOMMAND:所执行的指令<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"Shell基础回顾\"><a href=\"#Shell基础回顾\" class=\"headerlink\" title=\"Shell基础回顾\"></a>Shell基础回顾</h2><h3 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h3><ul>\n<li>引用用户变量和环境变量</li>\n<li>命令替换</li>\n<li>从键盘读入赋值</li>\n</ul>\n<h3 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> 函数名 <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span>\n\n函数名<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"if条件测试\"><a href=\"#if条件测试\" class=\"headerlink\" title=\"if条件测试\"></a>if条件测试</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n commands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>condition可以判断三种条件：</p>\n<ol>\n<li><p>文件比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png\" alt=\"3.Shell条件测试-2023-06-16-20-43-25\"></p>\n</li>\n<li><p>字符串比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png\" alt=\"3.Shell条件测试-2023-06-16-20-46-41\"></p>\n</li>\n<li><p>数值比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png\" alt=\"3.Shell条件测试-2023-06-16-21-06-44\"></p>\n</li>\n</ol>\n<ul>\n<li><p>if多条件测试：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> a <span class=\"token operator\">></span> b <span class=\"token punctuation\">))</span></span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> a <span class=\"token operator\">&lt;</span> c <span class=\"token punctuation\">))</span></span> \n或者\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$a</span> <span class=\"token operator\">></span> <span class=\"token variable\">$b</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$a</span> <span class=\"token operator\">&lt;</span> <span class=\"token variable\">$c</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> \n或者 \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$a</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token variable\">$b</span> <span class=\"token parameter variable\">-a</span> <span class=\"token variable\">$a</span> <span class=\"token parameter variable\">-lt</span> <span class=\"token variable\">$c</span> <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> 条件 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。</p>\n<p>例如，下面的代码中，<code>while</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"当前变量的值是 <span class=\"token variable\">$i</span>\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> 变量名 <span class=\"token keyword\">in</span> 列表\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Shell脚本其他用法\"><a href=\"#Shell脚本其他用法\" class=\"headerlink\" title=\"Shell脚本其他用法\"></a>Shell脚本其他用法</h3><h3 id=\"select-in\"><a href=\"#select-in\" class=\"headerlink\" title=\"select in\"></a>select in</h3><p>select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。</p>\n<p>Shell select in 循环的用法如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">variable</span> <span class=\"token keyword\">in</span> value_list\n<span class=\"token keyword\">do</span>\n    statements\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>实例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"What is your favourite OS?\"</span>\n<span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">name</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"Linux\"</span> <span class=\"token string\">\"Windows\"</span> <span class=\"token string\">\"Mac OS\"</span> <span class=\"token string\">\"UNIX\"</span> <span class=\"token string\">\"Android\"</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$name</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"You have selected <span class=\"token variable\">$name</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>select in 通常和  <code>case in</code> 一起使用，在用户输入不同的编号时可以做出不同的反应。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"What is your favourite OS?\"</span>\n<span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">name</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"Linux\"</span> <span class=\"token string\">\"Windows\"</span> <span class=\"token string\">\"Mac OS\"</span> <span class=\"token string\">\"UNIX\"</span> <span class=\"token string\">\"Android\"</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">case</span> <span class=\"token variable\">$name</span> <span class=\"token keyword\">in</span>\n        <span class=\"token string\">\"Linux\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"Windows\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Windows是微软开发的个人电脑操作系统，它是闭源收费的。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"Mac OS\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"UNIX\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"Android\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        *<span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"输入错误，请重新输入\"</span>\n    <span class=\"token keyword\">esac</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"echo-e\"><a href=\"#echo-e\" class=\"headerlink\" title=\"echo -e\"></a>echo -e</h3><p>在 shell 脚本中，可以使用 <code>echo</code> 命令输出信息，但是默认情况下输出的文本是单色的，可能不够直观。如果要在输出中使用颜色，可以使用 <code>echo -e</code> 命令。</p>\n<p><code>echo -e</code> 可以解析特定的转义序列，其中包括用于设置文本颜色的序列。常用的文本颜色序列如下：</p>\n<ul>\n<li><code>\\033[0m</code>：重置所有属性，包括颜色。</li>\n<li><code>\\033[30m</code> - <code>\\033[37m</code>：设置前景色为黑色到白色。</li>\n<li><code>\\033[40m</code> - <code>\\033[47m</code>：设置背景色为黑色到白色。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[31mThis is red text<span class=\"token entity\" title=\"\\033\">\\033</span>[0m\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"和-区别\"><a href=\"#和-区别\" class=\"headerlink\" title=\"$和${}区别\"></a>$和${}区别</h3><p><code>$</code> 符号后跟变量名，表示对变量进行简单的替换。例如，<code>$var</code> 表示将变量 <code>var</code> 的值替换到命令中或输出中。这种形式适用于大多数简单的变量替换场景。</p>\n<p><code>$&#123;&#125;</code> 是一种更加复杂的语法形式，它可以用于更精确地定义变量扩展的边界。<code>$&#123;&#125;</code> 可以用于以下情况：</p>\n<ol>\n<li>明确指定变量的边界：<code>$&#123;var&#125;</code> 表示变量 <code>var</code> 的边界，可用于区分变量名与紧随其后的字符。这在与其他字符连接时特别有用，例如<code>$&#123;var&#125;name</code>。</li>\n<li>执行变量替换时，<code>$&#123;&#125;</code> 可以使用更复杂的表达式，例如变量的默认值、字符串替换、命令替换等。示例：<code>$&#123;var:-default&#125;</code>、<code>$&#123;var/foo/bar&#125;</code>、<code>$&#123;var//pattern/replacement&#125;</code>。</li>\n</ol>\n<p>下面是一些<code>$&#123;&#125;</code>的用法示例：</p>\n<ul>\n<li>变量替换：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"Alice\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$&#123;name&#125;</span>!\"</span>  <span class=\"token comment\"># 输出：Hello, Alice!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>指定变量边界：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">text</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello,\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;text&#125;</span>world\"</span>  <span class=\"token comment\"># 输出：Hello, !</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>默认值设定：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$&#123;name<span class=\"token operator\">:-</span>Guest&#125;</span>!\"</span>  <span class=\"token comment\"># 输出：Hello, Guest!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>字符串替换：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">text</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello, world!\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;text<span class=\"token operator\">/</span>world<span class=\"token operator\">/</span>Universe&#125;</span>\"</span>  <span class=\"token comment\"># 输出：Hello, Universe!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><code>$&#123;&#125;</code> 可以根据需要组合和嵌套，用于更复杂的变量操作和替换。它提供了更大的灵活性和精确性，使变量扩展更加强大。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p>Linux sort 命令用于将文本文件内容加以排序。</p>\n<p>sort 可针对文本文件的内容，以行为单位来排序。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-b 忽略每行前面开始出的空格字符。\n-c 检查文件是否已经按照顺序排序。\n-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。\n-f 排序时，将小写字母视为大写字母。\n-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。\n-m 将几个排序好的文件进行合并。\n-M 将前面3个字母依照月份的缩写进行排序。\n-n 依照数值的大小排序。\n-u 意味着是唯一的(unique)，输出的结果是去完重了的。\n-o&lt;输出文件> 将排序后的结果存入指定的文件。\n-r 以相反的顺序来排序。\n-t&lt;分隔字符> 指定排序时所用的栏位分隔字符。\n+&lt;起始栏位>-&lt;结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n--help 显示帮助。\n--version 显示版本信息。\n[-k field1[,field2]] 按指定的列进行排序。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>用法举例</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">##原始文件</span>\n$ <span class=\"token function\">cat</span> testfile      <span class=\"token comment\"># testfile文件原有排序  </span>\n<span class=\"token builtin class-name\">test</span> <span class=\"token number\">30</span>  \nHello <span class=\"token number\">95</span>  \nLinux <span class=\"token number\">85</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  使用sort默认的排序方式</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sort</span> testfile <span class=\"token comment\"># 重排结果  </span>\nHello <span class=\"token number\">95</span>  \nLinux <span class=\"token number\">85</span>  \n<span class=\"token builtin class-name\">test</span> <span class=\"token number\">30</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  使用 -k 参数设置对第二列的值进行重排，结果如下：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sort</span> testfile <span class=\"token parameter variable\">-k</span> <span class=\"token number\">2</span>\n<span class=\"token builtin class-name\">test</span> <span class=\"token number\">30</span>  \nLinux <span class=\"token number\">85</span> \nHello <span class=\"token number\">95</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"awk工具扩展\"><a href=\"#awk工具扩展\" class=\"headerlink\" title=\"awk工具扩展\"></a>awk工具扩展</h2><h3 id=\"awk内的for循环\"><a href=\"#awk内的for循环\" class=\"headerlink\" title=\"awk内的for循环\"></a>awk内的for循环</h3><p>在Awk中，for循环用于迭代执行一系列的操作。Awk中的for循环有两种形式：基于条件的for循环和基于集合的for循环。</p>\n<ol>\n<li><p>基于条件的for循环：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>初始化<span class=\"token punctuation\">;</span> 条件<span class=\"token punctuation\">;</span> 迭代<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\"># 循环体</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p> 初始化在循环开始前执行，条件在每次迭代前进行检查，如果条件为真，则执行循环体，迭代在每次循环体执行完后执行。</p>\n</li>\n<li><p>基于集合的for循环：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>变量 <span class=\"token keyword\">in</span> 集合<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\"># 循环体</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在awk中，数组是一种常用的数据结构，用于存储和操作数据。</p>\n<ol>\n<li>声明数组：使用<code>arrayName[index] = value</code>语法来声明数组，并将指定的索引位置赋值为对应的值。例如：<code>fruits[0] = &quot;apple&quot;</code>。</li>\n<li>访问数组元素：使用<code>arrayName[index]</code>语法来访问数组的特定元素。例如：<code>fruits[0]</code>表示访问数组<code>fruits</code>中索引为0的元素。</li>\n<li>遍历数组：可以使用<code>for (index in arrayName)</code>语法来遍历数组中的所有元素。</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">awk</span> -F: <span class=\"token string\">'&#123;shells[$NF]++&#125; END&#123;for (i in shells)&#123;print i,shells[i]&#125;&#125;'</span> /etc/passwd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"第一节课代码\"><a href=\"#第一节课代码\" class=\"headerlink\" title=\"第一节课代码\"></a>第一节课代码</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\">#</span>\n<span class=\"token function-name function\">os_check</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-e</span> /etc/redhat-release <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n                <span class=\"token assign-left variable\">REDHAT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">cat</span> /etc/redhat-release <span class=\"token operator\">|</span><span class=\"token function\">cut</span> -d<span class=\"token string\">' '</span> <span class=\"token parameter variable\">-f1</span><span class=\"token variable\">`</span></span>\n        <span class=\"token keyword\">else</span>\n                <span class=\"token assign-left variable\">DEBIAN</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">cat</span> /etc/issue <span class=\"token operator\">|</span><span class=\"token function\">cut</span> -d<span class=\"token string\">' '</span> <span class=\"token parameter variable\">-f1</span><span class=\"token variable\">`</span></span>\n        <span class=\"token keyword\">fi</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$REDHAT</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"CentOS\"</span> <span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token variable\">$REDHAT</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Red\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n                <span class=\"token assign-left variable\">P_M</span><span class=\"token operator\">=</span>yum\n        <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$DEBIAN</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Ubuntu\"</span> <span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token variable\">$DEBIAN</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"ubutnu\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n                <span class=\"token assign-left variable\">P_M</span><span class=\"token operator\">=</span>apt-get\n        <span class=\"token keyword\">else</span>\n                <span class=\"token builtin class-name\">echo</span><span class=\"token string\">\"Operating system does not support.\"</span>\n                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">#查看登录的用户是否为 root</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$LOGNAME</span> <span class=\"token operator\">!=</span> root <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Please use the root account operation.\"</span>\n        <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#查看是否存在 vmstat 命令</span>\n<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span> <span class=\"token function\">which</span> <span class=\"token function\">vmstat</span> <span class=\"token operator\">&amp;></span>/dev/null<span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"vmstat command not found, now the install.\"</span>\n        <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n        os_check\n        <span class=\"token variable\">$P_M</span> <span class=\"token function\">install</span> procps <span class=\"token parameter variable\">-y</span>\n        <span class=\"token builtin class-name\">echo</span>    <span class=\"token string\">\"-----------------------------------------------------------------\n        ------\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#查看是否有 iostat 命令</span>\n<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span> <span class=\"token function\">which</span> iostat <span class=\"token operator\">&amp;></span>/dev/null<span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"iostat command not found, now the install.\"</span>\n        <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n        os_check\n        <span class=\"token variable\">$P_M</span> <span class=\"token function\">install</span> sysstat <span class=\"token parameter variable\">-y</span>\n        <span class=\"token builtin class-name\">echo</span>   <span class=\"token string\">\"------------------------------------------------------------------\n        -----\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#打印菜单</span>\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">input</span> <span class=\"token keyword\">in</span> cpu_load disk_load disk_use disk_inode mem_use tcp_status cpu_top10 mem_top10 traffic quit<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n                <span class=\"token keyword\">case</span> <span class=\"token variable\">$input</span> <span class=\"token keyword\">in</span>\n                        cpu_load<span class=\"token punctuation\">)</span>\n                                <span class=\"token comment\">#CPU 利用率与负载</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"-----------------------------------------------------\"</span>\n                                <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n                                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[32m 参考值<span class=\"token variable\">$&#123;i&#125;</span><span class=\"token entity\" title=\"\\033\">\\033</span>[0m\"</span>\n                                        <span class=\"token assign-left variable\">UTIL</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print 100-$15\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token assign-left variable\"><span class=\"token environment constant\">USER</span></span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print $13\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token assign-left variable\">SYS</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print $14\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token assign-left variable\">IOWAIT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print $16\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Util: <span class=\"token variable\">$UTIL</span>\"</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"User use: <span class=\"token environment constant\">$USER</span>\"</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"System use: <span class=\"token variable\">$SYS</span>\"</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"I/O wait: <span class=\"token variable\">$IOWAIT</span>\"</span> \n                                        <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token variable\">))</span></span>\n                                        <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n                                <span class=\"token keyword\">done</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"  -------------------------------------------------------\"</span>\n                                <span class=\"token builtin class-name\">break</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                        quit<span class=\"token punctuation\">)</span>\n                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">esac</span>\n        <span class=\"token keyword\">done</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见的系统性能分析工具\"><a href=\"#常见的系统性能分析工具\" class=\"headerlink\" title=\"常见的系统性能分析工具\"></a>常见的系统性能分析工具</h2><ul>\n<li>为什么利用Shell脚本进行系统资源性能分析<ol>\n<li>在系统性能分析中，我们需要收集大量的数据并进行分析，而手动操作比较繁琐且容易出错，而且不易重复。使用shell脚本可以自动化执行这些操作，提高效率和准确性。</li>\n<li>由于shell脚本的灵活性和可编程性，可以根据不同需求和环境对脚本进行维护和扩展，实现各种不同的性能分析操作，可以大大提高工作效率和准确性。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"vmstat\"><a href=\"#vmstat\" class=\"headerlink\" title=\"vmstat\"></a>vmstat</h3><p>vmstat是一个用于Linux系统的性能分析工具，它能够实时地监测CPU、内存、I&#x2F;O、交换分区等系统性能数据，并将这些数据以一定的时间间隔（默认为2秒）输出到终端或日志文件中，提供给用户进行分析和优化。</p>\n<ul>\n<li><p>vmstat输出信息含义：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">r：等待运行的进程数目，即运行队列长度；\nb：处于不可中断状态（blocked）的进程数目；\nswpd：使用虚拟内存的大小，单位为KB；\nfree：空闲物理内存的大小，单位为KB；\nbuff：用作缓存的内存大小，单位为KB；\ncache：用作缓存的页缓存的大小，单位为KB；\nsi：从磁盘交换入的内存大小，单位为KB/s；\nso：向磁盘交换出的内存大小，单位为KB/s；\nbi：从块设备读取的块数，单位为块/s；\nbo：向块设备写入的块数，单位为块/s；\nin：每秒中断数，包括时钟中断；\ncs：每秒上下文切换次数；\nus：用户进程占用CPU时间百分比；\nsy：系统内核占用CPU时间百分比；\nid：CPU空闲时间百分比；\nwa：等待I/O完成时间百分比;\nst：虚拟机占用CPU时间百分比；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看系统的整体性能信息： <code>vmstat</code></p>\n</li>\n<li><p>每隔一段时间查看系统的整体性能信息： <code>vmstat 5 1</code></p>\n</li>\n<li><p>输出带有时间戳的系统整体性能信息： <code>vmstat -t</code></p>\n</li>\n<li><p>显示磁盘信息： <code>vmstat -d</code></p>\n</li>\n<li><p>显示指定的硬盘分区状态： <code>vmstat -p disk part</code></p>\n</li>\n<li><p>修改输出信息的单位： <code>vmstat -S M</code></p>\n</li>\n</ul>\n<h3 id=\"iostat\"><a href=\"#iostat\" class=\"headerlink\" title=\"iostat\"></a>iostat</h3><p>iostat是一个常用的性能分析工具，它可以监测CPU、磁盘、网络等系统资源的使用情况。</p>\n<ul>\n<li><p>输出信息含义：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">rrqm/s：    每秒合并读操作的次数\nwrqm/s：    每秒合并写操作的次数\nr/s：       每秒读操作的次数 （IOPS）\nw/s：       每秒写操作的次数 （IOPS）\nrMB/s：     每秒读带宽\nwMB/s：     每秒写带宽\navgrq-sz：  I/O请求的平均大小（扇区数）\navgqu-sz：  I/O请求队列的平均长度\nawait：     每个I/O平均耗时，单位是ms，这个时间包括I/O在队列中等待耗时，以及最终被磁盘设备处理的时间\nr_await：   每个读操作的平均耗时\nw_await：   每个写操作的平均耗时\n%util：     该磁盘设备的繁忙度，该设备有I/O（即非空闲）的时间比率，不考虑I/O有多少，只考虑有没有。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>iostat常见选项：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-c 表示显示cpu使用情况，默认不写也会显示cpu使用情况\n-d 表示显示磁盘使用情况，默认不写也会显示disk使用情况\n-h  友好显示\n-x 表示显示额外的统计信息\n-k 表示以kb为单位显示磁盘请求数\n-m 表示以M为单位显示磁盘请求数\n-V 显示版本信\n-p  [磁盘] 显示磁盘和分区的情况<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h3><p><code>netstat</code> 是一个用于显示网络连接、路由表、网络接口状态等网络相关信息的命令行工具。它可用于查看当前系统的网络状态、连接情况以及网络性能信息。</p>\n<ul>\n<li><p>常见选项以及含义</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-a</span> <span class=\"token punctuation\">(</span>all<span class=\"token punctuation\">)</span>显示所有选项，默认不显示LISTEN相关\n<span class=\"token parameter variable\">-t</span> <span class=\"token punctuation\">(</span>tcp<span class=\"token punctuation\">)</span>仅显示tcp相关选项\n<span class=\"token parameter variable\">-u</span> <span class=\"token punctuation\">(</span>udp<span class=\"token punctuation\">)</span>仅显示udp相关选项\n<span class=\"token parameter variable\">-n</span> 拒绝显示别名，能显示数字的全部转化成数字。\n<span class=\"token parameter variable\">-l</span> 仅列出有在 Listen <span class=\"token punctuation\">(</span>监听<span class=\"token punctuation\">)</span> 的服務状态\n<span class=\"token parameter variable\">-p</span> 显示建立相关链接的程序名\n<span class=\"token parameter variable\">-r</span> 显示路由信息，路由表\n<span class=\"token parameter variable\">-e</span> 显示扩展信息，例如uid等\n<span class=\"token parameter variable\">-s</span> 按各个协议进行统计\n<span class=\"token parameter variable\">-c</span> 每隔一个固定时间，执行该netstat命令。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>Linux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>\n<ul>\n<li><p>ps命令常用选项</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-A 列出所有的进程\n-w 显示加宽可以显示较多的资讯\n-au 显示较详细的资讯\n-aux 显示所有包含其他使用者的进程<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>ps命令输出字段含义</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">USER: 行程拥有者\nPID: pid\n%CPU: 占用的 CPU 使用率\n%MEM: 占用的记忆体使用率\nVSZ: 占用的虚拟记忆体大小\nRSS: 占用的记忆体大小\nTTY: 终端的次要装置号码 (minor device number of tty)\nSTAT: 该行程的状态:\n\nD: 无法中断的休眠状态 (通常 IO 的进程)\nR: 正在执行中\nS: 静止状态\nT: 暂停执行\nZ: 不存在但暂时无法消除\nW: 没有足够的记忆体分页可分配\n&lt;: 高优先序的行程\nN: 低优先序的行程\nL: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\nSTART: 行程开始时间\nTIME: 执行的时间\nCOMMAND:所执行的指令<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"Shell基础回顾\"><a href=\"#Shell基础回顾\" class=\"headerlink\" title=\"Shell基础回顾\"></a>Shell基础回顾</h2><h3 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h3><ul>\n<li>引用用户变量和环境变量</li>\n<li>命令替换</li>\n<li>从键盘读入赋值</li>\n</ul>\n<h3 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> 函数名 <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span>\n\n函数名<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"if条件测试\"><a href=\"#if条件测试\" class=\"headerlink\" title=\"if条件测试\"></a>if条件测试</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n commands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>condition可以判断三种条件：</p>\n<ol>\n<li><p>文件比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png\" alt=\"3.Shell条件测试-2023-06-16-20-43-25\"></p>\n</li>\n<li><p>字符串比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png\" alt=\"3.Shell条件测试-2023-06-16-20-46-41\"></p>\n</li>\n<li><p>数值比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png\" alt=\"3.Shell条件测试-2023-06-16-21-06-44\"></p>\n</li>\n</ol>\n<ul>\n<li><p>if多条件测试：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> a <span class=\"token operator\">></span> b <span class=\"token punctuation\">))</span></span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span> a <span class=\"token operator\">&lt;</span> c <span class=\"token punctuation\">))</span></span> \n或者\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$a</span> <span class=\"token operator\">></span> <span class=\"token variable\">$b</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$a</span> <span class=\"token operator\">&lt;</span> <span class=\"token variable\">$c</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> \n或者 \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$a</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token variable\">$b</span> <span class=\"token parameter variable\">-a</span> <span class=\"token variable\">$a</span> <span class=\"token parameter variable\">-lt</span> <span class=\"token variable\">$c</span> <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> 条件 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。</p>\n<p>例如，下面的代码中，<code>while</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"当前变量的值是 <span class=\"token variable\">$i</span>\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> 变量名 <span class=\"token keyword\">in</span> 列表\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Shell脚本其他用法\"><a href=\"#Shell脚本其他用法\" class=\"headerlink\" title=\"Shell脚本其他用法\"></a>Shell脚本其他用法</h3><h3 id=\"select-in\"><a href=\"#select-in\" class=\"headerlink\" title=\"select in\"></a>select in</h3><p>select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。</p>\n<p>Shell select in 循环的用法如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">variable</span> <span class=\"token keyword\">in</span> value_list\n<span class=\"token keyword\">do</span>\n    statements\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>实例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"What is your favourite OS?\"</span>\n<span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">name</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"Linux\"</span> <span class=\"token string\">\"Windows\"</span> <span class=\"token string\">\"Mac OS\"</span> <span class=\"token string\">\"UNIX\"</span> <span class=\"token string\">\"Android\"</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$name</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"You have selected <span class=\"token variable\">$name</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>select in 通常和  <code>case in</code> 一起使用，在用户输入不同的编号时可以做出不同的反应。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"What is your favourite OS?\"</span>\n<span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">name</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"Linux\"</span> <span class=\"token string\">\"Windows\"</span> <span class=\"token string\">\"Mac OS\"</span> <span class=\"token string\">\"UNIX\"</span> <span class=\"token string\">\"Android\"</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">case</span> <span class=\"token variable\">$name</span> <span class=\"token keyword\">in</span>\n        <span class=\"token string\">\"Linux\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"Windows\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Windows是微软开发的个人电脑操作系统，它是闭源收费的。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"Mac OS\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"UNIX\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"Android\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。\"</span>\n            <span class=\"token builtin class-name\">break</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        *<span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"输入错误，请重新输入\"</span>\n    <span class=\"token keyword\">esac</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"echo-e\"><a href=\"#echo-e\" class=\"headerlink\" title=\"echo -e\"></a>echo -e</h3><p>在 shell 脚本中，可以使用 <code>echo</code> 命令输出信息，但是默认情况下输出的文本是单色的，可能不够直观。如果要在输出中使用颜色，可以使用 <code>echo -e</code> 命令。</p>\n<p><code>echo -e</code> 可以解析特定的转义序列，其中包括用于设置文本颜色的序列。常用的文本颜色序列如下：</p>\n<ul>\n<li><code>\\033[0m</code>：重置所有属性，包括颜色。</li>\n<li><code>\\033[30m</code> - <code>\\033[37m</code>：设置前景色为黑色到白色。</li>\n<li><code>\\033[40m</code> - <code>\\033[47m</code>：设置背景色为黑色到白色。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[31mThis is red text<span class=\"token entity\" title=\"\\033\">\\033</span>[0m\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"和-区别\"><a href=\"#和-区别\" class=\"headerlink\" title=\"$和${}区别\"></a>$和${}区别</h3><p><code>$</code> 符号后跟变量名，表示对变量进行简单的替换。例如，<code>$var</code> 表示将变量 <code>var</code> 的值替换到命令中或输出中。这种形式适用于大多数简单的变量替换场景。</p>\n<p><code>$&#123;&#125;</code> 是一种更加复杂的语法形式，它可以用于更精确地定义变量扩展的边界。<code>$&#123;&#125;</code> 可以用于以下情况：</p>\n<ol>\n<li>明确指定变量的边界：<code>$&#123;var&#125;</code> 表示变量 <code>var</code> 的边界，可用于区分变量名与紧随其后的字符。这在与其他字符连接时特别有用，例如<code>$&#123;var&#125;name</code>。</li>\n<li>执行变量替换时，<code>$&#123;&#125;</code> 可以使用更复杂的表达式，例如变量的默认值、字符串替换、命令替换等。示例：<code>$&#123;var:-default&#125;</code>、<code>$&#123;var/foo/bar&#125;</code>、<code>$&#123;var//pattern/replacement&#125;</code>。</li>\n</ol>\n<p>下面是一些<code>$&#123;&#125;</code>的用法示例：</p>\n<ul>\n<li>变量替换：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"Alice\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$&#123;name&#125;</span>!\"</span>  <span class=\"token comment\"># 输出：Hello, Alice!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>指定变量边界：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">text</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello,\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;text&#125;</span>world\"</span>  <span class=\"token comment\"># 输出：Hello, !</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>默认值设定：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$&#123;name<span class=\"token operator\">:-</span>Guest&#125;</span>!\"</span>  <span class=\"token comment\"># 输出：Hello, Guest!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>字符串替换：</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">text</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello, world!\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;text<span class=\"token operator\">/</span>world<span class=\"token operator\">/</span>Universe&#125;</span>\"</span>  <span class=\"token comment\"># 输出：Hello, Universe!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><code>$&#123;&#125;</code> 可以根据需要组合和嵌套，用于更复杂的变量操作和替换。它提供了更大的灵活性和精确性，使变量扩展更加强大。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p>Linux sort 命令用于将文本文件内容加以排序。</p>\n<p>sort 可针对文本文件的内容，以行为单位来排序。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-b 忽略每行前面开始出的空格字符。\n-c 检查文件是否已经按照顺序排序。\n-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。\n-f 排序时，将小写字母视为大写字母。\n-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。\n-m 将几个排序好的文件进行合并。\n-M 将前面3个字母依照月份的缩写进行排序。\n-n 依照数值的大小排序。\n-u 意味着是唯一的(unique)，输出的结果是去完重了的。\n-o&lt;输出文件> 将排序后的结果存入指定的文件。\n-r 以相反的顺序来排序。\n-t&lt;分隔字符> 指定排序时所用的栏位分隔字符。\n+&lt;起始栏位>-&lt;结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n--help 显示帮助。\n--version 显示版本信息。\n[-k field1[,field2]] 按指定的列进行排序。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>用法举例</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">##原始文件</span>\n$ <span class=\"token function\">cat</span> testfile      <span class=\"token comment\"># testfile文件原有排序  </span>\n<span class=\"token builtin class-name\">test</span> <span class=\"token number\">30</span>  \nHello <span class=\"token number\">95</span>  \nLinux <span class=\"token number\">85</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  使用sort默认的排序方式</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sort</span> testfile <span class=\"token comment\"># 重排结果  </span>\nHello <span class=\"token number\">95</span>  \nLinux <span class=\"token number\">85</span>  \n<span class=\"token builtin class-name\">test</span> <span class=\"token number\">30</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  使用 -k 参数设置对第二列的值进行重排，结果如下：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sort</span> testfile <span class=\"token parameter variable\">-k</span> <span class=\"token number\">2</span>\n<span class=\"token builtin class-name\">test</span> <span class=\"token number\">30</span>  \nLinux <span class=\"token number\">85</span> \nHello <span class=\"token number\">95</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"awk工具扩展\"><a href=\"#awk工具扩展\" class=\"headerlink\" title=\"awk工具扩展\"></a>awk工具扩展</h2><h3 id=\"awk内的for循环\"><a href=\"#awk内的for循环\" class=\"headerlink\" title=\"awk内的for循环\"></a>awk内的for循环</h3><p>在Awk中，for循环用于迭代执行一系列的操作。Awk中的for循环有两种形式：基于条件的for循环和基于集合的for循环。</p>\n<ol>\n<li><p>基于条件的for循环：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>初始化<span class=\"token punctuation\">;</span> 条件<span class=\"token punctuation\">;</span> 迭代<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\"># 循环体</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p> 初始化在循环开始前执行，条件在每次迭代前进行检查，如果条件为真，则执行循环体，迭代在每次循环体执行完后执行。</p>\n</li>\n<li><p>基于集合的for循环：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>变量 <span class=\"token keyword\">in</span> 集合<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\"># 循环体</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在awk中，数组是一种常用的数据结构，用于存储和操作数据。</p>\n<ol>\n<li>声明数组：使用<code>arrayName[index] = value</code>语法来声明数组，并将指定的索引位置赋值为对应的值。例如：<code>fruits[0] = &quot;apple&quot;</code>。</li>\n<li>访问数组元素：使用<code>arrayName[index]</code>语法来访问数组的特定元素。例如：<code>fruits[0]</code>表示访问数组<code>fruits</code>中索引为0的元素。</li>\n<li>遍历数组：可以使用<code>for (index in arrayName)</code>语法来遍历数组中的所有元素。</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">awk</span> -F: <span class=\"token string\">'&#123;shells[$NF]++&#125; END&#123;for (i in shells)&#123;print i,shells[i]&#125;&#125;'</span> /etc/passwd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"第一节课代码\"><a href=\"#第一节课代码\" class=\"headerlink\" title=\"第一节课代码\"></a>第一节课代码</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\">#</span>\n<span class=\"token function-name function\">os_check</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-e</span> /etc/redhat-release <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n                <span class=\"token assign-left variable\">REDHAT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">cat</span> /etc/redhat-release <span class=\"token operator\">|</span><span class=\"token function\">cut</span> -d<span class=\"token string\">' '</span> <span class=\"token parameter variable\">-f1</span><span class=\"token variable\">`</span></span>\n        <span class=\"token keyword\">else</span>\n                <span class=\"token assign-left variable\">DEBIAN</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">cat</span> /etc/issue <span class=\"token operator\">|</span><span class=\"token function\">cut</span> -d<span class=\"token string\">' '</span> <span class=\"token parameter variable\">-f1</span><span class=\"token variable\">`</span></span>\n        <span class=\"token keyword\">fi</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$REDHAT</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"CentOS\"</span> <span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token variable\">$REDHAT</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Red\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n                <span class=\"token assign-left variable\">P_M</span><span class=\"token operator\">=</span>yum\n        <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$DEBIAN</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Ubuntu\"</span> <span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token variable\">$DEBIAN</span>\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"ubutnu\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n                <span class=\"token assign-left variable\">P_M</span><span class=\"token operator\">=</span>apt-get\n        <span class=\"token keyword\">else</span>\n                <span class=\"token builtin class-name\">echo</span><span class=\"token string\">\"Operating system does not support.\"</span>\n                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">#查看登录的用户是否为 root</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$LOGNAME</span> <span class=\"token operator\">!=</span> root <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Please use the root account operation.\"</span>\n        <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#查看是否存在 vmstat 命令</span>\n<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span> <span class=\"token function\">which</span> <span class=\"token function\">vmstat</span> <span class=\"token operator\">&amp;></span>/dev/null<span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"vmstat command not found, now the install.\"</span>\n        <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n        os_check\n        <span class=\"token variable\">$P_M</span> <span class=\"token function\">install</span> procps <span class=\"token parameter variable\">-y</span>\n        <span class=\"token builtin class-name\">echo</span>    <span class=\"token string\">\"-----------------------------------------------------------------\n        ------\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#查看是否有 iostat 命令</span>\n<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span> <span class=\"token function\">which</span> iostat <span class=\"token operator\">&amp;></span>/dev/null<span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"iostat command not found, now the install.\"</span>\n        <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n        os_check\n        <span class=\"token variable\">$P_M</span> <span class=\"token function\">install</span> sysstat <span class=\"token parameter variable\">-y</span>\n        <span class=\"token builtin class-name\">echo</span>   <span class=\"token string\">\"------------------------------------------------------------------\n        -----\"</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#打印菜单</span>\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">select</span> <span class=\"token for-or-select variable\">input</span> <span class=\"token keyword\">in</span> cpu_load disk_load disk_use disk_inode mem_use tcp_status cpu_top10 mem_top10 traffic quit<span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n                <span class=\"token keyword\">case</span> <span class=\"token variable\">$input</span> <span class=\"token keyword\">in</span>\n                        cpu_load<span class=\"token punctuation\">)</span>\n                                <span class=\"token comment\">#CPU 利用率与负载</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"-----------------------------------------------------\"</span>\n                                <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n                                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[32m 参考值<span class=\"token variable\">$&#123;i&#125;</span><span class=\"token entity\" title=\"\\033\">\\033</span>[0m\"</span>\n                                        <span class=\"token assign-left variable\">UTIL</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print 100-$15\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token assign-left variable\"><span class=\"token environment constant\">USER</span></span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print $13\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token assign-left variable\">SYS</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print $14\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token assign-left variable\">IOWAIT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">vmstat</span> <span class=\"token operator\">|</span><span class=\"token function\">awk</span> <span class=\"token string\">'&#123;if(NR==3)print $16\"%\"&#125;'</span><span class=\"token variable\">`</span></span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Util: <span class=\"token variable\">$UTIL</span>\"</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"User use: <span class=\"token environment constant\">$USER</span>\"</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"System use: <span class=\"token variable\">$SYS</span>\"</span>\n                                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"I/O wait: <span class=\"token variable\">$IOWAIT</span>\"</span> \n                                        <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token variable\">))</span></span>\n                                        <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n                                <span class=\"token keyword\">done</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"  -------------------------------------------------------\"</span>\n                                <span class=\"token builtin class-name\">break</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                        quit<span class=\"token punctuation\">)</span>\n                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">esac</span>\n        <span class=\"token keyword\">done</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"title":"项目实战集","date":"2023-06-16T13:36:20.000Z","_content":"\n## ping命令\n\nLinux ping 命令用于检测主机。\n\n执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\n\n```test\n-d 使用Socket的SO_DEBUG功能。\n-c <完成次数> 设置完成要求回应的次数。\n-f 极限检测。\n-i<间隔秒数> 指定收发信息的间隔时间。\n-I<网络界面> 使用指定的网络接口送出数据包。\n-l<前置载入> 设置在送出要求信息之前，先行发出的数据包。\n-n 只输出数值。\n-p<范本样式> 设置填满数据包的范本样式。\n-q 不显示指令执行过程，开头和结尾的相关信息除外。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-R 记录路由过程。\n-s<数据包大小> 设置数据包的大小。\n-t<存活数值> 设置存活数值TTL的大小。\n-v 详细显示指令的执行过程。\n-w <deadline> 在 deadline 秒后退出。\n```\n\n## 服务器状态检测脚本\n\n使用for循环判断主机是否存活：\n\n```bash\n#!/bin/bash\n\nip_list=\"192.168.1.1 127.0.0.1 0.0.0.0\"\n\nfor ip in $ip_list\ndo\n        for count in {1..3};do\n                ping -c1 -w1 $ip &>/dev/null\n                if [ $? -eq 0 ];then\n                        echo \"$ip ping is ok\"\n                        break\n                fi\n        done\n        if [ $count -eq 3 ];then\n                echo \"$ip ping is failure\"\n        fi\ndone\n```\n\n使用while循环判断主机是否存活：\n\n```bash\n#!/bin/bash\n\n#ip_list=\"192.168.1.1 127.0.0.1 0.0.0.0\"\n\nwhile read ip\ndo\n        count=1\n        while [ $count -le 3 ];do\n                ping -c1 -w1 $ip &>/dev/null\n                if [ $? -eq 0 ];then\n                        echo \"$ip ping is ok\"\n                        break\n                fi\n                count=$(($count+1))\n        done\n        if [ $count -eq 4 ];then\n                echo \"$ip ping is failure\"\n        fi\ndone <ip.txt\n```\n\n## Nginx日志参数\n\n| 变量名称 | 变量描述 | 举例说明 |\n| --- | --- | --- |\n| $remote_addr | 客户端地址 | 113.140.15.90 |\n| $remote_user | 客户端用户名称 | – |\n| $time_local | 访问时间和时区 | 18/Jul/2012:17:00:01 +0800 |\n| $request | 请求的URI和HTTP协议 | “GET /pa/img/home/logo-alipay-t.png HTTP:/1.1″ |\n| $http_host | 请求地址，即浏览器中你输入的地址（IP或域名） | img.alipay.com10.253.70.103 |\n| $status | HTTP请求状态 | 200 |\n| $upstream_status | upstream状态 | 200 |\n| $body_bytes_sent | 发送给客户端文件内容大小 | 547 |\n| $http_referer | 跳转来源 | “<https://cashier.alip/ay.com…/”> |\n| $http_user_agent | 用户终端代理 | “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C; |\n| $ssl_protocol | SSL协议版本 | TLSv1 |\n| $ssl_cipher | 交换数据中的算法 | RC4-SHA |\n| $upstream_addr | 后台upstream的地址，即真正提供服务的主机地址 | 10.228.35.247:80 |\n| $request_time | 整个请求的总时间 | 0.205 |\n| $upstream_response_time | 请求过程中，upstream响应时间 | 0.002 |\n\n## xargs命令\n\n`xargs`是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。\n\n`xargs`可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。\n\n### 常用选项\n\n```bash\n-d <定界符>：指定输入项的定界符，默认为换行符。\n-I <占位符>：指定替代字符串，用于替换命令中的参数位置。\n-n <数量>：指定每次执行的参数数量。\n-t：显示实际执行的命令。\n-p：提示用户确认是否执行命令\n```\n\n### 通过`cat`命令理解`xargs`用法\n\n- 原始文件\n\n    ```sh\n    root@sh:~# cat file.txt\n    file1\n    file2\n    file3\n    ```\n\n- 通过管道符号讲标准输出转换为标准输入传递给cat\n\n    ```sh\n    root@sh:~# cat file.txt|cat\n    file1\n    file2\n    file3\n    ```\n\n- 通过管道符号和xargs将标准输出转换为参数传递给cat\n\n    ```sh\n    root@sh:~# cat file.txt|xargs cat\n    cat: file1: No such file or directory\n    cat: file2: No such file or directory\n    cat: file3: No such file or directory\n    ```\n\n### 常见用法\n\n1. 查找并打包日志\n\n    ```sh\n    find . -name \"*.log\" |xargs tar -cvzf log.tar.gz\n    ```\n\n2. 对日志文件进行文字查找\n\n    ```sh\n    find . -name \"*.log\" |xargs grep -n \"error\"\n    ```\n\n3. 批量创建目录\n\n    ```sh\n    find  /var/log -maxdepth 1 -type d |xargs -I {} mkdir .{}\n    ```\n\n## uniq命令\n\nLinux uniq命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。\n\nuniq命令可检查文本文件中重复出现的行列。\n\n```text\n-c或--count 在每列旁边显示该行重复出现的次数。\n-d或--repeated 仅显示重复出现的行列。\n-f<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。\n-s<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。\n-u或--unique 仅显示出一次的行列。\n-w<字符位置>或--check-chars=<字符位置> 指定要比较的字符。\n--help 显示帮助。\n--version 显示版本信息。\n[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；\n[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）\n```\n\n文本文件包含以下内容：\n\n```text\nCopy code\napple\nbanana\napple\norange\norange\napple\n```\n\n使用`uniq -c`命令来统计重复行的次数：\n\n```sh\n$ uniq -c data.txt\n      1 apple\n      1 banana\n      2 apple\n      2 orange\n      1 apple\n```\n\n输出的每一行都包含两部分：重复行的次数和该行的内容。在上面的示例中，第一行的`apple`只出现了一次，第二行的`banana`只出现了一次，第三行的`apple`出现了两次，以此类推。\n\n## 多机部署MySQL\n\n### 实验环境搭建\n\n1. 配置`centos`虚拟机网络\n\n    ```bash\n    ## 配置ip地址和子网掩码\n    sudo ifconfig [网口名] [ip]/24\n    ## 配置默认网关\n    sudo route add default gw [网关]\n    ping baidu.com\n    ```\n\n2. 本项目通过docker搭建实验环境，首先需要在`centos7`虚拟机中安装`docker`\n运行以下命令使用官方安装脚本自动安装Docker\n\n    ```bash\n    curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n    ```\n\n3. 启动docker服务\n\n    ```bash\n    sudo service docker start\n    ```\n\n4. 通过镜像`linuxserver/openssh-server`创建多个主机\n    1. 创建主机1，默认ssh端口号2222，主机名设置为host1，外部ssh端口号2221\n\n        ```bash\n        sudo docker run -d --name host1\\\n         -e PASSWORD_ACCESS=true \\\n         -e USER_PASSWORD=password \\\n         -e USER_NAME=demo \\\n         -p 2221:2222 lscr.io/linuxserver/openssh-server:latest\n        ```\n\n    2. 创建主机2，默认ssh端口号2222，主机名设置为host2，外部ssh端口号2222\n\n        ```bash\n        sudo docker run -d --name host2 \\\n         -e PASSWORD_ACCESS=true \\\n         -e USER_PASSWORD=password \\\n         -e USER_NAME=demo \\\n         -p 2222:2222 lscr.io/linuxserver/openssh-server:latest\n        ```\n\n    3. 创建主机3，默认ssh端口号2222，主机名设置为host3，外部ssh端口号2223\n\n        ```bash\n        sudo docker run -d --name host3 \\\n         -e PASSWORD_ACCESS=true \\\n         -e USER_PASSWORD=password \\\n         -e USER_NAME=demo \\\n         -p 2223:2222 lscr.io/linuxserver/openssh-server:latest\n        ```\n\n5. 通过`sudo docker ps`查看容器信息\n\n    ![Untitled](%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%9B%86%20b1f29f1f66bb4b5791f43d861b5bb655/Untitled.png)\n\n6. 容器常用命令\n\n    ```sh\n    ## 查看当前运行的容器状态\n    sudo docker ps\n    \n    ## 停止容器\n    sudo docker stop 容器名\n    \n    ## 删除容器\n    sudo docker rm 容器名\n    \n    ## 进入正在运行的容器\n    sudo docker exec -it 容器名 /bin/bash\n    \n    ##从容器中退出\n    exit或者使用快捷键CTRL + p 然后CTRL + q\n    ```\n\n7. 通过`ping -p 2221 localhost`验证centos和容器之间的网络\n8. 通过`ssh -p 2221 demo@localhost`验证ssh服务，使用用户名`demo`和密码`password`登录容器，在容器内使用exit断开ssh连接。\n\n### 推送公钥到各个主机\n\n- ssh密钥登录原理\n\n    我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。\n\n    密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。\n\n1. `ssh-keygen`制作密钥对\n2. `ls ~/.ssh`查看密钥文件\n3. `ssh-copy-id -p 2221 demo@localhost` 推送公钥到目标主机\n4. `ssh -p 2221 demo@localhost`验证密钥登录\n\n### 批量推送公钥\n\n1. centos虚拟机安装expect工具\n\n    ```sh\n    sudo yum install expect\n    ```\n\n    `expect` 是一个用于自动化交互式命令行工具的工具集，它可以用于编写脚本来处理需要与外部程序进行交互的场景。以下是 `expect` 常用的命令和用法：\n\n    1. `spawn`：启动一个新的进程并与其进行交互。\n\n        ```sh\n        spawn ssh user@hostname\n        ```\n\n        上述命令将启动一个 SSH 连接，并与远程主机进行交互。\n\n    2. `expect`：匹配预期的输出或交互，并执行相应的操作。\n\n        ```sh\n        expect \"password:\"\n        send \"mypassword\\r\"\n        ```\n\n        上述命令会等待输出中出现 \"password:\"，然后发送密码。\n\n    3. `send`：向进程发送字符串。\n\n        ```sh\n        send \"ls\\r\"\n        ```\n\n        上述命令会发送 \"ls\" 命令给进程。\n\n2. 批量推送公钥脚本\n\n    ```bash\n    #!/bin/bash\n    \n    port_list=\"2221 2223\"\n    password=\"password\"\n    \n    for i in $port_list\n    do\n            /usr/bin/expect -c \"\n                    spawn ssh-copy-id -p $i demo@localhost\n                    expect {\n                    \\\"*connecting\\\" { send \\\"yes\\r\\\"; exp_continue } }\n                    expect {\n                    \\\"*password\\\" { send \\\"$password\\r\\\"; exp_continue } }\n                    expect eof\n                    \"\n    done\n    \n    ```\n\n### 多机部署MySQL脚本\n\n```bash\n#!/bin/bash\n\nport_list=\"2221 2222 2223\"\npassword=\"password\"\n\nfor i in $port_list\ndo\n        ping -c1 -w1 -p $i localhost\n        if [ $? -eq 0 ];then\n                /usr/bin/expect -c \"\n                spawn ssh -p $i demo@localhost \\\"sudo apk add mysql mysql-client\\\"      \n                expect {\n                \\\"*password\\\" { send \\\"$password\\r\\\";exp_continue}}\n                expect eof\n                \"\n        fi\ndone\n```\n","source":"_posts/linux_shell/12.项目实战集.md","raw":"---\ntitle: 项目实战集\ndate: 2023-06-16 21:36:20\ntags:\n---\n\n## ping命令\n\nLinux ping 命令用于检测主机。\n\n执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\n\n```test\n-d 使用Socket的SO_DEBUG功能。\n-c <完成次数> 设置完成要求回应的次数。\n-f 极限检测。\n-i<间隔秒数> 指定收发信息的间隔时间。\n-I<网络界面> 使用指定的网络接口送出数据包。\n-l<前置载入> 设置在送出要求信息之前，先行发出的数据包。\n-n 只输出数值。\n-p<范本样式> 设置填满数据包的范本样式。\n-q 不显示指令执行过程，开头和结尾的相关信息除外。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-R 记录路由过程。\n-s<数据包大小> 设置数据包的大小。\n-t<存活数值> 设置存活数值TTL的大小。\n-v 详细显示指令的执行过程。\n-w <deadline> 在 deadline 秒后退出。\n```\n\n## 服务器状态检测脚本\n\n使用for循环判断主机是否存活：\n\n```bash\n#!/bin/bash\n\nip_list=\"192.168.1.1 127.0.0.1 0.0.0.0\"\n\nfor ip in $ip_list\ndo\n        for count in {1..3};do\n                ping -c1 -w1 $ip &>/dev/null\n                if [ $? -eq 0 ];then\n                        echo \"$ip ping is ok\"\n                        break\n                fi\n        done\n        if [ $count -eq 3 ];then\n                echo \"$ip ping is failure\"\n        fi\ndone\n```\n\n使用while循环判断主机是否存活：\n\n```bash\n#!/bin/bash\n\n#ip_list=\"192.168.1.1 127.0.0.1 0.0.0.0\"\n\nwhile read ip\ndo\n        count=1\n        while [ $count -le 3 ];do\n                ping -c1 -w1 $ip &>/dev/null\n                if [ $? -eq 0 ];then\n                        echo \"$ip ping is ok\"\n                        break\n                fi\n                count=$(($count+1))\n        done\n        if [ $count -eq 4 ];then\n                echo \"$ip ping is failure\"\n        fi\ndone <ip.txt\n```\n\n## Nginx日志参数\n\n| 变量名称 | 变量描述 | 举例说明 |\n| --- | --- | --- |\n| $remote_addr | 客户端地址 | 113.140.15.90 |\n| $remote_user | 客户端用户名称 | – |\n| $time_local | 访问时间和时区 | 18/Jul/2012:17:00:01 +0800 |\n| $request | 请求的URI和HTTP协议 | “GET /pa/img/home/logo-alipay-t.png HTTP:/1.1″ |\n| $http_host | 请求地址，即浏览器中你输入的地址（IP或域名） | img.alipay.com10.253.70.103 |\n| $status | HTTP请求状态 | 200 |\n| $upstream_status | upstream状态 | 200 |\n| $body_bytes_sent | 发送给客户端文件内容大小 | 547 |\n| $http_referer | 跳转来源 | “<https://cashier.alip/ay.com…/”> |\n| $http_user_agent | 用户终端代理 | “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C; |\n| $ssl_protocol | SSL协议版本 | TLSv1 |\n| $ssl_cipher | 交换数据中的算法 | RC4-SHA |\n| $upstream_addr | 后台upstream的地址，即真正提供服务的主机地址 | 10.228.35.247:80 |\n| $request_time | 整个请求的总时间 | 0.205 |\n| $upstream_response_time | 请求过程中，upstream响应时间 | 0.002 |\n\n## xargs命令\n\n`xargs`是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。\n\n`xargs`可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。\n\n### 常用选项\n\n```bash\n-d <定界符>：指定输入项的定界符，默认为换行符。\n-I <占位符>：指定替代字符串，用于替换命令中的参数位置。\n-n <数量>：指定每次执行的参数数量。\n-t：显示实际执行的命令。\n-p：提示用户确认是否执行命令\n```\n\n### 通过`cat`命令理解`xargs`用法\n\n- 原始文件\n\n    ```sh\n    root@sh:~# cat file.txt\n    file1\n    file2\n    file3\n    ```\n\n- 通过管道符号讲标准输出转换为标准输入传递给cat\n\n    ```sh\n    root@sh:~# cat file.txt|cat\n    file1\n    file2\n    file3\n    ```\n\n- 通过管道符号和xargs将标准输出转换为参数传递给cat\n\n    ```sh\n    root@sh:~# cat file.txt|xargs cat\n    cat: file1: No such file or directory\n    cat: file2: No such file or directory\n    cat: file3: No such file or directory\n    ```\n\n### 常见用法\n\n1. 查找并打包日志\n\n    ```sh\n    find . -name \"*.log\" |xargs tar -cvzf log.tar.gz\n    ```\n\n2. 对日志文件进行文字查找\n\n    ```sh\n    find . -name \"*.log\" |xargs grep -n \"error\"\n    ```\n\n3. 批量创建目录\n\n    ```sh\n    find  /var/log -maxdepth 1 -type d |xargs -I {} mkdir .{}\n    ```\n\n## uniq命令\n\nLinux uniq命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。\n\nuniq命令可检查文本文件中重复出现的行列。\n\n```text\n-c或--count 在每列旁边显示该行重复出现的次数。\n-d或--repeated 仅显示重复出现的行列。\n-f<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。\n-s<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。\n-u或--unique 仅显示出一次的行列。\n-w<字符位置>或--check-chars=<字符位置> 指定要比较的字符。\n--help 显示帮助。\n--version 显示版本信息。\n[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；\n[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）\n```\n\n文本文件包含以下内容：\n\n```text\nCopy code\napple\nbanana\napple\norange\norange\napple\n```\n\n使用`uniq -c`命令来统计重复行的次数：\n\n```sh\n$ uniq -c data.txt\n      1 apple\n      1 banana\n      2 apple\n      2 orange\n      1 apple\n```\n\n输出的每一行都包含两部分：重复行的次数和该行的内容。在上面的示例中，第一行的`apple`只出现了一次，第二行的`banana`只出现了一次，第三行的`apple`出现了两次，以此类推。\n\n## 多机部署MySQL\n\n### 实验环境搭建\n\n1. 配置`centos`虚拟机网络\n\n    ```bash\n    ## 配置ip地址和子网掩码\n    sudo ifconfig [网口名] [ip]/24\n    ## 配置默认网关\n    sudo route add default gw [网关]\n    ping baidu.com\n    ```\n\n2. 本项目通过docker搭建实验环境，首先需要在`centos7`虚拟机中安装`docker`\n运行以下命令使用官方安装脚本自动安装Docker\n\n    ```bash\n    curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n    ```\n\n3. 启动docker服务\n\n    ```bash\n    sudo service docker start\n    ```\n\n4. 通过镜像`linuxserver/openssh-server`创建多个主机\n    1. 创建主机1，默认ssh端口号2222，主机名设置为host1，外部ssh端口号2221\n\n        ```bash\n        sudo docker run -d --name host1\\\n         -e PASSWORD_ACCESS=true \\\n         -e USER_PASSWORD=password \\\n         -e USER_NAME=demo \\\n         -p 2221:2222 lscr.io/linuxserver/openssh-server:latest\n        ```\n\n    2. 创建主机2，默认ssh端口号2222，主机名设置为host2，外部ssh端口号2222\n\n        ```bash\n        sudo docker run -d --name host2 \\\n         -e PASSWORD_ACCESS=true \\\n         -e USER_PASSWORD=password \\\n         -e USER_NAME=demo \\\n         -p 2222:2222 lscr.io/linuxserver/openssh-server:latest\n        ```\n\n    3. 创建主机3，默认ssh端口号2222，主机名设置为host3，外部ssh端口号2223\n\n        ```bash\n        sudo docker run -d --name host3 \\\n         -e PASSWORD_ACCESS=true \\\n         -e USER_PASSWORD=password \\\n         -e USER_NAME=demo \\\n         -p 2223:2222 lscr.io/linuxserver/openssh-server:latest\n        ```\n\n5. 通过`sudo docker ps`查看容器信息\n\n    ![Untitled](%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%9B%86%20b1f29f1f66bb4b5791f43d861b5bb655/Untitled.png)\n\n6. 容器常用命令\n\n    ```sh\n    ## 查看当前运行的容器状态\n    sudo docker ps\n    \n    ## 停止容器\n    sudo docker stop 容器名\n    \n    ## 删除容器\n    sudo docker rm 容器名\n    \n    ## 进入正在运行的容器\n    sudo docker exec -it 容器名 /bin/bash\n    \n    ##从容器中退出\n    exit或者使用快捷键CTRL + p 然后CTRL + q\n    ```\n\n7. 通过`ping -p 2221 localhost`验证centos和容器之间的网络\n8. 通过`ssh -p 2221 demo@localhost`验证ssh服务，使用用户名`demo`和密码`password`登录容器，在容器内使用exit断开ssh连接。\n\n### 推送公钥到各个主机\n\n- ssh密钥登录原理\n\n    我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。\n\n    密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。\n\n1. `ssh-keygen`制作密钥对\n2. `ls ~/.ssh`查看密钥文件\n3. `ssh-copy-id -p 2221 demo@localhost` 推送公钥到目标主机\n4. `ssh -p 2221 demo@localhost`验证密钥登录\n\n### 批量推送公钥\n\n1. centos虚拟机安装expect工具\n\n    ```sh\n    sudo yum install expect\n    ```\n\n    `expect` 是一个用于自动化交互式命令行工具的工具集，它可以用于编写脚本来处理需要与外部程序进行交互的场景。以下是 `expect` 常用的命令和用法：\n\n    1. `spawn`：启动一个新的进程并与其进行交互。\n\n        ```sh\n        spawn ssh user@hostname\n        ```\n\n        上述命令将启动一个 SSH 连接，并与远程主机进行交互。\n\n    2. `expect`：匹配预期的输出或交互，并执行相应的操作。\n\n        ```sh\n        expect \"password:\"\n        send \"mypassword\\r\"\n        ```\n\n        上述命令会等待输出中出现 \"password:\"，然后发送密码。\n\n    3. `send`：向进程发送字符串。\n\n        ```sh\n        send \"ls\\r\"\n        ```\n\n        上述命令会发送 \"ls\" 命令给进程。\n\n2. 批量推送公钥脚本\n\n    ```bash\n    #!/bin/bash\n    \n    port_list=\"2221 2223\"\n    password=\"password\"\n    \n    for i in $port_list\n    do\n            /usr/bin/expect -c \"\n                    spawn ssh-copy-id -p $i demo@localhost\n                    expect {\n                    \\\"*connecting\\\" { send \\\"yes\\r\\\"; exp_continue } }\n                    expect {\n                    \\\"*password\\\" { send \\\"$password\\r\\\"; exp_continue } }\n                    expect eof\n                    \"\n    done\n    \n    ```\n\n### 多机部署MySQL脚本\n\n```bash\n#!/bin/bash\n\nport_list=\"2221 2222 2223\"\npassword=\"password\"\n\nfor i in $port_list\ndo\n        ping -c1 -w1 -p $i localhost\n        if [ $? -eq 0 ];then\n                /usr/bin/expect -c \"\n                spawn ssh -p $i demo@localhost \\\"sudo apk add mysql mysql-client\\\"      \n                expect {\n                \\\"*password\\\" { send \\\"$password\\r\\\";exp_continue}}\n                expect eof\n                \"\n        fi\ndone\n```\n","slug":"linux_shell/12.项目实战集","published":1,"updated":"2023-06-27T14:04:29.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04i00081dnzb6310wn0","content":"<h2 id=\"ping命令\"><a href=\"#ping命令\" class=\"headerlink\" title=\"ping命令\"></a>ping命令</h2><p>Linux ping 命令用于检测主机。</p>\n<p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>\n<pre class=\"line-numbers language-test\" data-language=\"test\"><code class=\"language-test\">-d 使用Socket的SO_DEBUG功能。\n-c &lt;完成次数&gt; 设置完成要求回应的次数。\n-f 极限检测。\n-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。\n-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。\n-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。\n-n 只输出数值。\n-p&lt;范本样式&gt; 设置填满数据包的范本样式。\n-q 不显示指令执行过程，开头和结尾的相关信息除外。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-R 记录路由过程。\n-s&lt;数据包大小&gt; 设置数据包的大小。\n-t&lt;存活数值&gt; 设置存活数值TTL的大小。\n-v 详细显示指令的执行过程。\n-w &lt;deadline&gt; 在 deadline 秒后退出。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"服务器状态检测脚本\"><a href=\"#服务器状态检测脚本\" class=\"headerlink\" title=\"服务器状态检测脚本\"></a>服务器状态检测脚本</h2><p>使用for循环判断主机是否存活：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">ip_list</span><span class=\"token operator\">=</span><span class=\"token string\">\"192.168.1.1 127.0.0.1 0.0.0.0\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">ip</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$ip_list</span>\n<span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">count</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">do</span>\n                <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-w1</span> <span class=\"token variable\">$ip</span> <span class=\"token operator\">&amp;></span>/dev/null\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is ok\"</span>\n                        <span class=\"token builtin class-name\">break</span>\n                <span class=\"token keyword\">fi</span>\n        <span class=\"token keyword\">done</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is failure\"</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用while循环判断主机是否存活：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\">#ip_list=\"192.168.1.1 127.0.0.1 0.0.0.0\"</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> <span class=\"token function\">ip</span>\n<span class=\"token keyword\">do</span>\n        <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">do</span>\n                <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-w1</span> <span class=\"token variable\">$ip</span> <span class=\"token operator\">&amp;></span>/dev/null\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is ok\"</span>\n                        <span class=\"token builtin class-name\">break</span>\n                <span class=\"token keyword\">fi</span>\n                <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$count<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token variable\">))</span></span>\n        <span class=\"token keyword\">done</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is failure\"</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span> <span class=\"token operator\">&lt;</span>ip.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Nginx日志参数\"><a href=\"#Nginx日志参数\" class=\"headerlink\" title=\"Nginx日志参数\"></a>Nginx日志参数</h2><table>\n<thead>\n<tr>\n<th>变量名称</th>\n<th>变量描述</th>\n<th>举例说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$remote_addr</td>\n<td>客户端地址</td>\n<td>113.140.15.90</td>\n</tr>\n<tr>\n<td>$remote_user</td>\n<td>客户端用户名称</td>\n<td>–</td>\n</tr>\n<tr>\n<td>$time_local</td>\n<td>访问时间和时区</td>\n<td>18&#x2F;Jul&#x2F;2012:17:00:01 +0800</td>\n</tr>\n<tr>\n<td>$request</td>\n<td>请求的URI和HTTP协议</td>\n<td>“GET &#x2F;pa&#x2F;img&#x2F;home&#x2F;logo-alipay-t.png HTTP:&#x2F;1.1″</td>\n</tr>\n<tr>\n<td>$http_host</td>\n<td>请求地址，即浏览器中你输入的地址（IP或域名）</td>\n<td>img.alipay.com10.253.70.103</td>\n</tr>\n<tr>\n<td>$status</td>\n<td>HTTP请求状态</td>\n<td>200</td>\n</tr>\n<tr>\n<td>$upstream_status</td>\n<td>upstream状态</td>\n<td>200</td>\n</tr>\n<tr>\n<td>$body_bytes_sent</td>\n<td>发送给客户端文件内容大小</td>\n<td>547</td>\n</tr>\n<tr>\n<td>$http_referer</td>\n<td>跳转来源</td>\n<td>“<a href=\"https://cashier.alip/ay.com%E2%80%A6/%E2%80%9D\">https://cashier.alip/ay.com…/”</a></td>\n</tr>\n<tr>\n<td>$http_user_agent</td>\n<td>用户终端代理</td>\n<td>“Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.0C;</td>\n</tr>\n<tr>\n<td>$ssl_protocol</td>\n<td>SSL协议版本</td>\n<td>TLSv1</td>\n</tr>\n<tr>\n<td>$ssl_cipher</td>\n<td>交换数据中的算法</td>\n<td>RC4-SHA</td>\n</tr>\n<tr>\n<td>$upstream_addr</td>\n<td>后台upstream的地址，即真正提供服务的主机地址</td>\n<td>10.228.35.247:80</td>\n</tr>\n<tr>\n<td>$request_time</td>\n<td>整个请求的总时间</td>\n<td>0.205</td>\n</tr>\n<tr>\n<td>$upstream_response_time</td>\n<td>请求过程中，upstream响应时间</td>\n<td>0.002</td>\n</tr>\n</tbody></table>\n<h2 id=\"xargs命令\"><a href=\"#xargs命令\" class=\"headerlink\" title=\"xargs命令\"></a>xargs命令</h2><p><code>xargs</code>是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>\n<p><code>xargs</code>可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p>\n<h3 id=\"常用选项\"><a href=\"#常用选项\" class=\"headerlink\" title=\"常用选项\"></a>常用选项</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>定界符<span class=\"token operator\">></span>：指定输入项的定界符，默认为换行符。\n<span class=\"token parameter variable\">-I</span> <span class=\"token operator\">&lt;</span>占位符<span class=\"token operator\">></span>：指定替代字符串，用于替换命令中的参数位置。\n<span class=\"token parameter variable\">-n</span> <span class=\"token operator\">&lt;</span>数量<span class=\"token operator\">></span>：指定每次执行的参数数量。\n-t：显示实际执行的命令。\n-p：提示用户确认是否执行命令<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"通过cat命令理解xargs用法\"><a href=\"#通过cat命令理解xargs用法\" class=\"headerlink\" title=\"通过cat命令理解xargs用法\"></a>通过<code>cat</code>命令理解<code>xargs</code>用法</h3><ul>\n<li><p>原始文件</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@sh:~<span class=\"token comment\"># cat file.txt</span>\nfile1\nfile2\nfile3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过管道符号讲标准输出转换为标准输入传递给cat</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@sh:~<span class=\"token comment\"># cat file.txt|cat</span>\nfile1\nfile2\nfile3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过管道符号和xargs将标准输出转换为参数传递给cat</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@sh:~<span class=\"token comment\"># cat file.txt|xargs cat</span>\ncat: file1: No such <span class=\"token function\">file</span> or directory\ncat: file2: No such <span class=\"token function\">file</span> or directory\ncat: file3: No such <span class=\"token function\">file</span> or directory<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h3><ol>\n<li><p>查找并打包日志</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token operator\">|</span><span class=\"token function\">xargs</span> <span class=\"token function\">tar</span> <span class=\"token parameter variable\">-cvzf</span> log.tar.gz<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>对日志文件进行文字查找</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token operator\">|</span><span class=\"token function\">xargs</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"error\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>批量创建目录</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span>  /var/log <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">1</span> <span class=\"token parameter variable\">-type</span> d <span class=\"token operator\">|</span><span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token function\">mkdir</span> .<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"uniq命令\"><a href=\"#uniq命令\" class=\"headerlink\" title=\"uniq命令\"></a>uniq命令</h2><p>Linux uniq命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p>\n<p>uniq命令可检查文本文件中重复出现的行列。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-c或--count 在每列旁边显示该行重复出现的次数。\n-d或--repeated 仅显示重复出现的行列。\n-f&lt;栏位>或--skip-fields=&lt;栏位> 忽略比较指定的栏位。\n-s&lt;字符位置>或--skip-chars=&lt;字符位置> 忽略比较指定的字符。\n-u或--unique 仅显示出一次的行列。\n-w&lt;字符位置>或--check-chars=&lt;字符位置> 指定要比较的字符。\n--help 显示帮助。\n--version 显示版本信息。\n[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；\n[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>文本文件包含以下内容：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Copy code\napple\nbanana\napple\norange\norange\napple<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>uniq -c</code>命令来统计重复行的次数：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">uniq</span> <span class=\"token parameter variable\">-c</span> data.txt\n      <span class=\"token number\">1</span> apple\n      <span class=\"token number\">1</span> banana\n      <span class=\"token number\">2</span> apple\n      <span class=\"token number\">2</span> orange\n      <span class=\"token number\">1</span> apple<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出的每一行都包含两部分：重复行的次数和该行的内容。在上面的示例中，第一行的<code>apple</code>只出现了一次，第二行的<code>banana</code>只出现了一次，第三行的<code>apple</code>出现了两次，以此类推。</p>\n<h2 id=\"多机部署MySQL\"><a href=\"#多机部署MySQL\" class=\"headerlink\" title=\"多机部署MySQL\"></a>多机部署MySQL</h2><h3 id=\"实验环境搭建\"><a href=\"#实验环境搭建\" class=\"headerlink\" title=\"实验环境搭建\"></a>实验环境搭建</h3><ol>\n<li><p>配置<code>centos</code>虚拟机网络</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## 配置ip地址和子网掩码</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">ifconfig</span> <span class=\"token punctuation\">[</span>网口名<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>ip<span class=\"token punctuation\">]</span>/24\n<span class=\"token comment\">## 配置默认网关</span>\n<span class=\"token function\">sudo</span> route <span class=\"token function\">add</span> default gw <span class=\"token punctuation\">[</span>网关<span class=\"token punctuation\">]</span>\n<span class=\"token function\">ping</span> baidu.com<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>本项目通过docker搭建实验环境，首先需要在<code>centos7</code>虚拟机中安装<code>docker</code><br>运行以下命令使用官方安装脚本自动安装Docker</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://get.docker.com <span class=\"token operator\">|</span> <span class=\"token function\">bash</span> <span class=\"token parameter variable\">-s</span> <span class=\"token function\">docker</span> <span class=\"token parameter variable\">--mirror</span> Aliyun<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>启动docker服务</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">service</span> <span class=\"token function\">docker</span> start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>通过镜像<code>linuxserver/openssh-server</code>创建多个主机</p>\n<ol>\n<li><p>创建主机1，默认ssh端口号2222，主机名设置为host1，外部ssh端口号2221</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> host1<span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PASSWORD_ACCESS</span><span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_PASSWORD</span><span class=\"token operator\">=</span>password <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_NAME</span><span class=\"token operator\">=</span>demo <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-p</span> <span class=\"token number\">2221</span>:2222 lscr.io/linuxserver/openssh-server:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建主机2，默认ssh端口号2222，主机名设置为host2，外部ssh端口号2222</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> host2 <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PASSWORD_ACCESS</span><span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_PASSWORD</span><span class=\"token operator\">=</span>password <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_NAME</span><span class=\"token operator\">=</span>demo <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-p</span> <span class=\"token number\">2222</span>:2222 lscr.io/linuxserver/openssh-server:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建主机3，默认ssh端口号2222，主机名设置为host3，外部ssh端口号2223</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> host3 <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PASSWORD_ACCESS</span><span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_PASSWORD</span><span class=\"token operator\">=</span>password <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_NAME</span><span class=\"token operator\">=</span>demo <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-p</span> <span class=\"token number\">2223</span>:2222 lscr.io/linuxserver/openssh-server:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p>通过<code>sudo docker ps</code>查看容器信息</p>\n<p> <img src=\"/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%9B%86%20b1f29f1f66bb4b5791f43d861b5bb655/Untitled.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>容器常用命令</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## 查看当前运行的容器状态</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">ps</span>\n\n<span class=\"token comment\">## 停止容器</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> stop 容器名\n\n<span class=\"token comment\">## 删除容器</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">rm</span> 容器名\n\n<span class=\"token comment\">## 进入正在运行的容器</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> 容器名 /bin/bash\n\n<span class=\"token comment\">##从容器中退出</span>\nexit或者使用快捷键CTRL + p 然后CTRL + q<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过<code>ping -p 2221 localhost</code>验证centos和容器之间的网络</p>\n</li>\n<li><p>通过<code>ssh -p 2221 demo@localhost</code>验证ssh服务，使用用户名<code>demo</code>和密码<code>password</code>登录容器，在容器内使用exit断开ssh连接。</p>\n</li>\n</ol>\n<h3 id=\"推送公钥到各个主机\"><a href=\"#推送公钥到各个主机\" class=\"headerlink\" title=\"推送公钥到各个主机\"></a>推送公钥到各个主机</h3><ul>\n<li><p>ssh密钥登录原理</p>\n<p>  我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p>\n<p>  密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。</p>\n</li>\n</ul>\n<ol>\n<li><code>ssh-keygen</code>制作密钥对</li>\n<li><code>ls ~/.ssh</code>查看密钥文件</li>\n<li><code>ssh-copy-id -p 2221 demo@localhost</code> 推送公钥到目标主机</li>\n<li><code>ssh -p 2221 demo@localhost</code>验证密钥登录</li>\n</ol>\n<h3 id=\"批量推送公钥\"><a href=\"#批量推送公钥\" class=\"headerlink\" title=\"批量推送公钥\"></a>批量推送公钥</h3><ol>\n<li><p>centos虚拟机安装expect工具</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> <span class=\"token function\">expect</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> <code>expect</code> 是一个用于自动化交互式命令行工具的工具集，它可以用于编写脚本来处理需要与外部程序进行交互的场景。以下是 <code>expect</code> 常用的命令和用法：</p>\n<ol>\n<li><p><code>spawn</code>：启动一个新的进程并与其进行交互。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">spawn <span class=\"token function\">ssh</span> user@hostname<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 上述命令将启动一个 SSH 连接，并与远程主机进行交互。</p>\n</li>\n<li><p><code>expect</code>：匹配预期的输出或交互，并执行相应的操作。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">expect</span> <span class=\"token string\">\"password:\"</span>\nsend <span class=\"token string\">\"mypassword<span class=\"token entity\" title=\"\\r\">\\r</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p> 上述命令会等待输出中出现 “password:”，然后发送密码。</p>\n</li>\n<li><p><code>send</code>：向进程发送字符串。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">send <span class=\"token string\">\"ls<span class=\"token entity\" title=\"\\r\">\\r</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 上述命令会发送 “ls” 命令给进程。</p>\n</li>\n</ol>\n</li>\n<li><p>批量推送公钥脚本</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">port_list</span><span class=\"token operator\">=</span><span class=\"token string\">\"2221 2223\"</span>\n<span class=\"token assign-left variable\">password</span><span class=\"token operator\">=</span><span class=\"token string\">\"password\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$port_list</span>\n<span class=\"token keyword\">do</span>\n        /usr/bin/expect <span class=\"token parameter variable\">-c</span> <span class=\"token string\">\"\n                spawn ssh-copy-id -p <span class=\"token variable\">$i</span> demo@localhost\n                expect &#123;\n                <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>*connecting<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &#123; send <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>yes<span class=\"token entity\" title=\"\\r\">\\r</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>; exp_continue &#125; &#125;\n                expect &#123;\n                <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>*password<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &#123; send <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$password</span><span class=\"token entity\" title=\"\\r\">\\r</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>; exp_continue &#125; &#125;\n                expect eof\n                \"</span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"多机部署MySQL脚本\"><a href=\"#多机部署MySQL脚本\" class=\"headerlink\" title=\"多机部署MySQL脚本\"></a>多机部署MySQL脚本</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">port_list</span><span class=\"token operator\">=</span><span class=\"token string\">\"2221 2222 2223\"</span>\n<span class=\"token assign-left variable\">password</span><span class=\"token operator\">=</span><span class=\"token string\">\"password\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$port_list</span>\n<span class=\"token keyword\">do</span>\n        <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-w1</span> <span class=\"token parameter variable\">-p</span> <span class=\"token variable\">$i</span> localhost\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                /usr/bin/expect <span class=\"token parameter variable\">-c</span> <span class=\"token string\">\"\n                spawn ssh -p <span class=\"token variable\">$i</span> demo@localhost <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>sudo apk add mysql mysql-client<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>      \n                expect &#123;\n                <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>*password<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &#123; send <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$password</span><span class=\"token entity\" title=\"\\r\">\\r</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>;exp_continue&#125;&#125;\n                expect eof\n                \"</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ping命令\"><a href=\"#ping命令\" class=\"headerlink\" title=\"ping命令\"></a>ping命令</h2><p>Linux ping 命令用于检测主机。</p>\n<p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>\n<pre class=\"line-numbers language-test\" data-language=\"test\"><code class=\"language-test\">-d 使用Socket的SO_DEBUG功能。\n-c &lt;完成次数&gt; 设置完成要求回应的次数。\n-f 极限检测。\n-i&lt;间隔秒数&gt; 指定收发信息的间隔时间。\n-I&lt;网络界面&gt; 使用指定的网络接口送出数据包。\n-l&lt;前置载入&gt; 设置在送出要求信息之前，先行发出的数据包。\n-n 只输出数值。\n-p&lt;范本样式&gt; 设置填满数据包的范本样式。\n-q 不显示指令执行过程，开头和结尾的相关信息除外。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-R 记录路由过程。\n-s&lt;数据包大小&gt; 设置数据包的大小。\n-t&lt;存活数值&gt; 设置存活数值TTL的大小。\n-v 详细显示指令的执行过程。\n-w &lt;deadline&gt; 在 deadline 秒后退出。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"服务器状态检测脚本\"><a href=\"#服务器状态检测脚本\" class=\"headerlink\" title=\"服务器状态检测脚本\"></a>服务器状态检测脚本</h2><p>使用for循环判断主机是否存活：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">ip_list</span><span class=\"token operator\">=</span><span class=\"token string\">\"192.168.1.1 127.0.0.1 0.0.0.0\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">ip</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$ip_list</span>\n<span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">count</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">do</span>\n                <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-w1</span> <span class=\"token variable\">$ip</span> <span class=\"token operator\">&amp;></span>/dev/null\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is ok\"</span>\n                        <span class=\"token builtin class-name\">break</span>\n                <span class=\"token keyword\">fi</span>\n        <span class=\"token keyword\">done</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is failure\"</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用while循环判断主机是否存活：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\">#ip_list=\"192.168.1.1 127.0.0.1 0.0.0.0\"</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> <span class=\"token function\">ip</span>\n<span class=\"token keyword\">do</span>\n        <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">do</span>\n                <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-w1</span> <span class=\"token variable\">$ip</span> <span class=\"token operator\">&amp;></span>/dev/null\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is ok\"</span>\n                        <span class=\"token builtin class-name\">break</span>\n                <span class=\"token keyword\">fi</span>\n                <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$count<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token variable\">))</span></span>\n        <span class=\"token keyword\">done</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span> ping is failure\"</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span> <span class=\"token operator\">&lt;</span>ip.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Nginx日志参数\"><a href=\"#Nginx日志参数\" class=\"headerlink\" title=\"Nginx日志参数\"></a>Nginx日志参数</h2><table>\n<thead>\n<tr>\n<th>变量名称</th>\n<th>变量描述</th>\n<th>举例说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$remote_addr</td>\n<td>客户端地址</td>\n<td>113.140.15.90</td>\n</tr>\n<tr>\n<td>$remote_user</td>\n<td>客户端用户名称</td>\n<td>–</td>\n</tr>\n<tr>\n<td>$time_local</td>\n<td>访问时间和时区</td>\n<td>18&#x2F;Jul&#x2F;2012:17:00:01 +0800</td>\n</tr>\n<tr>\n<td>$request</td>\n<td>请求的URI和HTTP协议</td>\n<td>“GET &#x2F;pa&#x2F;img&#x2F;home&#x2F;logo-alipay-t.png HTTP:&#x2F;1.1″</td>\n</tr>\n<tr>\n<td>$http_host</td>\n<td>请求地址，即浏览器中你输入的地址（IP或域名）</td>\n<td>img.alipay.com10.253.70.103</td>\n</tr>\n<tr>\n<td>$status</td>\n<td>HTTP请求状态</td>\n<td>200</td>\n</tr>\n<tr>\n<td>$upstream_status</td>\n<td>upstream状态</td>\n<td>200</td>\n</tr>\n<tr>\n<td>$body_bytes_sent</td>\n<td>发送给客户端文件内容大小</td>\n<td>547</td>\n</tr>\n<tr>\n<td>$http_referer</td>\n<td>跳转来源</td>\n<td>“<a href=\"https://cashier.alip/ay.com%E2%80%A6/%E2%80%9D\">https://cashier.alip/ay.com…/”</a></td>\n</tr>\n<tr>\n<td>$http_user_agent</td>\n<td>用户终端代理</td>\n<td>“Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; SV1; GTB7.0; .NET4.0C;</td>\n</tr>\n<tr>\n<td>$ssl_protocol</td>\n<td>SSL协议版本</td>\n<td>TLSv1</td>\n</tr>\n<tr>\n<td>$ssl_cipher</td>\n<td>交换数据中的算法</td>\n<td>RC4-SHA</td>\n</tr>\n<tr>\n<td>$upstream_addr</td>\n<td>后台upstream的地址，即真正提供服务的主机地址</td>\n<td>10.228.35.247:80</td>\n</tr>\n<tr>\n<td>$request_time</td>\n<td>整个请求的总时间</td>\n<td>0.205</td>\n</tr>\n<tr>\n<td>$upstream_response_time</td>\n<td>请求过程中，upstream响应时间</td>\n<td>0.002</td>\n</tr>\n</tbody></table>\n<h2 id=\"xargs命令\"><a href=\"#xargs命令\" class=\"headerlink\" title=\"xargs命令\"></a>xargs命令</h2><p><code>xargs</code>是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>\n<p><code>xargs</code>可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p>\n<h3 id=\"常用选项\"><a href=\"#常用选项\" class=\"headerlink\" title=\"常用选项\"></a>常用选项</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-d</span> <span class=\"token operator\">&lt;</span>定界符<span class=\"token operator\">></span>：指定输入项的定界符，默认为换行符。\n<span class=\"token parameter variable\">-I</span> <span class=\"token operator\">&lt;</span>占位符<span class=\"token operator\">></span>：指定替代字符串，用于替换命令中的参数位置。\n<span class=\"token parameter variable\">-n</span> <span class=\"token operator\">&lt;</span>数量<span class=\"token operator\">></span>：指定每次执行的参数数量。\n-t：显示实际执行的命令。\n-p：提示用户确认是否执行命令<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"通过cat命令理解xargs用法\"><a href=\"#通过cat命令理解xargs用法\" class=\"headerlink\" title=\"通过cat命令理解xargs用法\"></a>通过<code>cat</code>命令理解<code>xargs</code>用法</h3><ul>\n<li><p>原始文件</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@sh:~<span class=\"token comment\"># cat file.txt</span>\nfile1\nfile2\nfile3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过管道符号讲标准输出转换为标准输入传递给cat</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@sh:~<span class=\"token comment\"># cat file.txt|cat</span>\nfile1\nfile2\nfile3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过管道符号和xargs将标准输出转换为参数传递给cat</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@sh:~<span class=\"token comment\"># cat file.txt|xargs cat</span>\ncat: file1: No such <span class=\"token function\">file</span> or directory\ncat: file2: No such <span class=\"token function\">file</span> or directory\ncat: file3: No such <span class=\"token function\">file</span> or directory<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h3><ol>\n<li><p>查找并打包日志</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token operator\">|</span><span class=\"token function\">xargs</span> <span class=\"token function\">tar</span> <span class=\"token parameter variable\">-cvzf</span> log.tar.gz<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>对日志文件进行文字查找</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.log\"</span> <span class=\"token operator\">|</span><span class=\"token function\">xargs</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"error\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>批量创建目录</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span>  /var/log <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">1</span> <span class=\"token parameter variable\">-type</span> d <span class=\"token operator\">|</span><span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token function\">mkdir</span> .<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"uniq命令\"><a href=\"#uniq命令\" class=\"headerlink\" title=\"uniq命令\"></a>uniq命令</h2><p>Linux uniq命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p>\n<p>uniq命令可检查文本文件中重复出现的行列。</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">-c或--count 在每列旁边显示该行重复出现的次数。\n-d或--repeated 仅显示重复出现的行列。\n-f&lt;栏位>或--skip-fields=&lt;栏位> 忽略比较指定的栏位。\n-s&lt;字符位置>或--skip-chars=&lt;字符位置> 忽略比较指定的字符。\n-u或--unique 仅显示出一次的行列。\n-w&lt;字符位置>或--check-chars=&lt;字符位置> 指定要比较的字符。\n--help 显示帮助。\n--version 显示版本信息。\n[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；\n[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>文本文件包含以下内容：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">Copy code\napple\nbanana\napple\norange\norange\napple<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>uniq -c</code>命令来统计重复行的次数：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">uniq</span> <span class=\"token parameter variable\">-c</span> data.txt\n      <span class=\"token number\">1</span> apple\n      <span class=\"token number\">1</span> banana\n      <span class=\"token number\">2</span> apple\n      <span class=\"token number\">2</span> orange\n      <span class=\"token number\">1</span> apple<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出的每一行都包含两部分：重复行的次数和该行的内容。在上面的示例中，第一行的<code>apple</code>只出现了一次，第二行的<code>banana</code>只出现了一次，第三行的<code>apple</code>出现了两次，以此类推。</p>\n<h2 id=\"多机部署MySQL\"><a href=\"#多机部署MySQL\" class=\"headerlink\" title=\"多机部署MySQL\"></a>多机部署MySQL</h2><h3 id=\"实验环境搭建\"><a href=\"#实验环境搭建\" class=\"headerlink\" title=\"实验环境搭建\"></a>实验环境搭建</h3><ol>\n<li><p>配置<code>centos</code>虚拟机网络</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## 配置ip地址和子网掩码</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">ifconfig</span> <span class=\"token punctuation\">[</span>网口名<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>ip<span class=\"token punctuation\">]</span>/24\n<span class=\"token comment\">## 配置默认网关</span>\n<span class=\"token function\">sudo</span> route <span class=\"token function\">add</span> default gw <span class=\"token punctuation\">[</span>网关<span class=\"token punctuation\">]</span>\n<span class=\"token function\">ping</span> baidu.com<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>本项目通过docker搭建实验环境，首先需要在<code>centos7</code>虚拟机中安装<code>docker</code><br>运行以下命令使用官方安装脚本自动安装Docker</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://get.docker.com <span class=\"token operator\">|</span> <span class=\"token function\">bash</span> <span class=\"token parameter variable\">-s</span> <span class=\"token function\">docker</span> <span class=\"token parameter variable\">--mirror</span> Aliyun<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>启动docker服务</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">service</span> <span class=\"token function\">docker</span> start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>通过镜像<code>linuxserver/openssh-server</code>创建多个主机</p>\n<ol>\n<li><p>创建主机1，默认ssh端口号2222，主机名设置为host1，外部ssh端口号2221</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> host1<span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PASSWORD_ACCESS</span><span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_PASSWORD</span><span class=\"token operator\">=</span>password <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_NAME</span><span class=\"token operator\">=</span>demo <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-p</span> <span class=\"token number\">2221</span>:2222 lscr.io/linuxserver/openssh-server:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建主机2，默认ssh端口号2222，主机名设置为host2，外部ssh端口号2222</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> host2 <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PASSWORD_ACCESS</span><span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_PASSWORD</span><span class=\"token operator\">=</span>password <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_NAME</span><span class=\"token operator\">=</span>demo <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-p</span> <span class=\"token number\">2222</span>:2222 lscr.io/linuxserver/openssh-server:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建主机3，默认ssh端口号2222，主机名设置为host3，外部ssh端口号2223</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> host3 <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">PASSWORD_ACCESS</span><span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_PASSWORD</span><span class=\"token operator\">=</span>password <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">USER_NAME</span><span class=\"token operator\">=</span>demo <span class=\"token punctuation\">\\</span>\n <span class=\"token parameter variable\">-p</span> <span class=\"token number\">2223</span>:2222 lscr.io/linuxserver/openssh-server:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n</li>\n<li><p>通过<code>sudo docker ps</code>查看容器信息</p>\n<p> <img src=\"/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E9%9B%86%20b1f29f1f66bb4b5791f43d861b5bb655/Untitled.png\" alt=\"Untitled\"></p>\n</li>\n<li><p>容器常用命令</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">## 查看当前运行的容器状态</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">ps</span>\n\n<span class=\"token comment\">## 停止容器</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> stop 容器名\n\n<span class=\"token comment\">## 删除容器</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">rm</span> 容器名\n\n<span class=\"token comment\">## 进入正在运行的容器</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> 容器名 /bin/bash\n\n<span class=\"token comment\">##从容器中退出</span>\nexit或者使用快捷键CTRL + p 然后CTRL + q<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过<code>ping -p 2221 localhost</code>验证centos和容器之间的网络</p>\n</li>\n<li><p>通过<code>ssh -p 2221 demo@localhost</code>验证ssh服务，使用用户名<code>demo</code>和密码<code>password</code>登录容器，在容器内使用exit断开ssh连接。</p>\n</li>\n</ol>\n<h3 id=\"推送公钥到各个主机\"><a href=\"#推送公钥到各个主机\" class=\"headerlink\" title=\"推送公钥到各个主机\"></a>推送公钥到各个主机</h3><ul>\n<li><p>ssh密钥登录原理</p>\n<p>  我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p>\n<p>  密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。</p>\n</li>\n</ul>\n<ol>\n<li><code>ssh-keygen</code>制作密钥对</li>\n<li><code>ls ~/.ssh</code>查看密钥文件</li>\n<li><code>ssh-copy-id -p 2221 demo@localhost</code> 推送公钥到目标主机</li>\n<li><code>ssh -p 2221 demo@localhost</code>验证密钥登录</li>\n</ol>\n<h3 id=\"批量推送公钥\"><a href=\"#批量推送公钥\" class=\"headerlink\" title=\"批量推送公钥\"></a>批量推送公钥</h3><ol>\n<li><p>centos虚拟机安装expect工具</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> <span class=\"token function\">expect</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> <code>expect</code> 是一个用于自动化交互式命令行工具的工具集，它可以用于编写脚本来处理需要与外部程序进行交互的场景。以下是 <code>expect</code> 常用的命令和用法：</p>\n<ol>\n<li><p><code>spawn</code>：启动一个新的进程并与其进行交互。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">spawn <span class=\"token function\">ssh</span> user@hostname<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 上述命令将启动一个 SSH 连接，并与远程主机进行交互。</p>\n</li>\n<li><p><code>expect</code>：匹配预期的输出或交互，并执行相应的操作。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">expect</span> <span class=\"token string\">\"password:\"</span>\nsend <span class=\"token string\">\"mypassword<span class=\"token entity\" title=\"\\r\">\\r</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p> 上述命令会等待输出中出现 “password:”，然后发送密码。</p>\n</li>\n<li><p><code>send</code>：向进程发送字符串。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">send <span class=\"token string\">\"ls<span class=\"token entity\" title=\"\\r\">\\r</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 上述命令会发送 “ls” 命令给进程。</p>\n</li>\n</ol>\n</li>\n<li><p>批量推送公钥脚本</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">port_list</span><span class=\"token operator\">=</span><span class=\"token string\">\"2221 2223\"</span>\n<span class=\"token assign-left variable\">password</span><span class=\"token operator\">=</span><span class=\"token string\">\"password\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$port_list</span>\n<span class=\"token keyword\">do</span>\n        /usr/bin/expect <span class=\"token parameter variable\">-c</span> <span class=\"token string\">\"\n                spawn ssh-copy-id -p <span class=\"token variable\">$i</span> demo@localhost\n                expect &#123;\n                <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>*connecting<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &#123; send <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>yes<span class=\"token entity\" title=\"\\r\">\\r</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>; exp_continue &#125; &#125;\n                expect &#123;\n                <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>*password<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &#123; send <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$password</span><span class=\"token entity\" title=\"\\r\">\\r</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>; exp_continue &#125; &#125;\n                expect eof\n                \"</span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"多机部署MySQL脚本\"><a href=\"#多机部署MySQL脚本\" class=\"headerlink\" title=\"多机部署MySQL脚本\"></a>多机部署MySQL脚本</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">port_list</span><span class=\"token operator\">=</span><span class=\"token string\">\"2221 2222 2223\"</span>\n<span class=\"token assign-left variable\">password</span><span class=\"token operator\">=</span><span class=\"token string\">\"password\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$port_list</span>\n<span class=\"token keyword\">do</span>\n        <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-w1</span> <span class=\"token parameter variable\">-p</span> <span class=\"token variable\">$i</span> localhost\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">then</span>\n                /usr/bin/expect <span class=\"token parameter variable\">-c</span> <span class=\"token string\">\"\n                spawn ssh -p <span class=\"token variable\">$i</span> demo@localhost <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>sudo apk add mysql mysql-client<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>      \n                expect &#123;\n                <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>*password<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &#123; send <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">$password</span><span class=\"token entity\" title=\"\\r\">\\r</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>;exp_continue&#125;&#125;\n                expect eof\n                \"</span>\n        <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"title":"构建基本脚本","date":"2023-04-18T03:31:23.000Z","_content":"\n## 构建基本脚本\n\n- 在命令行中使用分号组织命令  \n\n    Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。\n\n    ```Shell 使用分号一次执行两个命令\n    [centos@host1 /]$ date;date\n    Tue Jun 13 14:16:40 UTC 2023\n    Tue Jun 13 14:16:40 UTC 2023\n    [centos@host1 /]$ date;whoami\n    Tue Jun 13 14:16:44 UTC 2023\n    centos\n    ```\n\n- 创建Shell脚本文件  \n\n    执行`vim test.sh`命令使用`vim`创建一个名为`test.sh`的脚本文件，编辑以下内容：  \n\n    ```bash 第一个Shell脚本\n    #!/bin/bash\n\n    # 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符\n    echo \"Hello World!\"\n    echo \"Hello World!\"\n    ```\n\n    1. 在Shell脚本中，井号`#`用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，`#!`符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  \n    2. 在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。  \n\n## 执行脚本文件的方式\n\n在执行脚本时先查看脚本是否有执行权限\n\n```shell\n[centos@host1 ~]$ ls -l test.sh\n-rwxrwxr-x 1 centos centos 124 Jun 13 14:51 test.sh\n```\n\n- 第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件\n- 第二种方式：将Shell脚本文件所处目录添加到PATH变量中\n\n    ```shell\n    [centos@host1 ~]$ echo $PATH\n    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n    ```\n\n- 第三种方式：使用 `bash + 脚本名` 或者 `source + 脚本名` 进行调用\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    Hello World!\n    Hello World!\n    [centos@host1 ~]$ source test.sh\n    Hello World!\n    Hello World!\n    ```\n\n## Shell变量概念\n\n- 变量定义\n\n    Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。\n\n- 变量分类\n\n    Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。\n\n- 定义变量的语法格式： `varName=varValue`\n\n    ```bash\n        #!/bin/bash\n    \n        # 定义一个变量，变量名为var，变量的值为数值10\n        var1=10\n    \n        # 定义一个变量，变量名为var，变量的值为字符串\"Hello World\"\n        var2=\"Hello World\"\n    \n        # 使用echo命令向标准输出打印变量var1和var2的值\n        # 使用美元符号$可以在脚本中引用已经定义过的变量\n        echo \"var1 = $var1\"\n        echo \"var2 = $var2\"\n    ```\n\n    使用`bash test.sh`命令运行脚本：  \n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    var1 = 10\n    var2 = Hello World\n    ```\n\n## Shell环境变量\n\n### 环境变量定义  \n\nBash Shell用环境变量（environment variable）来存储有关Shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。  \n\n### 环境变量分类\n\n1. 局部环境变量  \n\n    局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。\n\n    - 定义和使用局部变量  \n\n        区别于系统环境变量使用小写字符，当字符串内有空格时需要用双引号修饰。\n\n        ```shell\n        # 局部变量赋值时如果字符串内有空格不能直接赋值\n        [centos@host1 test]$ my_var=Hello World\n        bash: World: command not found\n        [centos@host1 test]$ echo $my_var\n\n        # 使用引号修饰字符串\n        [centos@host1 test]$ my_var=\"Hello World\"\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        ```\n\n    局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用。\n\n    ```shell\n    # 在父shell中创建局部环境变量，并查看变量的值\n    [centos@host1 test]$ my_var=\"Hello World\"\n    [centos@host1 test]$ echo $my_var\n    Hello World\n    # 使用bash创建子shell，在子shell中查看变量为空\n    [centos@host1 test]$ bash\n    [centos@host1 test]$ echo $my_var\n\n    ```\n\n2. 全局环境变量  \n\n    全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。  \n    Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。\n\n    - 查看和使用全局环境变量\n\n        ```shell\n        [centos@host1 test]$ printenv HOME\n        /home/centos\n        [centos@host1 test]$ echo $HOME\n        /home/centos\n        # 使用'$'在shell中引用环境变量\n        [centos@host1 test]$ ls $HOME\n        test  test.sh\n        ```\n\n    - 全局环境变量可以用于所有子Shell\n\n        ```shell\n        # 在父shell中查看环境变量HOME\n        [centos@host1 test]$ printenv HOME\n        /home/centos\n        # 使用bash命令创建子shell\n        [centos@host1 test]$ bash\n        # 在子shell中查看HOME变量\n        [centos@host1 test]$ printenv HOME\n        /home/centos\n        # 查看当前系统的父子shell关系\n        [centos@host1 test]$ ps -f\n        UID          PID    PPID  C STIME TTY          TIME CMD\n        centos       126     125  0 03:08 pts/3    00:00:00 bash\n        centos       150     126  0 05:12 pts/3    00:00:00 bash\n        centos       166     150  0 05:12 pts/3    00:00:00 ps -f\n        ```\n\n    - 设置全局环境变量\n\n        在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 `export`把它导出到全局环境中。\n\n        ```shell\n        # 在父shell中创建局部变量\n        [centos@host1 test]$ my_var=\"Hello World\"\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        # 将局部变量导出为全局变量\n        [centos@host1 test]$ export my_var\n        # 创建子shell\n        [centos@host1 test]$ bash\n        # 查看子shell继承的全局变量\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        # 修改子shell的全局变量\n        [centos@host1 test]$ my_var=\"NULL\"\n        [centos@host1 test]$ echo $my_var\n        NULL\n        # 退回父shell\n        [centos@host1 test]$ exit\n        exit\n        # 父shell内的全局变量值没有变\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        ```\n\n    - bash默认的环境变量\n\n        1. HOME：当前用户的家目录\n        2. PATH：系统执行命令的路径\n        3. USER：当前登录的用户名\n        4. Shell：当前用户使用的默认Shell程序\n        5. PWD：当前工作目录\n        6. LANG：当前语言环境\n        7. TERM：当前终端的类型\n        8. PS1：命令提示符的格式\n        9. HISTSIZE：命令历史记录的长度限制\n        10. HISTFILESIZE：命令历史记录文件的大小限制\n\n    - 设置PATH环境变量\n\n      ```shell\n      # 查看PATH变量的值\n      [centos@host1 test]$ echo $PATH\n      /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n      # 修改PATH变量，追加目录/home/centos\n      [centos@host1 test]$ PATH=$PATH:/home/centos\n      # 确认PATH变量的值\n      [centos@host1 test]$ echo $PATH\n      /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/centos\n      ```\n\n## 变量赋值\n\nShell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n\n- 引用用户变量和环境变量\n  - 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。\n  - 在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n  - 变量每次被引用时，都会输出当前赋给它的值。引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串。\n\n  ```bash\n  #!/bin/bash\n\n  # 通过引用环境变量进行赋值\n  var1=$HOME\n\n  # 通过echo命令打印var1的值\n  echo \"var1 = $var1\"\n  ```\n\n  运行结果：\n\n  ```shell\n  [centos@host1 ~]$ bash test.sh\n  var1 = /home/centos\n  ```\n\n- 命令替换\n\n    Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：\n\n  - 反引号字符（`）(与~同键位)\n  - $()格式\n\n  ```bash\n  #!/bin/bash\n\n  # 通过引用环境变量进行赋值\n  today=`date +%y%m%d`\n\n  touch log.$today\n  ```\n\n  运行结果：\n\n  ```shell\n  [centos@host1 ~]$ bash test.sh\n  # 创建了一个后缀为当前系统时间的日志文件\n  [centos@host1 ~]$ ls\n  log.230616  test.sh\n  ```\n\n- 从键盘读入赋值\n\n    在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：`read –p [提示信息]：[变量名]`\n\n    ```bash\n    #!/bin/bash\n\n    # 使用read命令打印出提示信息，等待用户输入字符并回车后将字符保存在变量ip内\n    read -p \"input ip:\" ip\n\n    # 使用ping检查用户所输入的ip地址的连通性\n    ping -c2 $ip\n    ```\n\n## 变量的数值计算\n\n1. 使用 `expr`命令\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    expr 5 + 2\n    expr 5+2\n    expr 5 * 2\n    expr 5 \\* 2\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    # expr的用法里运算符两侧需要添加空格\n    7\n    5+2\n    # 星号*不能直接作为乘法运算符使用，需要用反斜杠进行转义\n    expr: syntax error\n    10\n    ```\n\n2. 使用方括号\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    var1=100\n    var2=50\n    var3=45\n\n    var4=$[$var1 / $var2]\n    var5=$[$var1 / $var3]\n\n    echo var4 = $var4\n    echo var5 = $var5\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    var4 = 2\n    # 使用方括号进行的数值计算在整数范围内\n    var5 = 2\n    ```\n\n3. 在脚本内使用 `bc` 进行浮点数计算\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    var1=`echo \"scale=4; 3.44 / 5\" | bc`\n\n    echo the answer is $var1\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    the answer is .6880\n    ```\n\n4. let数值运算命令\n\n    let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于`((赋值表达式))` 。\n\n    ```shell\n    [centos@host1 ~]$ let sum=sum+8\n    [centos@host1 ~]$ echo $sum\n    8\n    ```\n\n5. 变量的自增\n\n    Shell变量的自增运算符是`i++`和`++i`。`i++`表示**先赋值再自加**，`++i`表示**先自加再赋值**。\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    var1=10\n\n    let var1++\n    echo $var1\n\n    let ++var1\n    echo $var1\n\n    let var2=var1++\n    echo $var2 $var1\n\n    let var2=++var1\n    echo $var2 $var1\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    11\n    12\n    12 13\n    14 14\n    ```\n\n## 特殊参数\n\n- 位置参数\n\n    $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数。\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    echo name is $0, var1 = $1, var2 = $2\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    name is test.sh, var1 = , var2 =\n    [centos@host1 ~]$ bash test.sh 123 abc\n    name is test.sh, var1 = 123, var2 = abc\n    ```\n\n- 预定义参数\n\n    |||\n    |---|---|\n    |$0|脚本名|\n    |$*|所有的参数（以整体的形式）|\n    |$@|所以的参数（以数组的形式）|\n    |$#|参数的个数|\n    |$$|当前进程的PID|\n    |$!|上一个后台进程的PID|\n    |$?|上一个命令的返回值 0表示成功|\n\n## Shell中的特殊符号\n\n- \"#\"用在行首表示程序的注释。\n- \";\" 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。\n- \".\"等价于source命令。它是bash中的一个内建命令。\n\n    \".\"也可以作为文件名的一部分，如果\".\"放在文件名的开头，那么这个文件将会成为\"隐藏文件\"，ls命令将不会正常显示出这个文件。\n\n- 单引号''，双引号\"\"的区别是单引号''剥夺了所有字符的特殊含义，单引号''内就变成了单纯的字符。双引号\"\"则对于双引号\"\"内的参数替换($)和命令替换(``)是个例外。\n","source":"_posts/linux_shell/2.构建基本脚本.md","raw":"---\ntitle: 构建基本脚本\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n## 构建基本脚本\n\n- 在命令行中使用分号组织命令  \n\n    Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。\n\n    ```Shell 使用分号一次执行两个命令\n    [centos@host1 /]$ date;date\n    Tue Jun 13 14:16:40 UTC 2023\n    Tue Jun 13 14:16:40 UTC 2023\n    [centos@host1 /]$ date;whoami\n    Tue Jun 13 14:16:44 UTC 2023\n    centos\n    ```\n\n- 创建Shell脚本文件  \n\n    执行`vim test.sh`命令使用`vim`创建一个名为`test.sh`的脚本文件，编辑以下内容：  \n\n    ```bash 第一个Shell脚本\n    #!/bin/bash\n\n    # 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符\n    echo \"Hello World!\"\n    echo \"Hello World!\"\n    ```\n\n    1. 在Shell脚本中，井号`#`用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，`#!`符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  \n    2. 在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。  \n\n## 执行脚本文件的方式\n\n在执行脚本时先查看脚本是否有执行权限\n\n```shell\n[centos@host1 ~]$ ls -l test.sh\n-rwxrwxr-x 1 centos centos 124 Jun 13 14:51 test.sh\n```\n\n- 第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件\n- 第二种方式：将Shell脚本文件所处目录添加到PATH变量中\n\n    ```shell\n    [centos@host1 ~]$ echo $PATH\n    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n    ```\n\n- 第三种方式：使用 `bash + 脚本名` 或者 `source + 脚本名` 进行调用\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    Hello World!\n    Hello World!\n    [centos@host1 ~]$ source test.sh\n    Hello World!\n    Hello World!\n    ```\n\n## Shell变量概念\n\n- 变量定义\n\n    Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。\n\n- 变量分类\n\n    Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。\n\n- 定义变量的语法格式： `varName=varValue`\n\n    ```bash\n        #!/bin/bash\n    \n        # 定义一个变量，变量名为var，变量的值为数值10\n        var1=10\n    \n        # 定义一个变量，变量名为var，变量的值为字符串\"Hello World\"\n        var2=\"Hello World\"\n    \n        # 使用echo命令向标准输出打印变量var1和var2的值\n        # 使用美元符号$可以在脚本中引用已经定义过的变量\n        echo \"var1 = $var1\"\n        echo \"var2 = $var2\"\n    ```\n\n    使用`bash test.sh`命令运行脚本：  \n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    var1 = 10\n    var2 = Hello World\n    ```\n\n## Shell环境变量\n\n### 环境变量定义  \n\nBash Shell用环境变量（environment variable）来存储有关Shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。  \n\n### 环境变量分类\n\n1. 局部环境变量  \n\n    局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。\n\n    - 定义和使用局部变量  \n\n        区别于系统环境变量使用小写字符，当字符串内有空格时需要用双引号修饰。\n\n        ```shell\n        # 局部变量赋值时如果字符串内有空格不能直接赋值\n        [centos@host1 test]$ my_var=Hello World\n        bash: World: command not found\n        [centos@host1 test]$ echo $my_var\n\n        # 使用引号修饰字符串\n        [centos@host1 test]$ my_var=\"Hello World\"\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        ```\n\n    局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用。\n\n    ```shell\n    # 在父shell中创建局部环境变量，并查看变量的值\n    [centos@host1 test]$ my_var=\"Hello World\"\n    [centos@host1 test]$ echo $my_var\n    Hello World\n    # 使用bash创建子shell，在子shell中查看变量为空\n    [centos@host1 test]$ bash\n    [centos@host1 test]$ echo $my_var\n\n    ```\n\n2. 全局环境变量  \n\n    全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。  \n    Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。\n\n    - 查看和使用全局环境变量\n\n        ```shell\n        [centos@host1 test]$ printenv HOME\n        /home/centos\n        [centos@host1 test]$ echo $HOME\n        /home/centos\n        # 使用'$'在shell中引用环境变量\n        [centos@host1 test]$ ls $HOME\n        test  test.sh\n        ```\n\n    - 全局环境变量可以用于所有子Shell\n\n        ```shell\n        # 在父shell中查看环境变量HOME\n        [centos@host1 test]$ printenv HOME\n        /home/centos\n        # 使用bash命令创建子shell\n        [centos@host1 test]$ bash\n        # 在子shell中查看HOME变量\n        [centos@host1 test]$ printenv HOME\n        /home/centos\n        # 查看当前系统的父子shell关系\n        [centos@host1 test]$ ps -f\n        UID          PID    PPID  C STIME TTY          TIME CMD\n        centos       126     125  0 03:08 pts/3    00:00:00 bash\n        centos       150     126  0 05:12 pts/3    00:00:00 bash\n        centos       166     150  0 05:12 pts/3    00:00:00 ps -f\n        ```\n\n    - 设置全局环境变量\n\n        在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 `export`把它导出到全局环境中。\n\n        ```shell\n        # 在父shell中创建局部变量\n        [centos@host1 test]$ my_var=\"Hello World\"\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        # 将局部变量导出为全局变量\n        [centos@host1 test]$ export my_var\n        # 创建子shell\n        [centos@host1 test]$ bash\n        # 查看子shell继承的全局变量\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        # 修改子shell的全局变量\n        [centos@host1 test]$ my_var=\"NULL\"\n        [centos@host1 test]$ echo $my_var\n        NULL\n        # 退回父shell\n        [centos@host1 test]$ exit\n        exit\n        # 父shell内的全局变量值没有变\n        [centos@host1 test]$ echo $my_var\n        Hello World\n        ```\n\n    - bash默认的环境变量\n\n        1. HOME：当前用户的家目录\n        2. PATH：系统执行命令的路径\n        3. USER：当前登录的用户名\n        4. Shell：当前用户使用的默认Shell程序\n        5. PWD：当前工作目录\n        6. LANG：当前语言环境\n        7. TERM：当前终端的类型\n        8. PS1：命令提示符的格式\n        9. HISTSIZE：命令历史记录的长度限制\n        10. HISTFILESIZE：命令历史记录文件的大小限制\n\n    - 设置PATH环境变量\n\n      ```shell\n      # 查看PATH变量的值\n      [centos@host1 test]$ echo $PATH\n      /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n      # 修改PATH变量，追加目录/home/centos\n      [centos@host1 test]$ PATH=$PATH:/home/centos\n      # 确认PATH变量的值\n      [centos@host1 test]$ echo $PATH\n      /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/centos\n      ```\n\n## 变量赋值\n\nShell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n\n- 引用用户变量和环境变量\n  - 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。\n  - 在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。\n  - 变量每次被引用时，都会输出当前赋给它的值。引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串。\n\n  ```bash\n  #!/bin/bash\n\n  # 通过引用环境变量进行赋值\n  var1=$HOME\n\n  # 通过echo命令打印var1的值\n  echo \"var1 = $var1\"\n  ```\n\n  运行结果：\n\n  ```shell\n  [centos@host1 ~]$ bash test.sh\n  var1 = /home/centos\n  ```\n\n- 命令替换\n\n    Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：\n\n  - 反引号字符（`）(与~同键位)\n  - $()格式\n\n  ```bash\n  #!/bin/bash\n\n  # 通过引用环境变量进行赋值\n  today=`date +%y%m%d`\n\n  touch log.$today\n  ```\n\n  运行结果：\n\n  ```shell\n  [centos@host1 ~]$ bash test.sh\n  # 创建了一个后缀为当前系统时间的日志文件\n  [centos@host1 ~]$ ls\n  log.230616  test.sh\n  ```\n\n- 从键盘读入赋值\n\n    在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：`read –p [提示信息]：[变量名]`\n\n    ```bash\n    #!/bin/bash\n\n    # 使用read命令打印出提示信息，等待用户输入字符并回车后将字符保存在变量ip内\n    read -p \"input ip:\" ip\n\n    # 使用ping检查用户所输入的ip地址的连通性\n    ping -c2 $ip\n    ```\n\n## 变量的数值计算\n\n1. 使用 `expr`命令\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    expr 5 + 2\n    expr 5+2\n    expr 5 * 2\n    expr 5 \\* 2\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    # expr的用法里运算符两侧需要添加空格\n    7\n    5+2\n    # 星号*不能直接作为乘法运算符使用，需要用反斜杠进行转义\n    expr: syntax error\n    10\n    ```\n\n2. 使用方括号\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    var1=100\n    var2=50\n    var3=45\n\n    var4=$[$var1 / $var2]\n    var5=$[$var1 / $var3]\n\n    echo var4 = $var4\n    echo var5 = $var5\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    var4 = 2\n    # 使用方括号进行的数值计算在整数范围内\n    var5 = 2\n    ```\n\n3. 在脚本内使用 `bc` 进行浮点数计算\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    var1=`echo \"scale=4; 3.44 / 5\" | bc`\n\n    echo the answer is $var1\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    the answer is .6880\n    ```\n\n4. let数值运算命令\n\n    let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于`((赋值表达式))` 。\n\n    ```shell\n    [centos@host1 ~]$ let sum=sum+8\n    [centos@host1 ~]$ echo $sum\n    8\n    ```\n\n5. 变量的自增\n\n    Shell变量的自增运算符是`i++`和`++i`。`i++`表示**先赋值再自加**，`++i`表示**先自加再赋值**。\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    var1=10\n\n    let var1++\n    echo $var1\n\n    let ++var1\n    echo $var1\n\n    let var2=var1++\n    echo $var2 $var1\n\n    let var2=++var1\n    echo $var2 $var1\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    11\n    12\n    12 13\n    14 14\n    ```\n\n## 特殊参数\n\n- 位置参数\n\n    $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数。\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    echo name is $0, var1 = $1, var2 = $2\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    name is test.sh, var1 = , var2 =\n    [centos@host1 ~]$ bash test.sh 123 abc\n    name is test.sh, var1 = 123, var2 = abc\n    ```\n\n- 预定义参数\n\n    |||\n    |---|---|\n    |$0|脚本名|\n    |$*|所有的参数（以整体的形式）|\n    |$@|所以的参数（以数组的形式）|\n    |$#|参数的个数|\n    |$$|当前进程的PID|\n    |$!|上一个后台进程的PID|\n    |$?|上一个命令的返回值 0表示成功|\n\n## Shell中的特殊符号\n\n- \"#\"用在行首表示程序的注释。\n- \";\" 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。\n- \".\"等价于source命令。它是bash中的一个内建命令。\n\n    \".\"也可以作为文件名的一部分，如果\".\"放在文件名的开头，那么这个文件将会成为\"隐藏文件\"，ls命令将不会正常显示出这个文件。\n\n- 单引号''，双引号\"\"的区别是单引号''剥夺了所有字符的特殊含义，单引号''内就变成了单纯的字符。双引号\"\"则对于双引号\"\"内的参数替换($)和命令替换(``)是个例外。\n","slug":"linux_shell/2.构建基本脚本","published":1,"updated":"2023-06-16T13:12:02.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04j00091dnzbmtaa0ul","content":"<h2 id=\"构建基本脚本\"><a href=\"#构建基本脚本\" class=\"headerlink\" title=\"构建基本脚本\"></a>构建基本脚本</h2><ul>\n<li><p>在命令行中使用分号组织命令  </p>\n<p>  Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。</p>\n  <pre class=\"line-numbers language-Shell\" data-language=\"Shell\"><div class=\"caption\"><span>使用分号一次执行两个命令</span></div><code class=\"language-Shell\">[centos@host1 &#x2F;]$ date;date\nTue Jun 13 14:16:40 UTC 2023\nTue Jun 13 14:16:40 UTC 2023\n[centos@host1 &#x2F;]$ date;whoami\nTue Jun 13 14:16:44 UTC 2023\ncentos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建Shell脚本文件  </p>\n<p>  执行<code>vim test.sh</code>命令使用<code>vim</code>创建一个名为<code>test.sh</code>的脚本文件，编辑以下内容：  </p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><div class=\"caption\"><span>第一个Shell脚本</span></div><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello World!\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello World!\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>在Shell脚本中，井号<code>#</code>用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，<code>#!</code>符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  </li>\n<li>在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"执行脚本文件的方式\"><a href=\"#执行脚本文件的方式\" class=\"headerlink\" title=\"执行脚本文件的方式\"></a>执行脚本文件的方式</h2><p>在执行脚本时先查看脚本是否有执行权限</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> test.sh\n-rwxrwxr-x <span class=\"token number\">1</span> centos centos <span class=\"token number\">124</span> Jun <span class=\"token number\">13</span> <span class=\"token number\">14</span>:51 test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件</p>\n</li>\n<li><p>第二种方式：将Shell脚本文件所处目录添加到PATH变量中</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>第三种方式：使用 <code>bash + 脚本名</code> 或者 <code>source + 脚本名</code> 进行调用</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">source</span> test.sh\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"Shell变量概念\"><a href=\"#Shell变量概念\" class=\"headerlink\" title=\"Shell变量概念\"></a>Shell变量概念</h2><ul>\n<li><p>变量定义</p>\n<p>  Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。</p>\n</li>\n<li><p>变量分类</p>\n<p>  Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。</p>\n</li>\n<li><p>定义变量的语法格式： <code>varName=varValue</code></p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n    \n<span class=\"token comment\"># 定义一个变量，变量名为var，变量的值为数值10</span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n    \n<span class=\"token comment\"># 定义一个变量，变量名为var，变量的值为字符串\"Hello World\"</span>\n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n    \n<span class=\"token comment\"># 使用echo命令向标准输出打印变量var1和var2的值</span>\n<span class=\"token comment\"># 使用美元符号$可以在脚本中引用已经定义过的变量</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"var1 = <span class=\"token variable\">$var1</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"var2 = <span class=\"token variable\">$var2</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  使用<code>bash test.sh</code>命令运行脚本：  </p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nvar1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\nvar2 <span class=\"token operator\">=</span> Hello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"Shell环境变量\"><a href=\"#Shell环境变量\" class=\"headerlink\" title=\"Shell环境变量\"></a>Shell环境变量</h2><h3 id=\"环境变量定义\"><a href=\"#环境变量定义\" class=\"headerlink\" title=\"环境变量定义\"></a>环境变量定义</h3><p>Bash Shell用环境变量（environment variable）来存储有关Shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。  </p>\n<h3 id=\"环境变量分类\"><a href=\"#环境变量分类\" class=\"headerlink\" title=\"环境变量分类\"></a>环境变量分类</h3><ol>\n<li><p>局部环境变量  </p>\n<p> 局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p>\n<ul>\n<li><p>定义和使用局部变量  </p>\n<p>  区别于系统环境变量使用小写字符，当字符串内有空格时需要用双引号修饰。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 局部变量赋值时如果字符串内有空格不能直接赋值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span>Hello World\nbash: World: <span class=\"token builtin class-name\">command</span> not found\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\n\n<span class=\"token comment\"># 使用引号修饰字符串</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p> 局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在父shell中创建局部环境变量，并查看变量的值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World\n<span class=\"token comment\"># 使用bash创建子shell，在子shell中查看变量为空</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>全局环境变量  </p>\n<p> 全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。<br> Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p>\n<ul>\n<li><p>查看和使用全局环境变量</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">printenv</span> <span class=\"token environment constant\">HOME</span>\n/home/centos\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$HOME</span>\n/home/centos\n<span class=\"token comment\"># 使用'$'在shell中引用环境变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span> <span class=\"token environment constant\">$HOME</span>\n<span class=\"token builtin class-name\">test</span>  test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>全局环境变量可以用于所有子Shell</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在父shell中查看环境变量HOME</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">printenv</span> <span class=\"token environment constant\">HOME</span>\n/home/centos\n<span class=\"token comment\"># 使用bash命令创建子shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span>\n<span class=\"token comment\"># 在子shell中查看HOME变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">printenv</span> <span class=\"token environment constant\">HOME</span>\n/home/centos\n<span class=\"token comment\"># 查看当前系统的父子shell关系</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-f</span>\n<span class=\"token environment constant\">UID</span>          PID    <span class=\"token environment constant\">PPID</span>  C STIME TTY          TIME CMD\ncentos       <span class=\"token number\">126</span>     <span class=\"token number\">125</span>  <span class=\"token number\">0</span> 03:08 pts/3    00:00:00 <span class=\"token function\">bash</span>\ncentos       <span class=\"token number\">150</span>     <span class=\"token number\">126</span>  <span class=\"token number\">0</span> 05:12 pts/3    00:00:00 <span class=\"token function\">bash</span>\ncentos       <span class=\"token number\">166</span>     <span class=\"token number\">150</span>  <span class=\"token number\">0</span> 05:12 pts/3    00:00:00 <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-f</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>设置全局环境变量</p>\n<p>  在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 <code>export</code>把它导出到全局环境中。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在父shell中创建局部变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World\n<span class=\"token comment\"># 将局部变量导出为全局变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">export</span> my_var\n<span class=\"token comment\"># 创建子shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span>\n<span class=\"token comment\"># 查看子shell继承的全局变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World\n<span class=\"token comment\"># 修改子shell的全局变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"NULL\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nNULL\n<span class=\"token comment\"># 退回父shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">exit</span>\n<span class=\"token builtin class-name\">exit</span>\n<span class=\"token comment\"># 父shell内的全局变量值没有变</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>bash默认的环境变量</p>\n<ol>\n<li>HOME：当前用户的家目录</li>\n<li>PATH：系统执行命令的路径</li>\n<li>USER：当前登录的用户名</li>\n<li>Shell：当前用户使用的默认Shell程序</li>\n<li>PWD：当前工作目录</li>\n<li>LANG：当前语言环境</li>\n<li>TERM：当前终端的类型</li>\n<li>PS1：命令提示符的格式</li>\n<li>HISTSIZE：命令历史记录的长度限制</li>\n<li>HISTFILESIZE：命令历史记录文件的大小限制</li>\n</ol>\n</li>\n<li><p>设置PATH环境变量</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看PATH变量的值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n<span class=\"token comment\"># 修改PATH变量，追加目录/home/centos</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token environment constant\">$PATH</span>:/home/centos\n<span class=\"token comment\"># 确认PATH变量的值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/centos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h2><p>Shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</p>\n<ul>\n<li><p>引用用户变量和环境变量</p>\n<ul>\n<li>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</li>\n<li>在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</li>\n<li>变量每次被引用时，都会输出当前赋给它的值。引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 通过引用环境变量进行赋值</span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token environment constant\">$HOME</span>\n\n<span class=\"token comment\"># 通过echo命令打印var1的值</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"var1 = <span class=\"token variable\">$var1</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nvar1 <span class=\"token operator\">=</span> /home/centos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>命令替换</p>\n<p>  Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：</p>\n<ul>\n<li>反引号字符（&#96;）(与~同键位)</li>\n<li>$()格式</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 通过引用环境变量进行赋值</span>\n<span class=\"token assign-left variable\">today</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> +%y%m%d<span class=\"token variable\">`</span></span>\n\n<span class=\"token function\">touch</span> log.<span class=\"token variable\">$today</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n<span class=\"token comment\"># 创建了一个后缀为当前系统时间的日志文件</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span>\nlog.230616  test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>从键盘读入赋值</p>\n<p>  在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：<code>read –p [提示信息]：[变量名]</code></p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 使用read命令打印出提示信息，等待用户输入字符并回车后将字符保存在变量ip内</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"input ip:\"</span> <span class=\"token function\">ip</span>\n\n<span class=\"token comment\"># 使用ping检查用户所输入的ip地址的连通性</span>\n<span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c2</span> <span class=\"token variable\">$ip</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"变量的数值计算\"><a href=\"#变量的数值计算\" class=\"headerlink\" title=\"变量的数值计算\"></a>变量的数值计算</h2><ol>\n<li><p>使用 <code>expr</code>命令</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span> + <span class=\"token number\">2</span>\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span>+2\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span> * <span class=\"token number\">2</span>\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">\\</span>* <span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n<span class=\"token comment\"># expr的用法里运算符两侧需要添加空格</span>\n<span class=\"token number\">7</span>\n<span class=\"token number\">5</span>+2\n<span class=\"token comment\"># 星号*不能直接作为乘法运算符使用，需要用反斜杠进行转义</span>\nexpr: syntax error\n<span class=\"token number\">10</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用方括号</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">100</span>\n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span><span class=\"token number\">50</span>\n<span class=\"token assign-left variable\">var3</span><span class=\"token operator\">=</span><span class=\"token number\">45</span>\n\n<span class=\"token assign-left variable\">var4</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$var1</span> / <span class=\"token variable\">$var2</span><span class=\"token punctuation\">]</span>\n<span class=\"token assign-left variable\">var5</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$var1</span> / <span class=\"token variable\">$var3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token builtin class-name\">echo</span> var4 <span class=\"token operator\">=</span> <span class=\"token variable\">$var4</span>\n<span class=\"token builtin class-name\">echo</span> var5 <span class=\"token operator\">=</span> <span class=\"token variable\">$var5</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nvar4 <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n<span class=\"token comment\"># 使用方括号进行的数值计算在整数范围内</span>\nvar5 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在脚本内使用 <code>bc</code> 进行浮点数计算</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"scale=4; 3.44 / 5\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">bc</span><span class=\"token variable\">`</span></span>\n\n<span class=\"token builtin class-name\">echo</span> the answer is <span class=\"token variable\">$var1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nthe answer is .6880<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>let数值运算命令</p>\n<p> let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于<code>((赋值表达式))</code> 。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span>sum+8\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$sum</span>\n<span class=\"token number\">8</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>变量的自增</p>\n<p> Shell变量的自增运算符是<code>i++</code>和<code>++i</code>。<code>i++</code>表示<strong>先赋值再自加</strong>，<code>++i</code>表示<strong>先自加再赋值</strong>。</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n\n<span class=\"token builtin class-name\">let</span> var1++\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var1</span>\n\n<span class=\"token builtin class-name\">let</span> ++var1\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var1</span>\n\n<span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span>var1++\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var2</span> <span class=\"token variable\">$var1</span>\n\n<span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span>++var1\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var2</span> <span class=\"token variable\">$var1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n<span class=\"token number\">11</span>\n<span class=\"token number\">12</span>\n<span class=\"token number\">12</span> <span class=\"token number\">13</span>\n<span class=\"token number\">14</span> <span class=\"token number\">14</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"特殊参数\"><a href=\"#特殊参数\" class=\"headerlink\" title=\"特殊参数\"></a>特殊参数</h2><ul>\n<li><p>位置参数</p>\n<p>  $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数。</p>\n<p>  创建脚本test.sh、编辑以下内容：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> name is <span class=\"token variable\">$0</span>, var1 <span class=\"token operator\">=</span> <span class=\"token variable\">$1</span>, var2 <span class=\"token operator\">=</span> <span class=\"token variable\">$2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>  运行脚本：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nname is test.sh, var1 <span class=\"token operator\">=</span> , var2 <span class=\"token operator\">=</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh <span class=\"token number\">123</span> abc\nname is test.sh, var1 <span class=\"token operator\">=</span> <span class=\"token number\">123</span>, var2 <span class=\"token operator\">=</span> abc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>预定义参数</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$0</td>\n<td>脚本名</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>所有的参数（以整体的形式）</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>所以的参数（以数组的形式）</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>参数的个数</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前进程的PID</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>上一个后台进程的PID</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>上一个命令的返回值 0表示成功</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"Shell中的特殊符号\"><a href=\"#Shell中的特殊符号\" class=\"headerlink\" title=\"Shell中的特殊符号\"></a>Shell中的特殊符号</h2><ul>\n<li><p>“#”用在行首表示程序的注释。</p>\n</li>\n<li><p>“;” 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。</p>\n</li>\n<li><p>“.”等价于source命令。它是bash中的一个内建命令。</p>\n<p>  “.”也可以作为文件名的一部分，如果”.”放在文件名的开头，那么这个文件将会成为”隐藏文件”，ls命令将不会正常显示出这个文件。</p>\n</li>\n<li><p>单引号’’，双引号””的区别是单引号’’剥夺了所有字符的特殊含义，单引号’’内就变成了单纯的字符。双引号””则对于双引号””内的参数替换($)和命令替换(&#96;&#96;)是个例外。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"构建基本脚本\"><a href=\"#构建基本脚本\" class=\"headerlink\" title=\"构建基本脚本\"></a>构建基本脚本</h2><ul>\n<li><p>在命令行中使用分号组织命令  </p>\n<p>  Shell脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。Shell可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以把它们放在同一行中，彼此间用分号隔开。</p>\n  <pre class=\"line-numbers language-Shell\" data-language=\"Shell\"><div class=\"caption\"><span>使用分号一次执行两个命令</span></div><code class=\"language-Shell\">[centos@host1 &#x2F;]$ date;date\nTue Jun 13 14:16:40 UTC 2023\nTue Jun 13 14:16:40 UTC 2023\n[centos@host1 &#x2F;]$ date;whoami\nTue Jun 13 14:16:44 UTC 2023\ncentos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建Shell脚本文件  </p>\n<p>  执行<code>vim test.sh</code>命令使用<code>vim</code>创建一个名为<code>test.sh</code>的脚本文件，编辑以下内容：  </p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><div class=\"caption\"><span>第一个Shell脚本</span></div><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 这是一行注释，下面两行代码通过echo命令向标准输出发送指定字符</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello World!\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello World!\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li>在Shell脚本中，井号<code>#</code>用作注释行，Shell并不会处理Shell脚本中的注释行。但是Shell脚本文件的第一行是个例外，<code>#!</code>符号是一个特殊的标记，它会告诉系统用哪个Shell来运行脚本。  </li>\n<li>在Shell脚本中，你可以在独立的行中书写命令，Shell会按根据命令在文件中出现的顺序进行处理。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"执行脚本文件的方式\"><a href=\"#执行脚本文件的方式\" class=\"headerlink\" title=\"执行脚本文件的方式\"></a>执行脚本文件的方式</h2><p>在执行脚本时先查看脚本是否有执行权限</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> test.sh\n-rwxrwxr-x <span class=\"token number\">1</span> centos centos <span class=\"token number\">124</span> Jun <span class=\"token number\">13</span> <span class=\"token number\">14</span>:51 test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>第一种方式：在提示符中使用绝对或者相对文件路径来引用脚本文件</p>\n</li>\n<li><p>第二种方式：将Shell脚本文件所处目录添加到PATH变量中</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>第三种方式：使用 <code>bash + 脚本名</code> 或者 <code>source + 脚本名</code> 进行调用</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">source</span> test.sh\nHello World<span class=\"token operator\">!</span>\nHello World<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"Shell变量概念\"><a href=\"#Shell变量概念\" class=\"headerlink\" title=\"Shell变量概念\"></a>Shell变量概念</h2><ul>\n<li><p>变量定义</p>\n<p>  Shell变量是一种用于存储数据的容器。在Shell脚本中，变量用于存储各种类型的数据，例如数字、字符、字符串等。变量名通常是由一个字母、数字或下划线组成的字符串，并且不能以数字开头。</p>\n</li>\n<li><p>变量分类</p>\n<p>  Shell中主要有两种类型的变量：环境变量和自定义变量。环境变量是在系统中定义的，可以由所有进程和用户访问。常见的环境变量包括PATH、HOME和USER等。自定义变量是在脚本中定义的，只能在脚本中使用，不能在脚本外部访问。</p>\n</li>\n<li><p>定义变量的语法格式： <code>varName=varValue</code></p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n    \n<span class=\"token comment\"># 定义一个变量，变量名为var，变量的值为数值10</span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n    \n<span class=\"token comment\"># 定义一个变量，变量名为var，变量的值为字符串\"Hello World\"</span>\n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n    \n<span class=\"token comment\"># 使用echo命令向标准输出打印变量var1和var2的值</span>\n<span class=\"token comment\"># 使用美元符号$可以在脚本中引用已经定义过的变量</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"var1 = <span class=\"token variable\">$var1</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"var2 = <span class=\"token variable\">$var2</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  使用<code>bash test.sh</code>命令运行脚本：  </p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nvar1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\nvar2 <span class=\"token operator\">=</span> Hello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"Shell环境变量\"><a href=\"#Shell环境变量\" class=\"headerlink\" title=\"Shell环境变量\"></a>Shell环境变量</h2><h3 id=\"环境变量定义\"><a href=\"#环境变量定义\" class=\"headerlink\" title=\"环境变量定义\"></a>环境变量定义</h3><p>Bash Shell用环境变量（environment variable）来存储有关Shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或Shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。  </p>\n<h3 id=\"环境变量分类\"><a href=\"#环境变量分类\" class=\"headerlink\" title=\"环境变量分类\"></a>环境变量分类</h3><ol>\n<li><p>局部环境变量  </p>\n<p> 局部环境变量只能在定义它们的进程中可见。查看局部环境变量的列表有点复杂。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p>\n<ul>\n<li><p>定义和使用局部变量  </p>\n<p>  区别于系统环境变量使用小写字符，当字符串内有空格时需要用双引号修饰。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 局部变量赋值时如果字符串内有空格不能直接赋值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span>Hello World\nbash: World: <span class=\"token builtin class-name\">command</span> not found\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\n\n<span class=\"token comment\"># 使用引号修饰字符串</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p> 局部变量在子Shell中不可用，同样子Shell中定义的局部变量在父Shell中不可用。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在父shell中创建局部环境变量，并查看变量的值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World\n<span class=\"token comment\"># 使用bash创建子shell，在子shell中查看变量为空</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>全局环境变量  </p>\n<p> 全局环境变量对于Shell会话和所有生成的子Shell都是可见的。局部变量则只对创建它们的Shell可见。这让全局环境变量对那些所创建的子Shell需要获取父Shell信息的程序来说非常有用。<br> Linux系统在你开始bash会话时就设置了一些全局环境变量。系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p>\n<ul>\n<li><p>查看和使用全局环境变量</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">printenv</span> <span class=\"token environment constant\">HOME</span>\n/home/centos\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$HOME</span>\n/home/centos\n<span class=\"token comment\"># 使用'$'在shell中引用环境变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span> <span class=\"token environment constant\">$HOME</span>\n<span class=\"token builtin class-name\">test</span>  test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>全局环境变量可以用于所有子Shell</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在父shell中查看环境变量HOME</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">printenv</span> <span class=\"token environment constant\">HOME</span>\n/home/centos\n<span class=\"token comment\"># 使用bash命令创建子shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span>\n<span class=\"token comment\"># 在子shell中查看HOME变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">printenv</span> <span class=\"token environment constant\">HOME</span>\n/home/centos\n<span class=\"token comment\"># 查看当前系统的父子shell关系</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-f</span>\n<span class=\"token environment constant\">UID</span>          PID    <span class=\"token environment constant\">PPID</span>  C STIME TTY          TIME CMD\ncentos       <span class=\"token number\">126</span>     <span class=\"token number\">125</span>  <span class=\"token number\">0</span> 03:08 pts/3    00:00:00 <span class=\"token function\">bash</span>\ncentos       <span class=\"token number\">150</span>     <span class=\"token number\">126</span>  <span class=\"token number\">0</span> 05:12 pts/3    00:00:00 <span class=\"token function\">bash</span>\ncentos       <span class=\"token number\">166</span>     <span class=\"token number\">150</span>  <span class=\"token number\">0</span> 05:12 pts/3    00:00:00 <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-f</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>设置全局环境变量</p>\n<p>  在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再使用 <code>export</code>把它导出到全局环境中。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在父shell中创建局部变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"Hello World\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World\n<span class=\"token comment\"># 将局部变量导出为全局变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">export</span> my_var\n<span class=\"token comment\"># 创建子shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span>\n<span class=\"token comment\"># 查看子shell继承的全局变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World\n<span class=\"token comment\"># 修改子shell的全局变量</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\">my_var</span><span class=\"token operator\">=</span><span class=\"token string\">\"NULL\"</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nNULL\n<span class=\"token comment\"># 退回父shell</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">exit</span>\n<span class=\"token builtin class-name\">exit</span>\n<span class=\"token comment\"># 父shell内的全局变量值没有变</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$my_var</span>\nHello World<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>bash默认的环境变量</p>\n<ol>\n<li>HOME：当前用户的家目录</li>\n<li>PATH：系统执行命令的路径</li>\n<li>USER：当前登录的用户名</li>\n<li>Shell：当前用户使用的默认Shell程序</li>\n<li>PWD：当前工作目录</li>\n<li>LANG：当前语言环境</li>\n<li>TERM：当前终端的类型</li>\n<li>PS1：命令提示符的格式</li>\n<li>HISTSIZE：命令历史记录的长度限制</li>\n<li>HISTFILESIZE：命令历史记录文件的大小限制</li>\n</ol>\n</li>\n<li><p>设置PATH环境变量</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看PATH变量的值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n<span class=\"token comment\"># 修改PATH变量，追加目录/home/centos</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token environment constant\">$PATH</span>:/home/centos\n<span class=\"token comment\"># 确认PATH变量的值</span>\n<span class=\"token punctuation\">[</span>centos@host1 test<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token environment constant\">$PATH</span>\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/centos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"变量赋值\"><a href=\"#变量赋值\" class=\"headerlink\" title=\"变量赋值\"></a>变量赋值</h2><p>Shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</p>\n<ul>\n<li><p>引用用户变量和环境变量</p>\n<ul>\n<li>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</li>\n<li>在脚本的整个生命周期里，Shell脚本中定义的变量会一直保持着它们的值，但在Shell脚本结束时会被删除掉。</li>\n<li>变量每次被引用时，都会输出当前赋给它的值。引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，Shell会将变量名解释成普通的文本字符串。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 通过引用环境变量进行赋值</span>\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token environment constant\">$HOME</span>\n\n<span class=\"token comment\"># 通过echo命令打印var1的值</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"var1 = <span class=\"token variable\">$var1</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nvar1 <span class=\"token operator\">=</span> /home/centos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>命令替换</p>\n<p>  Shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。有两种方法可以将命令输出赋给变量：</p>\n<ul>\n<li>反引号字符（&#96;）(与~同键位)</li>\n<li>$()格式</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 通过引用环境变量进行赋值</span>\n<span class=\"token assign-left variable\">today</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> +%y%m%d<span class=\"token variable\">`</span></span>\n\n<span class=\"token function\">touch</span> log.<span class=\"token variable\">$today</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n<span class=\"token comment\"># 创建了一个后缀为当前系统时间的日志文件</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">ls</span>\nlog.230616  test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>从键盘读入赋值</p>\n<p>  在Shell脚本中，Shell变量可以通过从键盘读入输入的内容并来赋值。命令格式为：<code>read –p [提示信息]：[变量名]</code></p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 使用read命令打印出提示信息，等待用户输入字符并回车后将字符保存在变量ip内</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"input ip:\"</span> <span class=\"token function\">ip</span>\n\n<span class=\"token comment\"># 使用ping检查用户所输入的ip地址的连通性</span>\n<span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c2</span> <span class=\"token variable\">$ip</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"变量的数值计算\"><a href=\"#变量的数值计算\" class=\"headerlink\" title=\"变量的数值计算\"></a>变量的数值计算</h2><ol>\n<li><p>使用 <code>expr</code>命令</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span> + <span class=\"token number\">2</span>\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span>+2\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span> * <span class=\"token number\">2</span>\n<span class=\"token function\">expr</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">\\</span>* <span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n<span class=\"token comment\"># expr的用法里运算符两侧需要添加空格</span>\n<span class=\"token number\">7</span>\n<span class=\"token number\">5</span>+2\n<span class=\"token comment\"># 星号*不能直接作为乘法运算符使用，需要用反斜杠进行转义</span>\nexpr: syntax error\n<span class=\"token number\">10</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用方括号</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">100</span>\n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span><span class=\"token number\">50</span>\n<span class=\"token assign-left variable\">var3</span><span class=\"token operator\">=</span><span class=\"token number\">45</span>\n\n<span class=\"token assign-left variable\">var4</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$var1</span> / <span class=\"token variable\">$var2</span><span class=\"token punctuation\">]</span>\n<span class=\"token assign-left variable\">var5</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$var1</span> / <span class=\"token variable\">$var3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token builtin class-name\">echo</span> var4 <span class=\"token operator\">=</span> <span class=\"token variable\">$var4</span>\n<span class=\"token builtin class-name\">echo</span> var5 <span class=\"token operator\">=</span> <span class=\"token variable\">$var5</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nvar4 <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n<span class=\"token comment\"># 使用方括号进行的数值计算在整数范围内</span>\nvar5 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在脚本内使用 <code>bc</code> 进行浮点数计算</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"scale=4; 3.44 / 5\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">bc</span><span class=\"token variable\">`</span></span>\n\n<span class=\"token builtin class-name\">echo</span> the answer is <span class=\"token variable\">$var1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nthe answer is .6880<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>let数值运算命令</p>\n<p> let数值符号可以直接进行计算，且不带回显功能，也就是说当使用let的时候，不再使用$引用变量。let运算命令的语法格式为：let 赋值表达式，其功能等同于<code>((赋值表达式))</code> 。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span>sum+8\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$sum</span>\n<span class=\"token number\">8</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>变量的自增</p>\n<p> Shell变量的自增运算符是<code>i++</code>和<code>++i</code>。<code>i++</code>表示<strong>先赋值再自加</strong>，<code>++i</code>表示<strong>先自加再赋值</strong>。</p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n\n<span class=\"token builtin class-name\">let</span> var1++\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var1</span>\n\n<span class=\"token builtin class-name\">let</span> ++var1\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var1</span>\n\n<span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span>var1++\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var2</span> <span class=\"token variable\">$var1</span>\n\n<span class=\"token builtin class-name\">let</span> <span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span>++var1\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$var2</span> <span class=\"token variable\">$var1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n<span class=\"token number\">11</span>\n<span class=\"token number\">12</span>\n<span class=\"token number\">12</span> <span class=\"token number\">13</span>\n<span class=\"token number\">14</span> <span class=\"token number\">14</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"特殊参数\"><a href=\"#特殊参数\" class=\"headerlink\" title=\"特殊参数\"></a>特殊参数</h2><ul>\n<li><p>位置参数</p>\n<p>  $0表示脚本名，$1表示脚本传递的第一个参数，$2 表示传递的第二个参数。</p>\n<p>  创建脚本test.sh、编辑以下内容：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> name is <span class=\"token variable\">$0</span>, var1 <span class=\"token operator\">=</span> <span class=\"token variable\">$1</span>, var2 <span class=\"token operator\">=</span> <span class=\"token variable\">$2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>  运行脚本：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nname is test.sh, var1 <span class=\"token operator\">=</span> , var2 <span class=\"token operator\">=</span>\n<span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh <span class=\"token number\">123</span> abc\nname is test.sh, var1 <span class=\"token operator\">=</span> <span class=\"token number\">123</span>, var2 <span class=\"token operator\">=</span> abc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>预定义参数</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$0</td>\n<td>脚本名</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>所有的参数（以整体的形式）</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>所以的参数（以数组的形式）</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>参数的个数</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前进程的PID</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>上一个后台进程的PID</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>上一个命令的返回值 0表示成功</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"Shell中的特殊符号\"><a href=\"#Shell中的特殊符号\" class=\"headerlink\" title=\"Shell中的特殊符号\"></a>Shell中的特殊符号</h2><ul>\n<li><p>“#”用在行首表示程序的注释。</p>\n</li>\n<li><p>“;” 作为命令的分隔符，分隔同一行上两个或者两个以上的命令。</p>\n</li>\n<li><p>“.”等价于source命令。它是bash中的一个内建命令。</p>\n<p>  “.”也可以作为文件名的一部分，如果”.”放在文件名的开头，那么这个文件将会成为”隐藏文件”，ls命令将不会正常显示出这个文件。</p>\n</li>\n<li><p>单引号’’，双引号””的区别是单引号’’剥夺了所有字符的特殊含义，单引号’’内就变成了单纯的字符。双引号””则对于双引号””内的参数替换($)和命令替换(&#96;&#96;)是个例外。</p>\n</li>\n</ul>\n"},{"title":"Shell条件测试","date":"2023-04-18T03:31:23.000Z","_content":"\n## 结构化命令概念\n\nShell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。  \n\n许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）  \n\n常见的条件测试命令： `if-then语句` 、 `case语句` 、 `for语句` 、 `while语句`\n\n## if条件语句\n\n- if条件语句通常由以下三个关键字组成：\n\n    1. if：用于指定要测试的条件\n    2. then：用于指定如果条件为true时要执行的指令\n    3. else：用于指定如果条件为false时要执行的指令\n\n    ```bash if条件语句格式\n    if condition\n    then\n        command1 \n        command2\n        ...\n        commandN \n    fi\n    ```\n\n在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。\n\n创建脚本test.sh、编辑以下内容：\n\n```bash\n#!/bin/bash\n\n# 测试的条件为`pwd`命令，根据命令的返回值进行跳转\nif pwd\nthen\n        echo \"it worked\"\nfi\n```\n\n运行脚本：\n\n```shell\n[centos@host1 ~]$ bash test.sh\n/home/centos\nit worked\n```\n\n- `if-then` 语句的另一种形式\n\n    ```bash\n    if command; then\n    commands\n    fi\n    ```\n\n- **练习**\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    # 待测试的用户名为centos\n    testuser=centos\n\n    # 根据grep语句的运行结果进行跳转，即文件/etc/passwd内是否有centos这个字符\n    if grep $testuser /etc/passwd\n    then\n            # 如果找到centos字符，打印以下信息\n            echo \"it worked\"\n            # 同时显示centos家目录下以.b开头的隐藏文件\n            ls -a /home/$testuser/.b*\n    fi\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    centos:x:1000:1000::/home/centos:/bin/bash\n    it worked\n    /home/centos/.bash_history  /home/centos/.bash_profile\n    /home/centos/.bash_logout   /home/centos/.bashrc\n    ```\n\n- `if-then-else` 双分支语句\n\n    当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then\n    语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。\n\n    在test.sh文件的基础上添加else语句\n\n    ```bash\n    #!/bin/bash\n\n    # 待测试的用户名为ubuntu\n    testuser=ubuntu\n\n    # 此时grep命令没有找到ubuntu字符，if语句跳转到else分支\n    if grep $testuser /etc/passwd\n    then\n            echo \"it worked\"\n            # 同时显示家目录下以.b开头的隐藏文件\n            ls -a /home/$testuser/.b*\n    else\n            echo \"user $testuser does not exist.\"\n    fi\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    user ubuntu does not exist.\n    ```\n\n- `if-then-elif-else` 多分支语句\n\n    ```bash\n    #!/bin/bash\n\n    testuser=ubuntu\n\n    if grep $testuser /etc/passwd\n    then\n            echo \"user: exist\"\n            ls -a /home/$testuser/.b*\n    else ls -d /home/$testuser 2>/dev/null\n    then\n            echo \"user $testuser does not exist, but has a directory\"\n    else\n            echo \"user $testuser does not exist\"\n            echo \"user $testuser does not have a directory\"\n    fi\n    ```\n\n- `test` 命令\n\n    如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。\n\n  - test命令格式\n\n    ```bash\n    if test condition\n    then\n     commands\n    fi\n    ```\n\n  - bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。\n\n    ```bash\n    if [ condition ]\n    then\n     commands\n    fi\n    ```\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    testuser=ubuntu\n\n    # 当变量testuser不为空时执行then语句的内容\n    if test $testuser\n    then\n            echo \"the variable exists\"\n    fi\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    the variable exists\n    ```\n\n    方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。\n    test命令可以判断三类条件：\n    1. 文件比较\n\n        这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：\n\n        ![3.Shell条件测试-2023-06-16-20-43-25](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png)\n\n        创建脚本test.sh、编辑以下内容：\n\n        ```bash\n        #!/bin/bash\n\n        dir=/home/centos\n\n        # 根据-d判断dir是否存在并且是一个目录文件\n        if [ -d $dir ]\n        then\n                echo \"directory $dir exists\"\n                cd $dir\n                ls\n        fi\n        ```\n\n        运行脚本：\n\n        ```shell\n        [centos@host1 ~]$ bash test.sh\n        directory /home/centos exists\n        log.230616  test.sh\n        ```\n\n    2. 字符串比较\n\n        ![3.Shell条件测试-2023-06-16-20-46-41](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png)\n\n        创建脚本test.sh、编辑以下内容：\n\n        ```bash\n        #!/bin/bash\n\n        testuser=centos\n\n        # 通过比较运算符等号=比较两个字符串，等式成立则表达式结果为真\n        if [ $USER = $testuser ]\n        then\n                echo \"welcome $testuser\"\n        fi\n        ```\n\n        运行脚本：\n\n        ```shell\n        [centos@host1 ~]$ bash test.sh\n        welcome centos\n        ```\n\n        - 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名\n\n        创建脚本test.sh、编辑以下内容：\n\n        ```bash\n        #!/bin/bash\n\n        var1=temp\n        var2=tmp\n\n        # 在条件比较时直接使用大于号>不能表示大于的含义，需要使用\\>在表示大于\n        if [ $var1 > $var2 ]\n        then\n                echo \"$var1 greater than $var2\"\n        fi\n        ```\n\n        运行脚本：\n\n        ```shell\n        [centos@host1 ~]$ bash test.sh\n        temp greater than tmp\n        ```\n\n    3. 数值比较\n\n        数值条件测试可以用在数字和变量上。\n\n       ![3.Shell条件测试-2023-06-16-21-06-44](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png)\n\n## 复合条件测试\n\n- `&&和||` 用法\n\n    ```bash\n    [ condition1 ] && [ condition2 ]\n    [ condition1 ] || [ condition2 ]\n    ```\n\n  - 第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。\n  - 第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。\n\n## case命令\n\n在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。\n\ncase语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：\n\n```bash\ncase expression in\n  pattern1)\n    command1\n    ;;\n  pattern2)\n    command2\n    ;;\n  pattern3)\n    command3\n    ;;\n  *)\n    default_command\n    ;;\nesac\n```\n\n其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**`;;`**表示命令结束，**`*)`**表示如果所有模式都不匹配时要执行的默认命令。\n\n创建脚本test.sh、编辑以下内容：\n\n```bash\n#!/bin/bash\n\nfruit=\"apple\"\n\ncase $fruit in\n        apple)\n                echo \"It's an apple.\"\n                ;;\n        banana)\n                echo \"It's a banana.\"\n                ;;\n        # *用来匹配之前所有匹配模式都匹配不到的情况\n        *)\n                echo \"It's not an apple or a banana.\"\n                ;;\nesac\n```\n\n运行脚本：\n\n```shell\n[centos@host1 ~]$ bash test.sh\nIt's an apple.\n```\n\n## 练习题\n\n1. 使用 `read`要求用户输入一个数字。\n2. 使用 `if`判断该数字是否在`0-9`之间，如果不满足则停止脚本。\n3. 然后使用 **`case`** 语句输出对应数字`0-3`的英文，对于其他数字输出一个提示“该数字在4-9之间”。\n","source":"_posts/linux_shell/3.Shell条件测试.md","raw":"---\ntitle: Shell条件测试\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n## 结构化命令概念\n\nShell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。  \n\n许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）  \n\n常见的条件测试命令： `if-then语句` 、 `case语句` 、 `for语句` 、 `while语句`\n\n## if条件语句\n\n- if条件语句通常由以下三个关键字组成：\n\n    1. if：用于指定要测试的条件\n    2. then：用于指定如果条件为true时要执行的指令\n    3. else：用于指定如果条件为false时要执行的指令\n\n    ```bash if条件语句格式\n    if condition\n    then\n        command1 \n        command2\n        ...\n        commandN \n    fi\n    ```\n\n在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。\n\n创建脚本test.sh、编辑以下内容：\n\n```bash\n#!/bin/bash\n\n# 测试的条件为`pwd`命令，根据命令的返回值进行跳转\nif pwd\nthen\n        echo \"it worked\"\nfi\n```\n\n运行脚本：\n\n```shell\n[centos@host1 ~]$ bash test.sh\n/home/centos\nit worked\n```\n\n- `if-then` 语句的另一种形式\n\n    ```bash\n    if command; then\n    commands\n    fi\n    ```\n\n- **练习**\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    # 待测试的用户名为centos\n    testuser=centos\n\n    # 根据grep语句的运行结果进行跳转，即文件/etc/passwd内是否有centos这个字符\n    if grep $testuser /etc/passwd\n    then\n            # 如果找到centos字符，打印以下信息\n            echo \"it worked\"\n            # 同时显示centos家目录下以.b开头的隐藏文件\n            ls -a /home/$testuser/.b*\n    fi\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    centos:x:1000:1000::/home/centos:/bin/bash\n    it worked\n    /home/centos/.bash_history  /home/centos/.bash_profile\n    /home/centos/.bash_logout   /home/centos/.bashrc\n    ```\n\n- `if-then-else` 双分支语句\n\n    当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then\n    语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。\n\n    在test.sh文件的基础上添加else语句\n\n    ```bash\n    #!/bin/bash\n\n    # 待测试的用户名为ubuntu\n    testuser=ubuntu\n\n    # 此时grep命令没有找到ubuntu字符，if语句跳转到else分支\n    if grep $testuser /etc/passwd\n    then\n            echo \"it worked\"\n            # 同时显示家目录下以.b开头的隐藏文件\n            ls -a /home/$testuser/.b*\n    else\n            echo \"user $testuser does not exist.\"\n    fi\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    user ubuntu does not exist.\n    ```\n\n- `if-then-elif-else` 多分支语句\n\n    ```bash\n    #!/bin/bash\n\n    testuser=ubuntu\n\n    if grep $testuser /etc/passwd\n    then\n            echo \"user: exist\"\n            ls -a /home/$testuser/.b*\n    else ls -d /home/$testuser 2>/dev/null\n    then\n            echo \"user $testuser does not exist, but has a directory\"\n    else\n            echo \"user $testuser does not exist\"\n            echo \"user $testuser does not have a directory\"\n    fi\n    ```\n\n- `test` 命令\n\n    如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。\n\n  - test命令格式\n\n    ```bash\n    if test condition\n    then\n     commands\n    fi\n    ```\n\n  - bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。\n\n    ```bash\n    if [ condition ]\n    then\n     commands\n    fi\n    ```\n\n    创建脚本test.sh、编辑以下内容：\n\n    ```bash\n    #!/bin/bash\n\n    testuser=ubuntu\n\n    # 当变量testuser不为空时执行then语句的内容\n    if test $testuser\n    then\n            echo \"the variable exists\"\n    fi\n    ```\n\n    运行脚本：\n\n    ```shell\n    [centos@host1 ~]$ bash test.sh\n    the variable exists\n    ```\n\n    方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。\n    test命令可以判断三类条件：\n    1. 文件比较\n\n        这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：\n\n        ![3.Shell条件测试-2023-06-16-20-43-25](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png)\n\n        创建脚本test.sh、编辑以下内容：\n\n        ```bash\n        #!/bin/bash\n\n        dir=/home/centos\n\n        # 根据-d判断dir是否存在并且是一个目录文件\n        if [ -d $dir ]\n        then\n                echo \"directory $dir exists\"\n                cd $dir\n                ls\n        fi\n        ```\n\n        运行脚本：\n\n        ```shell\n        [centos@host1 ~]$ bash test.sh\n        directory /home/centos exists\n        log.230616  test.sh\n        ```\n\n    2. 字符串比较\n\n        ![3.Shell条件测试-2023-06-16-20-46-41](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png)\n\n        创建脚本test.sh、编辑以下内容：\n\n        ```bash\n        #!/bin/bash\n\n        testuser=centos\n\n        # 通过比较运算符等号=比较两个字符串，等式成立则表达式结果为真\n        if [ $USER = $testuser ]\n        then\n                echo \"welcome $testuser\"\n        fi\n        ```\n\n        运行脚本：\n\n        ```shell\n        [centos@host1 ~]$ bash test.sh\n        welcome centos\n        ```\n\n        - 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名\n\n        创建脚本test.sh、编辑以下内容：\n\n        ```bash\n        #!/bin/bash\n\n        var1=temp\n        var2=tmp\n\n        # 在条件比较时直接使用大于号>不能表示大于的含义，需要使用\\>在表示大于\n        if [ $var1 > $var2 ]\n        then\n                echo \"$var1 greater than $var2\"\n        fi\n        ```\n\n        运行脚本：\n\n        ```shell\n        [centos@host1 ~]$ bash test.sh\n        temp greater than tmp\n        ```\n\n    3. 数值比较\n\n        数值条件测试可以用在数字和变量上。\n\n       ![3.Shell条件测试-2023-06-16-21-06-44](https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png)\n\n## 复合条件测试\n\n- `&&和||` 用法\n\n    ```bash\n    [ condition1 ] && [ condition2 ]\n    [ condition1 ] || [ condition2 ]\n    ```\n\n  - 第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。\n  - 第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。\n\n## case命令\n\n在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。\n\ncase语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：\n\n```bash\ncase expression in\n  pattern1)\n    command1\n    ;;\n  pattern2)\n    command2\n    ;;\n  pattern3)\n    command3\n    ;;\n  *)\n    default_command\n    ;;\nesac\n```\n\n其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**`;;`**表示命令结束，**`*)`**表示如果所有模式都不匹配时要执行的默认命令。\n\n创建脚本test.sh、编辑以下内容：\n\n```bash\n#!/bin/bash\n\nfruit=\"apple\"\n\ncase $fruit in\n        apple)\n                echo \"It's an apple.\"\n                ;;\n        banana)\n                echo \"It's a banana.\"\n                ;;\n        # *用来匹配之前所有匹配模式都匹配不到的情况\n        *)\n                echo \"It's not an apple or a banana.\"\n                ;;\nesac\n```\n\n运行脚本：\n\n```shell\n[centos@host1 ~]$ bash test.sh\nIt's an apple.\n```\n\n## 练习题\n\n1. 使用 `read`要求用户输入一个数字。\n2. 使用 `if`判断该数字是否在`0-9`之间，如果不满足则停止脚本。\n3. 然后使用 **`case`** 语句输出对应数字`0-3`的英文，对于其他数字输出一个提示“该数字在4-9之间”。\n","slug":"linux_shell/3.Shell条件测试","published":1,"updated":"2023-06-16T13:12:59.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04k000a1dnz8xoe9jij","content":"<h2 id=\"结构化命令概念\"><a href=\"#结构化命令概念\" class=\"headerlink\" title=\"结构化命令概念\"></a>结构化命令概念</h2><p>Shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。  </p>\n<p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）  </p>\n<p>常见的条件测试命令： <code>if-then语句</code> 、 <code>case语句</code> 、 <code>for语句</code> 、 <code>while语句</code></p>\n<h2 id=\"if条件语句\"><a href=\"#if条件语句\" class=\"headerlink\" title=\"if条件语句\"></a>if条件语句</h2><ul>\n<li><p>if条件语句通常由以下三个关键字组成：</p>\n<ol>\n<li>if：用于指定要测试的条件</li>\n<li>then：用于指定如果条件为true时要执行的指令</li>\n<li>else：用于指定如果条件为false时要执行的指令</li>\n</ol>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><div class=\"caption\"><span>if条件语句格式</span></div><code class=\"language-bash\"><span class=\"token keyword\">if</span> condition\n<span class=\"token keyword\">then</span>\n    command1 \n    command2\n    <span class=\"token punctuation\">..</span>.\n    commandN \n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。</p>\n<p>创建脚本test.sh、编辑以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 测试的条件为`pwd`命令，根据命令的返回值进行跳转</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it worked\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n/home/centos\nit worked<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p><code>if-then</code> 语句的另一种形式</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">command</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\ncommands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>练习</strong></p>\n<p>  创建脚本test.sh、编辑以下内容：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 待测试的用户名为centos</span>\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>centos\n\n<span class=\"token comment\"># 根据grep语句的运行结果进行跳转，即文件/etc/passwd内是否有centos这个字符</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span>\n        <span class=\"token comment\"># 如果找到centos字符，打印以下信息</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it worked\"</span>\n        <span class=\"token comment\"># 同时显示centos家目录下以.b开头的隐藏文件</span>\n        <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span> /home/<span class=\"token variable\">$testuser</span>/.b*\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  运行脚本：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\ncentos:x:1000:1000::/home/centos:/bin/bash\nit worked\n/home/centos/.bash_history  /home/centos/.bash_profile\n/home/centos/.bash_logout   /home/centos/.bashrc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>if-then-else</code> 双分支语句</p>\n<p>  当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then<br>  语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。</p>\n<p>  在test.sh文件的基础上添加else语句</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 待测试的用户名为ubuntu</span>\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>ubuntu\n\n<span class=\"token comment\"># 此时grep命令没有找到ubuntu字符，if语句跳转到else分支</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it worked\"</span>\n        <span class=\"token comment\"># 同时显示家目录下以.b开头的隐藏文件</span>\n        <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span> /home/<span class=\"token variable\">$testuser</span>/.b*\n<span class=\"token keyword\">else</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not exist.\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  运行脚本：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nuser ubuntu does not exist.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>if-then-elif-else</code> 多分支语句</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>ubuntu\n\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user: exist\"</span>\n        <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span> /home/<span class=\"token variable\">$testuser</span>/.b*\n<span class=\"token keyword\">else</span> <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-d</span> /home/<span class=\"token variable\">$testuser</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not exist, but has a directory\"</span>\n<span class=\"token keyword\">else</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not exist\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not have a directory\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>test</code> 命令</p>\n<p>  如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。</p>\n<ul>\n<li><p>test命令格式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> condition\n<span class=\"token keyword\">then</span>\n commands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n commands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>创建脚本test.sh、编辑以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>ubuntu\n\n<span class=\"token comment\"># 当变量testuser不为空时执行then语句的内容</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> <span class=\"token variable\">$testuser</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"the variable exists\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nthe variable exists<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。<br>test命令可以判断三类条件：</p>\n<ol>\n<li><p>文件比较</p>\n<p> 这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png\" alt=\"3.Shell条件测试-2023-06-16-20-43-25\"></p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">dir</span><span class=\"token operator\">=</span>/home/centos\n\n<span class=\"token comment\"># 根据-d判断dir是否存在并且是一个目录文件</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-d</span> <span class=\"token variable\">$dir</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"directory <span class=\"token variable\">$dir</span> exists\"</span>\n        <span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$dir</span>\n        <span class=\"token function\">ls</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\ndirectory /home/centos exists\nlog.230616  test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>字符串比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png\" alt=\"3.Shell条件测试-2023-06-16-20-46-41\"></p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>centos\n\n<span class=\"token comment\"># 通过比较运算符等号=比较两个字符串，等式成立则表达式结果为真</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$USER</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$testuser</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"welcome <span class=\"token variable\">$testuser</span>\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nwelcome centos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名</li>\n</ul>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span>temp\n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span>tmp\n\n<span class=\"token comment\"># 在条件比较时直接使用大于号>不能表示大于的含义，需要使用\\>在表示大于</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$var1</span> <span class=\"token operator\">></span> <span class=\"token variable\">$var2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$var1</span> greater than <span class=\"token variable\">$var2</span>\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\ntemp greater than tmp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>数值比较</p>\n<p> 数值条件测试可以用在数字和变量上。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png\" alt=\"3.Shell条件测试-2023-06-16-21-06-44\"></p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"复合条件测试\"><a href=\"#复合条件测试\" class=\"headerlink\" title=\"复合条件测试\"></a>复合条件测试</h2><ul>\n<li><p><code>&amp;&amp;和||</code> 用法</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span> condition1 <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span> condition2 <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span> condition1 <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> condition2 <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。</li>\n<li>第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"case命令\"><a href=\"#case命令\" class=\"headerlink\" title=\"case命令\"></a>case命令</h2><p>在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。</p>\n<p>case语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">case</span> expression <span class=\"token keyword\">in</span>\n  pattern1<span class=\"token punctuation\">)</span>\n    command1\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  pattern2<span class=\"token punctuation\">)</span>\n    command2\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  pattern3<span class=\"token punctuation\">)</span>\n    command3\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  *<span class=\"token punctuation\">)</span>\n    default_command\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**<code>;;</code><strong>表示命令结束，</strong><code>*)</code>**表示如果所有模式都不匹配时要执行的默认命令。</p>\n<p>创建脚本test.sh、编辑以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">fruit</span><span class=\"token operator\">=</span><span class=\"token string\">\"apple\"</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$fruit</span> <span class=\"token keyword\">in</span>\n        apple<span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"It's an apple.\"</span>\n                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        banana<span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"It's a banana.\"</span>\n                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\"># *用来匹配之前所有匹配模式都匹配不到的情况</span>\n        *<span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"It's not an apple or a banana.\"</span>\n                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nIt's an apple.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"练习题\"><a href=\"#练习题\" class=\"headerlink\" title=\"练习题\"></a>练习题</h2><ol>\n<li>使用 <code>read</code>要求用户输入一个数字。</li>\n<li>使用 <code>if</code>判断该数字是否在<code>0-9</code>之间，如果不满足则停止脚本。</li>\n<li>然后使用 <strong><code>case</code></strong> 语句输出对应数字<code>0-3</code>的英文，对于其他数字输出一个提示“该数字在4-9之间”。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"结构化命令概念\"><a href=\"#结构化命令概念\" class=\"headerlink\" title=\"结构化命令概念\"></a>结构化命令概念</h2><p>Shell按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。  </p>\n<p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令（structured command）  </p>\n<p>常见的条件测试命令： <code>if-then语句</code> 、 <code>case语句</code> 、 <code>for语句</code> 、 <code>while语句</code></p>\n<h2 id=\"if条件语句\"><a href=\"#if条件语句\" class=\"headerlink\" title=\"if条件语句\"></a>if条件语句</h2><ul>\n<li><p>if条件语句通常由以下三个关键字组成：</p>\n<ol>\n<li>if：用于指定要测试的条件</li>\n<li>then：用于指定如果条件为true时要执行的指令</li>\n<li>else：用于指定如果条件为false时要执行的指令</li>\n</ol>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><div class=\"caption\"><span>if条件语句格式</span></div><code class=\"language-bash\"><span class=\"token keyword\">if</span> condition\n<span class=\"token keyword\">then</span>\n    command1 \n    command2\n    <span class=\"token punctuation\">..</span>.\n    commandN \n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>在其他编程语言中，if语句之后的对象是一个等式，这个等式的求值结果为TRUE或FALSE。但bash shell的if语句并不是这么做的。bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。</p>\n<p>创建脚本test.sh、编辑以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 测试的条件为`pwd`命令，根据命令的返回值进行跳转</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">pwd</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it worked\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\n/home/centos\nit worked<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p><code>if-then</code> 语句的另一种形式</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">command</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\ncommands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>练习</strong></p>\n<p>  创建脚本test.sh、编辑以下内容：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 待测试的用户名为centos</span>\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>centos\n\n<span class=\"token comment\"># 根据grep语句的运行结果进行跳转，即文件/etc/passwd内是否有centos这个字符</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span>\n        <span class=\"token comment\"># 如果找到centos字符，打印以下信息</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it worked\"</span>\n        <span class=\"token comment\"># 同时显示centos家目录下以.b开头的隐藏文件</span>\n        <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span> /home/<span class=\"token variable\">$testuser</span>/.b*\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  运行脚本：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\ncentos:x:1000:1000::/home/centos:/bin/bash\nit worked\n/home/centos/.bash_history  /home/centos/.bash_profile\n/home/centos/.bash_logout   /home/centos/.bashrc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>if-then-else</code> 双分支语句</p>\n<p>  当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then<br>  语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。</p>\n<p>  在test.sh文件的基础上添加else语句</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 待测试的用户名为ubuntu</span>\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>ubuntu\n\n<span class=\"token comment\"># 此时grep命令没有找到ubuntu字符，if语句跳转到else分支</span>\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"it worked\"</span>\n        <span class=\"token comment\"># 同时显示家目录下以.b开头的隐藏文件</span>\n        <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span> /home/<span class=\"token variable\">$testuser</span>/.b*\n<span class=\"token keyword\">else</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not exist.\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  运行脚本：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nuser ubuntu does not exist.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>if-then-elif-else</code> 多分支语句</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>ubuntu\n\n<span class=\"token keyword\">if</span> <span class=\"token function\">grep</span> <span class=\"token variable\">$testuser</span> /etc/passwd\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user: exist\"</span>\n        <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span> /home/<span class=\"token variable\">$testuser</span>/.b*\n<span class=\"token keyword\">else</span> <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-d</span> /home/<span class=\"token variable\">$testuser</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not exist, but has a directory\"</span>\n<span class=\"token keyword\">else</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not exist\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"user <span class=\"token variable\">$testuser</span> does not have a directory\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>test</code> 命令</p>\n<p>  如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。如果条件不成立，test命令就会退出并返回非零的退出状态码，这使得if-then语句不会再被执行。</p>\n<ul>\n<li><p>test命令格式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> condition\n<span class=\"token keyword\">then</span>\n commands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> condition <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n commands\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>创建脚本test.sh、编辑以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>ubuntu\n\n<span class=\"token comment\"># 当变量testuser不为空时执行then语句的内容</span>\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> <span class=\"token variable\">$testuser</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"the variable exists\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nthe variable exists<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。<br>test命令可以判断三类条件：</p>\n<ol>\n<li><p>文件比较</p>\n<p> 这些测试条件使你能够在shell脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中，文件比较的操作符如下：</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-43-25.png\" alt=\"3.Shell条件测试-2023-06-16-20-43-25\"></p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">dir</span><span class=\"token operator\">=</span>/home/centos\n\n<span class=\"token comment\"># 根据-d判断dir是否存在并且是一个目录文件</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-d</span> <span class=\"token variable\">$dir</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"directory <span class=\"token variable\">$dir</span> exists\"</span>\n        <span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$dir</span>\n        <span class=\"token function\">ls</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\ndirectory /home/centos exists\nlog.230616  test.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>字符串比较</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-20-46-41.png\" alt=\"3.Shell条件测试-2023-06-16-20-46-41\"></p>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">testuser</span><span class=\"token operator\">=</span>centos\n\n<span class=\"token comment\"># 通过比较运算符等号=比较两个字符串，等式成立则表达式结果为真</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token environment constant\">$USER</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$testuser</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"welcome <span class=\"token variable\">$testuser</span>\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nwelcome centos<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名</li>\n</ul>\n<p> 创建脚本test.sh、编辑以下内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">var1</span><span class=\"token operator\">=</span>temp\n<span class=\"token assign-left variable\">var2</span><span class=\"token operator\">=</span>tmp\n\n<span class=\"token comment\"># 在条件比较时直接使用大于号>不能表示大于的含义，需要使用\\>在表示大于</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$var1</span> <span class=\"token operator\">></span> <span class=\"token variable\">$var2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$var1</span> greater than <span class=\"token variable\">$var2</span>\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\ntemp greater than tmp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>数值比较</p>\n<p> 数值条件测试可以用在数字和变量上。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note3.Shell%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95-2023-06-16-21-06-44.png\" alt=\"3.Shell条件测试-2023-06-16-21-06-44\"></p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"复合条件测试\"><a href=\"#复合条件测试\" class=\"headerlink\" title=\"复合条件测试\"></a>复合条件测试</h2><ul>\n<li><p><code>&amp;&amp;和||</code> 用法</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span> condition1 <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">[</span> condition2 <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span> condition1 <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> condition2 <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>第一种布尔运算使用AND布尔运算符来组合两个条件。要让then部分的命令执行，两个条件都必须满足。</li>\n<li>第二种布尔运算使用OR布尔运算符来组合两个条件。如果任意条件为TRUE，then部分的命令就会执行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"case命令\"><a href=\"#case命令\" class=\"headerlink\" title=\"case命令\"></a>case命令</h2><p>在shell编程中，case语句是一种多分支条件语句，用于测试变量或表达式是否与某些模式匹配，并执行相应的命令。</p>\n<p>case语句通常用于替代if-then-else语句，特别是在需要测试一个变量或表达式是否匹配多个模式的情况下。case语句的语法结构如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">case</span> expression <span class=\"token keyword\">in</span>\n  pattern1<span class=\"token punctuation\">)</span>\n    command1\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  pattern2<span class=\"token punctuation\">)</span>\n    command2\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  pattern3<span class=\"token punctuation\">)</span>\n    command3\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n  *<span class=\"token punctuation\">)</span>\n    default_command\n    <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，expression是要测试的变量或表达式，pattern1、pattern2、pattern3等是匹配模式，command1、command2、command3等是匹配模式成立时要执行的命令，**<code>;;</code><strong>表示命令结束，</strong><code>*)</code>**表示如果所有模式都不匹配时要执行的默认命令。</p>\n<p>创建脚本test.sh、编辑以下内容：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">fruit</span><span class=\"token operator\">=</span><span class=\"token string\">\"apple\"</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$fruit</span> <span class=\"token keyword\">in</span>\n        apple<span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"It's an apple.\"</span>\n                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        banana<span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"It's a banana.\"</span>\n                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\"># *用来匹配之前所有匹配模式都匹配不到的情况</span>\n        *<span class=\"token punctuation\">)</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"It's not an apple or a banana.\"</span>\n                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>运行脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>centos@host1 ~<span class=\"token punctuation\">]</span>$ <span class=\"token function\">bash</span> test.sh\nIt's an apple.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"练习题\"><a href=\"#练习题\" class=\"headerlink\" title=\"练习题\"></a>练习题</h2><ol>\n<li>使用 <code>read</code>要求用户输入一个数字。</li>\n<li>使用 <code>if</code>判断该数字是否在<code>0-9</code>之间，如果不满足则停止脚本。</li>\n<li>然后使用 <strong><code>case</code></strong> 语句输出对应数字<code>0-3</code>的英文，对于其他数字输出一个提示“该数字在4-9之间”。</li>\n</ol>\n"},{"title":"Shell循环","date":"2023-04-18T03:31:23.000Z","_content":"\n## 回顾\n\n上一章学习的结构化命令中的 `if-then` 和 `case` 语句，其中 `if-then` 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。\n\n在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括`for`、`while`、`until`三种。\n\n## for 循环结构\n\n`for` 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：\n\n```bash\nfor 变量名 in 列表\ndo\n    循环体\ndone\n\n```\n\n其中，`变量名`是一个新的变量，用于存储列表中的每个元素；`列表`是一个由空格分隔的参数列表。\n\n例如，下面的代码中，`for` 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：\n\n```bash\n#!/bin/bash\nfor i in 1 2 3 4 5\ndo\n    echo \"列表中的元素：$i\"\ndone,rk\n\necho \"i = $i\"\n\n```\n\n以上代码会输出以下结果：\n\n```text\n列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\ni = 5\n```\n\n- 读取列表中的复杂值\n\n    ```bash\n    #!/bin/bash\n    for i in I don't know if this'll work\n    do\n        echo \"word:$i\"\n    done\n    ```\n\n    以上代码输出以下结果：\n\n    ```text\n    word:I\n    word:dont know if thisll\n    word:work\n    ```\n\n  - 两种方法解决列表中单引号引用的问题\n\n    1. 使用转义字符（反斜杠）将单引号转义\n\n    2. 使用双引号定义用到单引号的值\n\n    ```bash\n    #!/bin/bash\n    for i in I don\\'t know if this\\'ll work\n    do\n        echo \"word:$i\"\n    done\n    \n    for i in I \"don't\" know if \"this'll\" work\n    do\n        echo \"word:$i\"\n    done\n    ```\n\n  - 使用双引号引用输出多个单词\n\n    ```bash\n    #!/bin/bash\n    for i in \"1 2\" \"3 4\" 5\n    do\n        echo \"列表中的元素：$i\"\n    done\n    \n    echo \"i = $i\"\n    ```\n\n    以上代码输出以下结果：\n\n    ```text\n    列表中的元素：1 2\n    列表中的元素：3 4\n    列表中的元素：5\n    i = 5\n    ```\n\n- 从变量读取列表\n\n    ```bash\n    #!/bin/bash\n    \n    list=\"1 2 3 4 5\"\n    list=$list\" 6\"\n    \n    for i in $list\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n\n    以上代码输出以下结果：\n\n    ```bash\n    列表中的元素：1\n    列表中的元素：2\n    列表中的元素：3\n    列表中的元素：4\n    列表中的元素：5\n    列表中的元素：6\n    ```\n\n- 通过命令读取\n\n    ```bash\n    #!/bin/bash\n    \n    IFS=$'\\n'\n    \n    cat > test.sh <<EOF\n    1 2 3\n    2\n    3\n    4\n    5\n    EOF\n    \n    for i in `cat test.sh`\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n\n- 用通配符读取目录\n\n    在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。\n\n    常见的通配符包括：\n\n  - `*`：匹配任意长度的任意字符，包括空字符串。\n  - `?`：匹配任意一个字符。\n  - `[...]`：匹配括号内列举的任意一个字符。\n  - `[^...]`：匹配除了括号内列举的任意一个字符以外的所有字符。\n\n    以下是一些通配符匹配的示例：\n\n  - `*.txt`：匹配所有以 `.txt` 结尾的文件，如 `file1.txt`、`file2.txt` 等。\n  - `file?.txt`：匹配所有文件名为 `file` 开头，后面跟着任意一个字符，最后以 `.txt` 结尾的文件，如 `file1.txt`、`fileA.txt` 等。\n  - `[abc].txt`：匹配所有文件名为 `a.txt`、`b.txt`、`c.txt` 的文件。\n  - `[^abc].txt`：匹配除了文件名为 `a.txt`、`b.txt`、`c.txt` 以外的所有以 `.txt` 结尾的文件。\n\n    ```bash\n    #!/bin/bash\n    \n    touch ~/file{1..2}\n    mkdir ~/dir{1..3}\n    \n    for file in ~/*\n    do\n        if [ -d \"$file\" ]\n        then\n         echo \"$file is a directory\"\n        elif [ -f \"$file\" ]\n        then\n            echo \"$file is a file\"\n        fi\n    done\n    ```\n\n    练习：\n\n    通过shell脚本实现批量主机检测\n\n    ```bash\n    #!/bin/bash\n    >ip.txt\n    \n    for i in {2..254}\n    do\n        {\n        ip=192.168.13.$i\n        ping -c1 -W1 $ip &>/dev/null\n        if [ $? -eq 0 ]\n        then\n        echo \"$ip\" |tee -a ip.txt\n      fi\n      }&\n    done\n    wait\n    echo \"finish...\"\n    ```\n\n## while 循环结构\n\n`while` 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：\n\n```bash\nwhile [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。\n\n例如，下面的代码中，`while` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```text\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n## until 循环结构\n\n`until` 循环与 `while` 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：\n\n```bash\nuntil [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。\n\n例如，下面的代码中，`until` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/bash\ni=1\nuntil [ $i -gt 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```text\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n## 循环控制语句结构\n\n在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：\n\n- `break`语句：用于强制退出循环，跳出循环体，执行循环后面的语句。\n- `continue`语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。\n- `return`语句：用于退出函数，返回到函数调用处。\n\n例如，下面的代码演示了如何在循环中使用 `break` 和 `continue` 语句：\n\n```bash\n#!/bin/bash\ni=1\nwhile [ $i -le 100 ]\ndo\n    if [ $i -eq 3 ]\n    then\n        echo \"跳过第 $i 次迭代\"\n        i=$(( $i + 1 ))\n        continue\n    fi\n    if [ $i -eq 5 ]\n    then\n        echo \"退出循环\"\n        break\n    fi\n    echo \"第 $i 次迭代\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```text\n第 1 次迭代\n第 2 次迭代\n跳过第 3 次迭代\n第 4 次迭代\n退出循环\n\n```\n","source":"_posts/linux_shell/4.Shell循环.md","raw":"---\ntitle: Shell循环\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n## 回顾\n\n上一章学习的结构化命令中的 `if-then` 和 `case` 语句，其中 `if-then` 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。\n\n在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括`for`、`while`、`until`三种。\n\n## for 循环结构\n\n`for` 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：\n\n```bash\nfor 变量名 in 列表\ndo\n    循环体\ndone\n\n```\n\n其中，`变量名`是一个新的变量，用于存储列表中的每个元素；`列表`是一个由空格分隔的参数列表。\n\n例如，下面的代码中，`for` 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：\n\n```bash\n#!/bin/bash\nfor i in 1 2 3 4 5\ndo\n    echo \"列表中的元素：$i\"\ndone,rk\n\necho \"i = $i\"\n\n```\n\n以上代码会输出以下结果：\n\n```text\n列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\ni = 5\n```\n\n- 读取列表中的复杂值\n\n    ```bash\n    #!/bin/bash\n    for i in I don't know if this'll work\n    do\n        echo \"word:$i\"\n    done\n    ```\n\n    以上代码输出以下结果：\n\n    ```text\n    word:I\n    word:dont know if thisll\n    word:work\n    ```\n\n  - 两种方法解决列表中单引号引用的问题\n\n    1. 使用转义字符（反斜杠）将单引号转义\n\n    2. 使用双引号定义用到单引号的值\n\n    ```bash\n    #!/bin/bash\n    for i in I don\\'t know if this\\'ll work\n    do\n        echo \"word:$i\"\n    done\n    \n    for i in I \"don't\" know if \"this'll\" work\n    do\n        echo \"word:$i\"\n    done\n    ```\n\n  - 使用双引号引用输出多个单词\n\n    ```bash\n    #!/bin/bash\n    for i in \"1 2\" \"3 4\" 5\n    do\n        echo \"列表中的元素：$i\"\n    done\n    \n    echo \"i = $i\"\n    ```\n\n    以上代码输出以下结果：\n\n    ```text\n    列表中的元素：1 2\n    列表中的元素：3 4\n    列表中的元素：5\n    i = 5\n    ```\n\n- 从变量读取列表\n\n    ```bash\n    #!/bin/bash\n    \n    list=\"1 2 3 4 5\"\n    list=$list\" 6\"\n    \n    for i in $list\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n\n    以上代码输出以下结果：\n\n    ```bash\n    列表中的元素：1\n    列表中的元素：2\n    列表中的元素：3\n    列表中的元素：4\n    列表中的元素：5\n    列表中的元素：6\n    ```\n\n- 通过命令读取\n\n    ```bash\n    #!/bin/bash\n    \n    IFS=$'\\n'\n    \n    cat > test.sh <<EOF\n    1 2 3\n    2\n    3\n    4\n    5\n    EOF\n    \n    for i in `cat test.sh`\n    do\n        echo \"列表中的元素：$i\"\n    done\n    ```\n\n- 用通配符读取目录\n\n    在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。\n\n    常见的通配符包括：\n\n  - `*`：匹配任意长度的任意字符，包括空字符串。\n  - `?`：匹配任意一个字符。\n  - `[...]`：匹配括号内列举的任意一个字符。\n  - `[^...]`：匹配除了括号内列举的任意一个字符以外的所有字符。\n\n    以下是一些通配符匹配的示例：\n\n  - `*.txt`：匹配所有以 `.txt` 结尾的文件，如 `file1.txt`、`file2.txt` 等。\n  - `file?.txt`：匹配所有文件名为 `file` 开头，后面跟着任意一个字符，最后以 `.txt` 结尾的文件，如 `file1.txt`、`fileA.txt` 等。\n  - `[abc].txt`：匹配所有文件名为 `a.txt`、`b.txt`、`c.txt` 的文件。\n  - `[^abc].txt`：匹配除了文件名为 `a.txt`、`b.txt`、`c.txt` 以外的所有以 `.txt` 结尾的文件。\n\n    ```bash\n    #!/bin/bash\n    \n    touch ~/file{1..2}\n    mkdir ~/dir{1..3}\n    \n    for file in ~/*\n    do\n        if [ -d \"$file\" ]\n        then\n         echo \"$file is a directory\"\n        elif [ -f \"$file\" ]\n        then\n            echo \"$file is a file\"\n        fi\n    done\n    ```\n\n    练习：\n\n    通过shell脚本实现批量主机检测\n\n    ```bash\n    #!/bin/bash\n    >ip.txt\n    \n    for i in {2..254}\n    do\n        {\n        ip=192.168.13.$i\n        ping -c1 -W1 $ip &>/dev/null\n        if [ $? -eq 0 ]\n        then\n        echo \"$ip\" |tee -a ip.txt\n      fi\n      }&\n    done\n    wait\n    echo \"finish...\"\n    ```\n\n## while 循环结构\n\n`while` 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：\n\n```bash\nwhile [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。\n\n例如，下面的代码中，`while` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/sh\ni=1\nwhile [ $i -le 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```text\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n## until 循环结构\n\n`until` 循环与 `while` 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：\n\n```bash\nuntil [ 条件 ]\ndo\n    循环体\ndone\n\n```\n\n其中，`条件`是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。\n\n例如，下面的代码中，`until` 循环会一直执行，直到变量 `i` 的值达到 5：\n\n```bash\n#!/bin/bash\ni=1\nuntil [ $i -gt 5 ]\ndo\n    echo \"当前变量的值是 $i\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```text\n当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n\n```\n\n## 循环控制语句结构\n\n在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：\n\n- `break`语句：用于强制退出循环，跳出循环体，执行循环后面的语句。\n- `continue`语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。\n- `return`语句：用于退出函数，返回到函数调用处。\n\n例如，下面的代码演示了如何在循环中使用 `break` 和 `continue` 语句：\n\n```bash\n#!/bin/bash\ni=1\nwhile [ $i -le 100 ]\ndo\n    if [ $i -eq 3 ]\n    then\n        echo \"跳过第 $i 次迭代\"\n        i=$(( $i + 1 ))\n        continue\n    fi\n    if [ $i -eq 5 ]\n    then\n        echo \"退出循环\"\n        break\n    fi\n    echo \"第 $i 次迭代\"\n    i=$(( $i + 1 ))\ndone\n\n```\n\n以上代码会输出以下结果：\n\n```text\n第 1 次迭代\n第 2 次迭代\n跳过第 3 次迭代\n第 4 次迭代\n退出循环\n\n```\n","slug":"linux_shell/4.Shell循环","published":1,"updated":"2023-06-16T13:17:40.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04l000b1dnz4k343poi","content":"<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>上一章学习的结构化命令中的 <code>if-then</code> 和 <code>case</code> 语句，其中 <code>if-then</code> 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。</p>\n<p>在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括<code>for</code>、<code>while</code>、<code>until</code>三种。</p>\n<h2 id=\"for-循环结构\"><a href=\"#for-循环结构\" class=\"headerlink\" title=\"for 循环结构\"></a>for 循环结构</h2><p><code>for</code> 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> 变量名 <span class=\"token keyword\">in</span> 列表\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>变量名</code>是一个新的变量，用于存储列表中的每个元素；<code>列表</code>是一个由空格分隔的参数列表。</p>\n<p>例如，下面的代码中，<code>for</code> 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\ndone,rk\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"i = <span class=\"token variable\">$i</span>\"</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\ni = 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>读取列表中的复杂值</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> I don<span class=\"token string\">'t know if this'</span>ll work\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"word:<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  以上代码输出以下结果：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">word:I\nword:dont know if thisll\nword:work<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>两种方法解决列表中单引号引用的问题</p>\n<ol>\n<li><p>使用转义字符（反斜杠）将单引号转义</p>\n</li>\n<li><p>使用双引号定义用到单引号的值</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> I don<span class=\"token punctuation\">\\</span>'t know <span class=\"token keyword\">if</span> this<span class=\"token punctuation\">\\</span>'ll work\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"word:<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> I <span class=\"token string\">\"don't\"</span> know <span class=\"token keyword\">if</span> <span class=\"token string\">\"this'll\"</span> work\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"word:<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用双引号引用输出多个单词</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"1 2\"</span> <span class=\"token string\">\"3 4\"</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"i = <span class=\"token variable\">$i</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">列表中的元素：1 2\n列表中的元素：3 4\n列表中的元素：5\ni = 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>从变量读取列表</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token string\">\"1 2 3 4 5\"</span>\n<span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token variable\">$list</span><span class=\"token string\">\" 6\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$list</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  以上代码输出以下结果：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\n列表中的元素：6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过命令读取</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">IFS</span></span><span class=\"token operator\">=</span><span class=\"token string\">$'<span class=\"token entity\" title=\"\\n\">\\n</span>'</span>\n\n<span class=\"token function\">cat</span> <span class=\"token operator\">></span> test.sh <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">EOF\n1 2 3\n2\n3\n4\n5\nEOF</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">cat</span> test.sh<span class=\"token variable\">`</span></span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>用通配符读取目录</p>\n<p>  在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。</p>\n<p>  常见的通配符包括：</p>\n<ul>\n<li><p><code>*</code>：匹配任意长度的任意字符，包括空字符串。</p>\n</li>\n<li><p><code>?</code>：匹配任意一个字符。</p>\n</li>\n<li><p><code>[...]</code>：匹配括号内列举的任意一个字符。</p>\n</li>\n<li><p><code>[^...]</code>：匹配除了括号内列举的任意一个字符以外的所有字符。</p>\n<p>以下是一些通配符匹配的示例：</p>\n</li>\n<li><p><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>file2.txt</code> 等。</p>\n</li>\n<li><p><code>file?.txt</code>：匹配所有文件名为 <code>file</code> 开头，后面跟着任意一个字符，最后以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>fileA.txt</code> 等。</p>\n</li>\n<li><p><code>[abc].txt</code>：匹配所有文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 的文件。</p>\n</li>\n<li><p><code>[^abc].txt</code>：匹配除了文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 以外的所有以 <code>.txt</code> 结尾的文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">touch</span> ~/file<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">mkdir</span> ~/dir<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> ~/*\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n     <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a directory\"</span>\n    <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-f</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a file\"</span>\n    <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>练习：</p>\n<p>通过shell脚本实现批量主机检测</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token operator\">></span>ip.txt\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">..</span><span class=\"token number\">254</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token assign-left variable\">ip</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.13.<span class=\"token variable\">$i</span>\n    <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-W1</span> <span class=\"token variable\">$ip</span> <span class=\"token operator\">&amp;></span>/dev/null\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span>\"</span> <span class=\"token operator\">|</span><span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> ip.txt\n  <span class=\"token keyword\">fi</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token operator\">&amp;</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token function\">wait</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"finish...\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"while-循环结构\"><a href=\"#while-循环结构\" class=\"headerlink\" title=\"while 循环结构\"></a>while 循环结构</h2><p><code>while</code> 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> 条件 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。</p>\n<p>例如，下面的代码中，<code>while</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"当前变量的值是 <span class=\"token variable\">$i</span>\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"until-循环结构\"><a href=\"#until-循环结构\" class=\"headerlink\" title=\"until 循环结构\"></a>until 循环结构</h2><p><code>until</code> 循环与 <code>while</code> 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">until</span> <span class=\"token punctuation\">[</span> 条件 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。</p>\n<p>例如，下面的代码中，<code>until</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">until</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"当前变量的值是 <span class=\"token variable\">$i</span>\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"循环控制语句结构\"><a href=\"#循环控制语句结构\" class=\"headerlink\" title=\"循环控制语句结构\"></a>循环控制语句结构</h2><p>在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：</p>\n<ul>\n<li><code>break</code>语句：用于强制退出循环，跳出循环体，执行循环后面的语句。</li>\n<li><code>continue</code>语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。</li>\n<li><code>return</code>语句：用于退出函数，返回到函数调用处。</li>\n</ul>\n<p>例如，下面的代码演示了如何在循环中使用 <code>break</code> 和 <code>continue</code> 语句：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"跳过第 <span class=\"token variable\">$i</span> 次迭代\"</span>\n        <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n        <span class=\"token builtin class-name\">continue</span>\n    <span class=\"token keyword\">fi</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"退出循环\"</span>\n        <span class=\"token builtin class-name\">break</span>\n    <span class=\"token keyword\">fi</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第 <span class=\"token variable\">$i</span> 次迭代\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">第 1 次迭代\n第 2 次迭代\n跳过第 3 次迭代\n第 4 次迭代\n退出循环\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>上一章学习的结构化命令中的 <code>if-then</code> 和 <code>case</code> 语句，其中 <code>if-then</code> 语句是通过检查命令的执行结果或者表达式（文件比较、字符串比较、数值比较）的结果来控制脚本的执行流程。</p>\n<p>在Shell脚本中，循环语句是一种重要的控制结构，用于多次执行同一段代码。Shell脚本中提供了多种循环语句，包括<code>for</code>、<code>while</code>、<code>until</code>三种。</p>\n<h2 id=\"for-循环结构\"><a href=\"#for-循环结构\" class=\"headerlink\" title=\"for 循环结构\"></a>for 循环结构</h2><p><code>for</code> 循环是一种针对列表中每个元素执行相同操作的循环结构。该语句会将列表中的每个元素依次赋值给变量，并执行循环体中的语句。其基本语法格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">for</span> 变量名 <span class=\"token keyword\">in</span> 列表\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>变量名</code>是一个新的变量，用于存储列表中的每个元素；<code>列表</code>是一个由空格分隔的参数列表。</p>\n<p>例如，下面的代码中，<code>for</code> 循环遍历了一个包含 5 个元素的列表，依次输出了每个元素：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\ndone,rk\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"i = <span class=\"token variable\">$i</span>\"</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\ni = 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>读取列表中的复杂值</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> I don<span class=\"token string\">'t know if this'</span>ll work\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"word:<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  以上代码输出以下结果：</p>\n  <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">word:I\nword:dont know if thisll\nword:work<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>两种方法解决列表中单引号引用的问题</p>\n<ol>\n<li><p>使用转义字符（反斜杠）将单引号转义</p>\n</li>\n<li><p>使用双引号定义用到单引号的值</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> I don<span class=\"token punctuation\">\\</span>'t know <span class=\"token keyword\">if</span> this<span class=\"token punctuation\">\\</span>'ll work\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"word:<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> I <span class=\"token string\">\"don't\"</span> know <span class=\"token keyword\">if</span> <span class=\"token string\">\"this'll\"</span> work\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"word:<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用双引号引用输出多个单词</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"1 2\"</span> <span class=\"token string\">\"3 4\"</span> <span class=\"token number\">5</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"i = <span class=\"token variable\">$i</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">列表中的元素：1 2\n列表中的元素：3 4\n列表中的元素：5\ni = 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>从变量读取列表</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token string\">\"1 2 3 4 5\"</span>\n<span class=\"token assign-left variable\">list</span><span class=\"token operator\">=</span><span class=\"token variable\">$list</span><span class=\"token string\">\" 6\"</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$list</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  以上代码输出以下结果：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">列表中的元素：1\n列表中的元素：2\n列表中的元素：3\n列表中的元素：4\n列表中的元素：5\n列表中的元素：6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过命令读取</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">IFS</span></span><span class=\"token operator\">=</span><span class=\"token string\">$'<span class=\"token entity\" title=\"\\n\">\\n</span>'</span>\n\n<span class=\"token function\">cat</span> <span class=\"token operator\">></span> test.sh <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">EOF\n1 2 3\n2\n3\n4\n5\nEOF</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">cat</span> test.sh<span class=\"token variable\">`</span></span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"列表中的元素：<span class=\"token variable\">$i</span>\"</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>用通配符读取目录</p>\n<p>  在 Shell 编程中，通配符是一种用于匹配文件名或目录名的特殊字符。通配符可以帮助你快速地匹配一组文件或目录，从而方便地对它们进行操作。</p>\n<p>  常见的通配符包括：</p>\n<ul>\n<li><p><code>*</code>：匹配任意长度的任意字符，包括空字符串。</p>\n</li>\n<li><p><code>?</code>：匹配任意一个字符。</p>\n</li>\n<li><p><code>[...]</code>：匹配括号内列举的任意一个字符。</p>\n</li>\n<li><p><code>[^...]</code>：匹配除了括号内列举的任意一个字符以外的所有字符。</p>\n<p>以下是一些通配符匹配的示例：</p>\n</li>\n<li><p><code>*.txt</code>：匹配所有以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>file2.txt</code> 等。</p>\n</li>\n<li><p><code>file?.txt</code>：匹配所有文件名为 <code>file</code> 开头，后面跟着任意一个字符，最后以 <code>.txt</code> 结尾的文件，如 <code>file1.txt</code>、<code>fileA.txt</code> 等。</p>\n</li>\n<li><p><code>[abc].txt</code>：匹配所有文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 的文件。</p>\n</li>\n<li><p><code>[^abc].txt</code>：匹配除了文件名为 <code>a.txt</code>、<code>b.txt</code>、<code>c.txt</code> 以外的所有以 <code>.txt</code> 结尾的文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">touch</span> ~/file<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">mkdir</span> ~/dir<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">file</span> <span class=\"token keyword\">in</span> ~/*\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-d</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n     <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a directory\"</span>\n    <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-f</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span>\"</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$file</span> is a file\"</span>\n    <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>练习：</p>\n<p>通过shell脚本实现批量主机检测</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token operator\">></span>ip.txt\n\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">..</span><span class=\"token number\">254</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token assign-left variable\">ip</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.13.<span class=\"token variable\">$i</span>\n    <span class=\"token function\">ping</span> <span class=\"token parameter variable\">-c1</span> <span class=\"token parameter variable\">-W1</span> <span class=\"token variable\">$ip</span> <span class=\"token operator\">&amp;></span>/dev/null\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$?</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$ip</span>\"</span> <span class=\"token operator\">|</span><span class=\"token function\">tee</span> <span class=\"token parameter variable\">-a</span> ip.txt\n  <span class=\"token keyword\">fi</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token operator\">&amp;</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token function\">wait</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"finish...\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"while-循环结构\"><a href=\"#while-循环结构\" class=\"headerlink\" title=\"while 循环结构\"></a>while 循环结构</h2><p><code>while</code> 循环是一种基于条件判断的循环结构，当条件满足时就会一直执行循环体中的语句。其基本语法格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> 条件 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为真，循环继续执行；否则为假，循环结束。</p>\n<p>例如，下面的代码中，<code>while</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"当前变量的值是 <span class=\"token variable\">$i</span>\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"until-循环结构\"><a href=\"#until-循环结构\" class=\"headerlink\" title=\"until 循环结构\"></a>until 循环结构</h2><p><code>until</code> 循环与 <code>while</code> 循环类似，但是只有当条件为假时才会执行循环体中的语句。其基本语法格式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">until</span> <span class=\"token punctuation\">[</span> 条件 <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    循环体\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，<code>条件</code>是一个可以执行的测试命令或表达式，如果返回值为0，则为假，循环继续执行；否则为真，循环结束。</p>\n<p>例如，下面的代码中，<code>until</code> 循环会一直执行，直到变量 <code>i</code> 的值达到 5：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">until</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"当前变量的值是 <span class=\"token variable\">$i</span>\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">当前变量的值是 1\n当前变量的值是 2\n当前变量的值是 3\n当前变量的值是 4\n当前变量的值是 5\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"循环控制语句结构\"><a href=\"#循环控制语句结构\" class=\"headerlink\" title=\"循环控制语句结构\"></a>循环控制语句结构</h2><p>在循环中，有时需要跳过某些循环或终止循环的执行，Shell脚本提供了以下三种循环控制语句：</p>\n<ul>\n<li><code>break</code>语句：用于强制退出循环，跳出循环体，执行循环后面的语句。</li>\n<li><code>continue</code>语句：用于跳过循环体中的一个迭代，直接进入下一个迭代。</li>\n<li><code>return</code>语句：用于退出函数，返回到函数调用处。</li>\n</ul>\n<p>例如，下面的代码演示了如何在循环中使用 <code>break</code> 和 <code>continue</code> 语句：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"跳过第 <span class=\"token variable\">$i</span> 次迭代\"</span>\n        <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n        <span class=\"token builtin class-name\">continue</span>\n    <span class=\"token keyword\">fi</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$i</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">then</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"退出循环\"</span>\n        <span class=\"token builtin class-name\">break</span>\n    <span class=\"token keyword\">fi</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第 <span class=\"token variable\">$i</span> 次迭代\"</span>\n    <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码会输出以下结果：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">第 1 次迭代\n第 2 次迭代\n跳过第 3 次迭代\n第 4 次迭代\n退出循环\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"title":"处理用户输入","date":"2023-04-18T03:31:23.000Z","_content":"\n- bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。\n\n## 命令行参数\n\n### 读取参数\n\n在Shell脚本中，命令行参数可以通过特殊变量 **`$1`**、**`$2`**、**`$3`** ... **`$n`**来获取，其中 **`$1`**表示第一个参数，**`$2`**表示第二个参数，以此类推，**`$n`**表示第 n 个参数。\n\n```bash\n#!/bin/bash\n\necho \"第一个参数为：$1\"\necho \"第二个参数为：$2\"\necho \"第三个参数为：$3\"\n```\n\n1. 利用`for`循环和命令行参数计算阶乘：\n\n    ```bash\n    #!/bin/bash\n    \n    n=$1\n    fact=1\n    \n    for((i=1; i<=$n; i++))\n    do\n       fact=$((fact * i))  \n    done\n    echo \"Factorial of $n is $fact\"\n    exit 0\n    ```\n\n2. 将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：\n\n    ```bash\n    #!/bin/bash\n    \n    echo Hello $1, glad to meet you.\n    ```\n\n3. 当参数超过9个时需要修改变量名，变量名两侧加上花括号。\n\n    ```bash\n    #!/bin/bash\n    # handling lots of parameters\n    #\n    total=$[ ${10} * ${11} ]\n    echo The tenth parameter is ${10}\n    echo The eleventh parameter is ${11}\n    echo The total is $total\n    ```\n\n    运行脚本：\n\n    ```text\n    The tenth parameter is 10\n    The eleventh parameter is 11\n    The total is 110\n    ```\n\n### 读取脚本名\n\n可以用`$0`参数获取shell在命令行启动的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\necho The zero parameter is set to: $0\n#\n```\n\n当传给`$0`变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量`$0`就会使用整个路径：\n\n```shell\nubuntu@sh:~$ bash ~/temp.sh\nThe zero parameter is set to: /home/ubuntu/temp.sh\n```\n\nbasename命令会返回不包含路径的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\nname=$(basename $0)\n\necho The zero parameter is set to: $name\n#\n```\n\n基于脚本名实现不同功能的脚本：\n\n```bash\n#!/bin/bash\n# Testing a Multi-function script\n#\nname=$(basename $0)\n#\nif [ $name = \"addem\" ]\nthen\ntotal=$[ $1 + $2 ]\n#\nelif [ $name = \"multem\" ]\nthen\ntotal=$[ $1 * $2 ]\nfi\n#\necho\necho The calculated value is $total\n```\n\n```shell\n$ cp temp.sh addem\n$ ln -s temp.sh multem\n\n$ bash addem 2 5\nThe calculated value is 7\n\n$ bash multem 2 5\nThe calculated value is 10\n$\n\n```\n\n### 测试参数\n\n在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：\n\n```bash\n#!/bin/bash\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n## 特殊参数变量\n\n### 参数统计\n\n使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量`$#`含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。\n\n```bash\n#!/bin/bash\n# getting the number of parameters\n#\necho There were $# parameters supplied.\n```\n\n执行结果：\n\n```shell\nubuntu@sh:~$ bash temp.sh\nThere were 0 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5\nThere were 5 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh \"Hello world\"\nThere were 1 parameters supplied.\n```\n\n在使用参数前测试参数总数：\n\n```bash\n#!/bin/bash\n\nif [ $# -ne 1 ]; then\n  echo \"Usage: $0 number\"\n  exit 1\nfi\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n### 抓取所有的数据\n\n`$*`变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每\n一个参数值。基本上`$*`变量会将这些参数视为一个整体，而不是多个个体。\n另一方面，`$@`变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样\n你就能够遍历所有的参数值，得到每个参数。这通常通过`for`命令完成。\n\n```bash\n#!/bin/bash\n# testing $* and $@\n#j,r:\necho\ncount=1\n#\nfor param in \"$*\"\ndo\necho \"\\$* Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n#\necho\ncount=1\n#\nfor param in \"$@\"\ndo\necho \"\\$@ Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 移动变量\n\nbash shell的`shift`命令能够用来操作命令行参数。在使用`shift`命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量`$3`的值会移到$2中，变量`$2`的值会移到`$1`中，而变量`$1`的值则会被删除（注意，变量`$0`的值，也就是程序名，不会改变）。\n\n这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。\n\n```bash\n#!/bin/bash\n\nwhile [ -n \"$1\" ]\ndo\n                sum=$(($sum+$1))\n                shift\ndone\n\necho sum=$sum\nexit 0\n```\n\n```shell\nubuntu@sh:~$ bash temp.sh 1 2 3\nsum=6\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5 6\nsum=21\n```\n\n## 处理选项\n\n选项是跟在单破折线后面的单个字母，它能改变命令的行为。\n\n### 处理简单选项\n\n```bash\n#!/bin/bash\n\necho\nwhile [ -n \"$1\" ]\ndo\n         case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\" ;;\n                                -c) echo \"Found the -c option\" ;;\n                                *) echo \"$1 is not an option\" ;;\n         esac\n         shift\ndone\n```\n\n### 分离参数和选项、处理带值选项\n\n```bash\n#!/bin/bash\n# extracting options and parameters\necho\nwhile [ -n \"$1\" ]\ndo\n                case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\";;\n                                -c) echo \"Found the -c option\" \n                   coption=$($2 * $3)\n                   echo $coption\n                   shift\n                   shift\n                   ;;\n                                --) shift\n                                                break ;;\n                                *) echo \"$1 is not an option\";;\n                esac\n                shift\ndone\n#\ncount=1\nfor param in $@\ndo\n                echo \"Parameter #$count: $param\"\n                count=$(( $count + 1 ))\ndone\n```\n\n### 利用选项和参数实现阶乘和求和的计算工具\n\n```bash\n#!/bin/bash\n\nif [ $# -eq 0 ] || [ $# -eq 1 ]\nthen\n                echo\n                echo \"sum and factorial tool\"\n                echo \"Usage:\"\n                echo \"          -a number ...\"\n                echo \"          -f number\"\n                exit 1\nfi\n\ncase \"$1\" in\n                -a)\n                                while [ -n \"$2\" ]\n                                do\n                                                sum=$[$sum + $2]\n                                                shift\n                                done\n                                echo \"sum=$sum\"\n                                exit 0\n# shift\n# for i in $@\n# do\n # sum=$((sum + i))\n# done\n# exit 0\n                                ;;\n                -f)\n                                if [ $2 -eq 0 ]\n                                then\n                                                echo \"fact=1\"\n                                                exit 0\n                                fi\n                                fact=1\n                                for((i=1; i<=$2; i++))\n                                do\n                                                fact=$[$fact * $i]\n                                done\n                                echo fact=$fact\n                                exit 0\n                                ;;\n                -h)\n                                ;;\n                *)\n                                echo\n                                echo \"sum and factorial tool\"\n                                echo \"Usage:\"\n                                echo \"          -a number ...\"\n                                echo \"          -f number\"\n                                ;;\nesac\nexit 0\n```\n\n## 标准化选项\n\n![5.处理用户输入-2023-06-16-21-20-42](https://raw.githubusercontent.com/yefreee/picture/main/note5.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-2023-06-16-21-20-42.png)\n","source":"_posts/linux_shell/5.处理用户输入.md","raw":"---\ntitle: 处理用户输入\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n- bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。\n\n## 命令行参数\n\n### 读取参数\n\n在Shell脚本中，命令行参数可以通过特殊变量 **`$1`**、**`$2`**、**`$3`** ... **`$n`**来获取，其中 **`$1`**表示第一个参数，**`$2`**表示第二个参数，以此类推，**`$n`**表示第 n 个参数。\n\n```bash\n#!/bin/bash\n\necho \"第一个参数为：$1\"\necho \"第二个参数为：$2\"\necho \"第三个参数为：$3\"\n```\n\n1. 利用`for`循环和命令行参数计算阶乘：\n\n    ```bash\n    #!/bin/bash\n    \n    n=$1\n    fact=1\n    \n    for((i=1; i<=$n; i++))\n    do\n       fact=$((fact * i))  \n    done\n    echo \"Factorial of $n is $fact\"\n    exit 0\n    ```\n\n2. 将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：\n\n    ```bash\n    #!/bin/bash\n    \n    echo Hello $1, glad to meet you.\n    ```\n\n3. 当参数超过9个时需要修改变量名，变量名两侧加上花括号。\n\n    ```bash\n    #!/bin/bash\n    # handling lots of parameters\n    #\n    total=$[ ${10} * ${11} ]\n    echo The tenth parameter is ${10}\n    echo The eleventh parameter is ${11}\n    echo The total is $total\n    ```\n\n    运行脚本：\n\n    ```text\n    The tenth parameter is 10\n    The eleventh parameter is 11\n    The total is 110\n    ```\n\n### 读取脚本名\n\n可以用`$0`参数获取shell在命令行启动的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\necho The zero parameter is set to: $0\n#\n```\n\n当传给`$0`变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量`$0`就会使用整个路径：\n\n```shell\nubuntu@sh:~$ bash ~/temp.sh\nThe zero parameter is set to: /home/ubuntu/temp.sh\n```\n\nbasename命令会返回不包含路径的脚本名：\n\n```bash\n#!/bin/bash\n# Testing the $0 parameter\n#\nname=$(basename $0)\n\necho The zero parameter is set to: $name\n#\n```\n\n基于脚本名实现不同功能的脚本：\n\n```bash\n#!/bin/bash\n# Testing a Multi-function script\n#\nname=$(basename $0)\n#\nif [ $name = \"addem\" ]\nthen\ntotal=$[ $1 + $2 ]\n#\nelif [ $name = \"multem\" ]\nthen\ntotal=$[ $1 * $2 ]\nfi\n#\necho\necho The calculated value is $total\n```\n\n```shell\n$ cp temp.sh addem\n$ ln -s temp.sh multem\n\n$ bash addem 2 5\nThe calculated value is 7\n\n$ bash multem 2 5\nThe calculated value is 10\n$\n\n```\n\n### 测试参数\n\n在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：\n\n```bash\n#!/bin/bash\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n## 特殊参数变量\n\n### 参数统计\n\n使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量`$#`含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。\n\n```bash\n#!/bin/bash\n# getting the number of parameters\n#\necho There were $# parameters supplied.\n```\n\n执行结果：\n\n```shell\nubuntu@sh:~$ bash temp.sh\nThere were 0 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5\nThere were 5 parameters supplied.\n\nubuntu@sh:~$ bash temp.sh \"Hello world\"\nThere were 1 parameters supplied.\n```\n\n在使用参数前测试参数总数：\n\n```bash\n#!/bin/bash\n\nif [ $# -ne 1 ]; then\n  echo \"Usage: $0 number\"\n  exit 1\nfi\n\nn=$1\nfact=1\n\nif [ $n -eq 0 ]; then\n  echo \"Factorial of 0 is 1\"\n  exit 0\nelif [ $n -lt 0 ]; then\n  echo \"Invalid input. Number must be a positive integer\"\n  exit 1\nfi\n\nfor ((i=1; i<=$n; i++)); do\n  fact=$((fact * i))\ndone\n\necho \"Factorial of $n is $fact\"\nexit 0\n```\n\n### 抓取所有的数据\n\n`$*`变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每\n一个参数值。基本上`$*`变量会将这些参数视为一个整体，而不是多个个体。\n另一方面，`$@`变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样\n你就能够遍历所有的参数值，得到每个参数。这通常通过`for`命令完成。\n\n```bash\n#!/bin/bash\n# testing $* and $@\n#j,r:\necho\ncount=1\n#\nfor param in \"$*\"\ndo\necho \"\\$* Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n#\necho\ncount=1\n#\nfor param in \"$@\"\ndo\necho \"\\$@ Parameter #$count = $param\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 移动变量\n\nbash shell的`shift`命令能够用来操作命令行参数。在使用`shift`命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量`$3`的值会移到$2中，变量`$2`的值会移到`$1`中，而变量`$1`的值则会被删除（注意，变量`$0`的值，也就是程序名，不会改变）。\n\n这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。\n\n```bash\n#!/bin/bash\n\nwhile [ -n \"$1\" ]\ndo\n                sum=$(($sum+$1))\n                shift\ndone\n\necho sum=$sum\nexit 0\n```\n\n```shell\nubuntu@sh:~$ bash temp.sh 1 2 3\nsum=6\n\nubuntu@sh:~$ bash temp.sh 1 2 3 4 5 6\nsum=21\n```\n\n## 处理选项\n\n选项是跟在单破折线后面的单个字母，它能改变命令的行为。\n\n### 处理简单选项\n\n```bash\n#!/bin/bash\n\necho\nwhile [ -n \"$1\" ]\ndo\n         case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\" ;;\n                                -c) echo \"Found the -c option\" ;;\n                                *) echo \"$1 is not an option\" ;;\n         esac\n         shift\ndone\n```\n\n### 分离参数和选项、处理带值选项\n\n```bash\n#!/bin/bash\n# extracting options and parameters\necho\nwhile [ -n \"$1\" ]\ndo\n                case \"$1\" in\n                                -a) echo \"Found the -a option\" ;;\n                                -b) echo \"Found the -b option\";;\n                                -c) echo \"Found the -c option\" \n                   coption=$($2 * $3)\n                   echo $coption\n                   shift\n                   shift\n                   ;;\n                                --) shift\n                                                break ;;\n                                *) echo \"$1 is not an option\";;\n                esac\n                shift\ndone\n#\ncount=1\nfor param in $@\ndo\n                echo \"Parameter #$count: $param\"\n                count=$(( $count + 1 ))\ndone\n```\n\n### 利用选项和参数实现阶乘和求和的计算工具\n\n```bash\n#!/bin/bash\n\nif [ $# -eq 0 ] || [ $# -eq 1 ]\nthen\n                echo\n                echo \"sum and factorial tool\"\n                echo \"Usage:\"\n                echo \"          -a number ...\"\n                echo \"          -f number\"\n                exit 1\nfi\n\ncase \"$1\" in\n                -a)\n                                while [ -n \"$2\" ]\n                                do\n                                                sum=$[$sum + $2]\n                                                shift\n                                done\n                                echo \"sum=$sum\"\n                                exit 0\n# shift\n# for i in $@\n# do\n # sum=$((sum + i))\n# done\n# exit 0\n                                ;;\n                -f)\n                                if [ $2 -eq 0 ]\n                                then\n                                                echo \"fact=1\"\n                                                exit 0\n                                fi\n                                fact=1\n                                for((i=1; i<=$2; i++))\n                                do\n                                                fact=$[$fact * $i]\n                                done\n                                echo fact=$fact\n                                exit 0\n                                ;;\n                -h)\n                                ;;\n                *)\n                                echo\n                                echo \"sum and factorial tool\"\n                                echo \"Usage:\"\n                                echo \"          -a number ...\"\n                                echo \"          -f number\"\n                                ;;\nesac\nexit 0\n```\n\n## 标准化选项\n\n![5.处理用户输入-2023-06-16-21-20-42](https://raw.githubusercontent.com/yefreee/picture/main/note5.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-2023-06-16-21-20-42.png)\n","slug":"linux_shell/5.处理用户输入","published":1,"updated":"2023-06-16T13:20:43.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04m000c1dnz7kynbhy8","content":"<ul>\n<li>bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。</li>\n</ul>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><h3 id=\"读取参数\"><a href=\"#读取参数\" class=\"headerlink\" title=\"读取参数\"></a>读取参数</h3><p>在Shell脚本中，命令行参数可以通过特殊变量 <strong><code>$1</code><strong>、</strong><code>$2</code><strong>、</strong><code>$3</code></strong> … **<code>$n</code>**来获取，其中 **<code>$1</code><strong>表示第一个参数，</strong><code>$2</code><strong>表示第二个参数，以此类推，</strong><code>$n</code>**表示第 n 个参数。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第一个参数为：<span class=\"token variable\">$1</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第二个参数为：<span class=\"token variable\">$2</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第三个参数为：<span class=\"token variable\">$3</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li><p>利用<code>for</code>循环和命令行参数计算阶乘：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">n</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">for</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span>\n<span class=\"token keyword\">do</span>\n   <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>fact <span class=\"token operator\">*</span> i<span class=\"token variable\">))</span></span>  \n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of <span class=\"token variable\">$n</span> is <span class=\"token variable\">$fact</span>\"</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> Hello <span class=\"token variable\">$1</span>, glad to meet you.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>当参数超过9个时需要修改变量名，变量名两侧加上花括号。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># handling lots of parameters</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">total</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$&#123;10&#125;</span> * <span class=\"token variable\">$&#123;11&#125;</span> <span class=\"token punctuation\">]</span>\n<span class=\"token builtin class-name\">echo</span> The tenth parameter is <span class=\"token variable\">$&#123;10&#125;</span>\n<span class=\"token builtin class-name\">echo</span> The eleventh parameter is <span class=\"token variable\">$&#123;11&#125;</span>\n<span class=\"token builtin class-name\">echo</span> The total is <span class=\"token variable\">$total</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">The tenth parameter is 10\nThe eleventh parameter is 11\nThe total is 110<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"读取脚本名\"><a href=\"#读取脚本名\" class=\"headerlink\" title=\"读取脚本名\"></a>读取脚本名</h3><p>可以用<code>$0</code>参数获取shell在命令行启动的脚本名：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Testing the $0 parameter</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span> The zero parameter is <span class=\"token builtin class-name\">set</span> to: <span class=\"token variable\">$0</span>\n<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当传给<code>$0</code>变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量<code>$0</code>就会使用整个路径：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> ~/temp.sh\nThe zero parameter is <span class=\"token builtin class-name\">set</span> to: /home/ubuntu/temp.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>basename命令会返回不包含路径的脚本名：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Testing the $0 parameter</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> $0<span class=\"token variable\">)</span></span>\n\n<span class=\"token builtin class-name\">echo</span> The zero parameter is <span class=\"token builtin class-name\">set</span> to: <span class=\"token variable\">$name</span>\n<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>基于脚本名实现不同功能的脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Testing a Multi-function script</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> $0<span class=\"token variable\">)</span></span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$name</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"addem\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token assign-left variable\">total</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$name</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"multem\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token assign-left variable\">total</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token builtin class-name\">echo</span> The calculated value is <span class=\"token variable\">$total</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cp</span> temp.sh addem\n$ <span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> temp.sh multem\n\n$ <span class=\"token function\">bash</span> addem <span class=\"token number\">2</span> <span class=\"token number\">5</span>\nThe calculated value is <span class=\"token number\">7</span>\n\n$ <span class=\"token function\">bash</span> multem <span class=\"token number\">2</span> <span class=\"token number\">5</span>\nThe calculated value is <span class=\"token number\">10</span>\n$\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">n</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of 0 is 1\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-lt</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Invalid input. Number must be a positive integer\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>fact <span class=\"token operator\">*</span> i<span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of <span class=\"token variable\">$n</span> is <span class=\"token variable\">$fact</span>\"</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"特殊参数变量\"><a href=\"#特殊参数变量\" class=\"headerlink\" title=\"特殊参数变量\"></a>特殊参数变量</h2><h3 id=\"参数统计\"><a href=\"#参数统计\" class=\"headerlink\" title=\"参数统计\"></a>参数统计</h3><p>使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># getting the number of parameters</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span> There were <span class=\"token variable\">$#</span> parameters supplied.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh\nThere were <span class=\"token number\">0</span> parameters supplied.\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span>\nThere were <span class=\"token number\">5</span> parameters supplied.\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token string\">\"Hello world\"</span>\nThere were <span class=\"token number\">1</span> parameters supplied.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在使用参数前测试参数总数：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> <span class=\"token parameter variable\">-ne</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage: <span class=\"token variable\">$0</span> number\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token assign-left variable\">n</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of 0 is 1\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-lt</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Invalid input. Number must be a positive integer\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>fact <span class=\"token operator\">*</span> i<span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of <span class=\"token variable\">$n</span> is <span class=\"token variable\">$fact</span>\"</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"抓取所有的数据\"><a href=\"#抓取所有的数据\" class=\"headerlink\" title=\"抓取所有的数据\"></a>抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每<br>一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。<br>另一方面，<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样<br>你就能够遍历所有的参数值，得到每个参数。这通常通过<code>for</code>命令完成。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># testing $* and $@</span>\n<span class=\"token comment\">#j,r:</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$*</span>\"</span>\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token variable\">$*</span> Parameter #<span class=\"token variable\">$count</span> = <span class=\"token variable\">$param</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span>\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token variable\">$@</span> Parameter #<span class=\"token variable\">$count</span> = <span class=\"token variable\">$param</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"移动变量\"><a href=\"#移动变量\" class=\"headerlink\" title=\"移动变量\"></a>移动变量</h2><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。在使用<code>shift</code>命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到$2中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值，也就是程序名，不会改变）。</p>\n<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n                <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$sum<span class=\"token operator\">+</span>$<span class=\"token number\">1</span><span class=\"token variable\">))</span></span>\n                <span class=\"token builtin class-name\">shift</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token variable\">$sum</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span>\n<span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">6</span>\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span>\n<span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">21</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>选项是跟在单破折线后面的单个字母，它能改变命令的行为。</p>\n<h3 id=\"处理简单选项\"><a href=\"#处理简单选项\" class=\"headerlink\" title=\"处理简单选项\"></a>处理简单选项</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n         <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span>\n                                -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">esac</span>\n         <span class=\"token builtin class-name\">shift</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"分离参数和选项、处理带值选项\"><a href=\"#分离参数和选项、处理带值选项\" class=\"headerlink\" title=\"分离参数和选项、处理带值选项\"></a>分离参数和选项、处理带值选项</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting options and parameters</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n                <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span>\n                                -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> \n                   <span class=\"token assign-left variable\">coption</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>$2 * $3<span class=\"token variable\">)</span></span>\n                   <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$coption</span>\n                   <span class=\"token builtin class-name\">shift</span>\n                   <span class=\"token builtin class-name\">shift</span>\n                   <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                --<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">shift</span>\n                                                <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">esac</span>\n                <span class=\"token builtin class-name\">shift</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$@</span>\n<span class=\"token keyword\">do</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span>\n                <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $count <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"利用选项和参数实现阶乘和求和的计算工具\"><a href=\"#利用选项和参数实现阶乘和求和的计算工具\" class=\"headerlink\" title=\"利用选项和参数实现阶乘和求和的计算工具\"></a>利用选项和参数实现阶乘和求和的计算工具</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n                <span class=\"token builtin class-name\">echo</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"sum and factorial tool\"</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage:\"</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -a number ...\"</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -f number\"</span>\n                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span>\n                -a<span class=\"token punctuation\">)</span>\n                                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$2</span>\"</span> <span class=\"token punctuation\">]</span>\n                                <span class=\"token keyword\">do</span>\n                                                <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$sum</span> + <span class=\"token variable\">$2</span><span class=\"token punctuation\">]</span>\n                                                <span class=\"token builtin class-name\">shift</span>\n                                <span class=\"token keyword\">done</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"sum=<span class=\"token variable\">$sum</span>\"</span>\n                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n<span class=\"token comment\"># shift</span>\n<span class=\"token comment\"># for i in $@</span>\n<span class=\"token comment\"># do</span>\n <span class=\"token comment\"># sum=$((sum + i))</span>\n<span class=\"token comment\"># done</span>\n<span class=\"token comment\"># exit 0</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                -f<span class=\"token punctuation\">)</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$2</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span>\n                                <span class=\"token keyword\">then</span>\n                                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"fact=1\"</span>\n                                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n                                <span class=\"token keyword\">fi</span>\n                                <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n                                <span class=\"token keyword\">for</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$<span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span>\n                                <span class=\"token keyword\">do</span>\n                                                <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$fact</span> * <span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span>\n                                <span class=\"token keyword\">done</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\">$fact</span>\n                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                -h<span class=\"token punctuation\">)</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                *<span class=\"token punctuation\">)</span>\n                                <span class=\"token builtin class-name\">echo</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"sum and factorial tool\"</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage:\"</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -a number ...\"</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -f number\"</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"标准化选项\"><a href=\"#标准化选项\" class=\"headerlink\" title=\"标准化选项\"></a>标准化选项</h2><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note5.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-2023-06-16-21-20-42.png\" alt=\"5.处理用户输入-2023-06-16-21-20-42\"></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>bash shell提供了一些不同的方法从用户处获得数据，包括命令行参数、命令行选项、直接从键盘读取。</li>\n</ul>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><h3 id=\"读取参数\"><a href=\"#读取参数\" class=\"headerlink\" title=\"读取参数\"></a>读取参数</h3><p>在Shell脚本中，命令行参数可以通过特殊变量 <strong><code>$1</code><strong>、</strong><code>$2</code><strong>、</strong><code>$3</code></strong> … **<code>$n</code>**来获取，其中 **<code>$1</code><strong>表示第一个参数，</strong><code>$2</code><strong>表示第二个参数，以此类推，</strong><code>$n</code>**表示第 n 个参数。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第一个参数为：<span class=\"token variable\">$1</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第二个参数为：<span class=\"token variable\">$2</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第三个参数为：<span class=\"token variable\">$3</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li><p>利用<code>for</code>循环和命令行参数计算阶乘：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">n</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">for</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span>\n<span class=\"token keyword\">do</span>\n   <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>fact <span class=\"token operator\">*</span> i<span class=\"token variable\">))</span></span>  \n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of <span class=\"token variable\">$n</span> is <span class=\"token variable\">$fact</span>\"</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将带有空格的文本字符串传递给脚本时需要注意用引号，引号在进行传递时只表明数据的起止位置，不作为数据的一部分：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> Hello <span class=\"token variable\">$1</span>, glad to meet you.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>当参数超过9个时需要修改变量名，变量名两侧加上花括号。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># handling lots of parameters</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">total</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$&#123;10&#125;</span> * <span class=\"token variable\">$&#123;11&#125;</span> <span class=\"token punctuation\">]</span>\n<span class=\"token builtin class-name\">echo</span> The tenth parameter is <span class=\"token variable\">$&#123;10&#125;</span>\n<span class=\"token builtin class-name\">echo</span> The eleventh parameter is <span class=\"token variable\">$&#123;11&#125;</span>\n<span class=\"token builtin class-name\">echo</span> The total is <span class=\"token variable\">$total</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p> 运行脚本：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">The tenth parameter is 10\nThe eleventh parameter is 11\nThe total is 110<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h3 id=\"读取脚本名\"><a href=\"#读取脚本名\" class=\"headerlink\" title=\"读取脚本名\"></a>读取脚本名</h3><p>可以用<code>$0</code>参数获取shell在命令行启动的脚本名：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Testing the $0 parameter</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span> The zero parameter is <span class=\"token builtin class-name\">set</span> to: <span class=\"token variable\">$0</span>\n<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当传给<code>$0</code>变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时，变量<code>$0</code>就会使用整个路径：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> ~/temp.sh\nThe zero parameter is <span class=\"token builtin class-name\">set</span> to: /home/ubuntu/temp.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>basename命令会返回不包含路径的脚本名：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Testing the $0 parameter</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> $0<span class=\"token variable\">)</span></span>\n\n<span class=\"token builtin class-name\">echo</span> The zero parameter is <span class=\"token builtin class-name\">set</span> to: <span class=\"token variable\">$name</span>\n<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>基于脚本名实现不同功能的脚本：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># Testing a Multi-function script</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> $0<span class=\"token variable\">)</span></span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$name</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"addem\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token assign-left variable\">total</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$name</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"multem\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token assign-left variable\">total</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token builtin class-name\">echo</span> The calculated value is <span class=\"token variable\">$total</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">cp</span> temp.sh addem\n$ <span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> temp.sh multem\n\n$ <span class=\"token function\">bash</span> addem <span class=\"token number\">2</span> <span class=\"token number\">5</span>\nThe calculated value is <span class=\"token number\">7</span>\n\n$ <span class=\"token function\">bash</span> multem <span class=\"token number\">2</span> <span class=\"token number\">5</span>\nThe calculated value is <span class=\"token number\">10</span>\n$\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>在脚本内使用参数时需要考虑到当用户输入错误参数时的情况：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token assign-left variable\">n</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of 0 is 1\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-lt</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Invalid input. Number must be a positive integer\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>fact <span class=\"token operator\">*</span> i<span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of <span class=\"token variable\">$n</span> is <span class=\"token variable\">$fact</span>\"</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"特殊参数变量\"><a href=\"#特殊参数变量\" class=\"headerlink\" title=\"特殊参数变量\"></a>特殊参数变量</h2><h3 id=\"参数统计\"><a href=\"#参数统计\" class=\"headerlink\" title=\"参数统计\"></a>参数统计</h3><p>使用特殊变量可以帮助我们更方便的检查用户传递给脚本的参数。特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># getting the number of parameters</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span> There were <span class=\"token variable\">$#</span> parameters supplied.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh\nThere were <span class=\"token number\">0</span> parameters supplied.\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span>\nThere were <span class=\"token number\">5</span> parameters supplied.\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token string\">\"Hello world\"</span>\nThere were <span class=\"token number\">1</span> parameters supplied.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在使用参数前测试参数总数：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> <span class=\"token parameter variable\">-ne</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage: <span class=\"token variable\">$0</span> number\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token assign-left variable\">n</span><span class=\"token operator\">=</span><span class=\"token variable\">$1</span>\n<span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of 0 is 1\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$n</span> <span class=\"token parameter variable\">-lt</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Invalid input. Number must be a positive integer\"</span>\n  <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n  <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>fact <span class=\"token operator\">*</span> i<span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Factorial of <span class=\"token variable\">$n</span> is <span class=\"token variable\">$fact</span>\"</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"抓取所有的数据\"><a href=\"#抓取所有的数据\" class=\"headerlink\" title=\"抓取所有的数据\"></a>抓取所有的数据</h3><p><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每<br>一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。<br>另一方面，<code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样<br>你就能够遍历所有的参数值，得到每个参数。这通常通过<code>for</code>命令完成。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># testing $* and $@</span>\n<span class=\"token comment\">#j,r:</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$*</span>\"</span>\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token variable\">$*</span> Parameter #<span class=\"token variable\">$count</span> = <span class=\"token variable\">$param</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token comment\">#</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token comment\">#</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token string\">\"<span class=\"token variable\">$@</span>\"</span>\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\\<span class=\"token variable\">$@</span> Parameter #<span class=\"token variable\">$count</span> = <span class=\"token variable\">$param</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"移动变量\"><a href=\"#移动变量\" class=\"headerlink\" title=\"移动变量\"></a>移动变量</h2><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。在使用<code>shift</code>命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量<code>$3</code>的值会移到$2中，变量<code>$2</code>的值会移到<code>$1</code>中，而变量<code>$1</code>的值则会被删除（注意，变量<code>$0</code>的值，也就是程序名，不会改变）。</p>\n<p>这是遍历命令行参数的另一个好方法，尤其是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n                <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>$sum<span class=\"token operator\">+</span>$<span class=\"token number\">1</span><span class=\"token variable\">))</span></span>\n                <span class=\"token builtin class-name\">shift</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token variable\">$sum</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span>\n<span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">6</span>\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> temp.sh <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span>\n<span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">21</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>选项是跟在单破折线后面的单个字母，它能改变命令的行为。</p>\n<h3 id=\"处理简单选项\"><a href=\"#处理简单选项\" class=\"headerlink\" title=\"处理简单选项\"></a>处理简单选项</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n         <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span>\n                                -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">esac</span>\n         <span class=\"token builtin class-name\">shift</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"分离参数和选项、处理带值选项\"><a href=\"#分离参数和选项、处理带值选项\" class=\"headerlink\" title=\"分离参数和选项、处理带值选项\"></a>分离参数和选项、处理带值选项</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># extracting options and parameters</span>\n<span class=\"token builtin class-name\">echo</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\n                <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span>\n                                -a<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -a option\"</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -b<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -b option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                -c<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Found the -c option\"</span> \n                   <span class=\"token assign-left variable\">coption</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>$2 * $3<span class=\"token variable\">)</span></span>\n                   <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$coption</span>\n                   <span class=\"token builtin class-name\">shift</span>\n                   <span class=\"token builtin class-name\">shift</span>\n                   <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                --<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">shift</span>\n                                                <span class=\"token builtin class-name\">break</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                                *<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span> is not an option\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">esac</span>\n                <span class=\"token builtin class-name\">shift</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token comment\">#</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">param</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$@</span>\n<span class=\"token keyword\">do</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Parameter #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$param</span>\"</span>\n                <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span> $count <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token variable\">))</span></span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"利用选项和参数实现阶乘和求和的计算工具\"><a href=\"#利用选项和参数实现阶乘和求和的计算工具\" class=\"headerlink\" title=\"利用选项和参数实现阶乘和求和的计算工具\"></a>利用选项和参数实现阶乘和求和的计算工具</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$#</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n                <span class=\"token builtin class-name\">echo</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"sum and factorial tool\"</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage:\"</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -a number ...\"</span>\n                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -f number\"</span>\n                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token keyword\">in</span>\n                -a<span class=\"token punctuation\">)</span>\n                                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$2</span>\"</span> <span class=\"token punctuation\">]</span>\n                                <span class=\"token keyword\">do</span>\n                                                <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$sum</span> + <span class=\"token variable\">$2</span><span class=\"token punctuation\">]</span>\n                                                <span class=\"token builtin class-name\">shift</span>\n                                <span class=\"token keyword\">done</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"sum=<span class=\"token variable\">$sum</span>\"</span>\n                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n<span class=\"token comment\"># shift</span>\n<span class=\"token comment\"># for i in $@</span>\n<span class=\"token comment\"># do</span>\n <span class=\"token comment\"># sum=$((sum + i))</span>\n<span class=\"token comment\"># done</span>\n<span class=\"token comment\"># exit 0</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                -f<span class=\"token punctuation\">)</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$2</span> <span class=\"token parameter variable\">-eq</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span>\n                                <span class=\"token keyword\">then</span>\n                                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"fact=1\"</span>\n                                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n                                <span class=\"token keyword\">fi</span>\n                                <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n                                <span class=\"token keyword\">for</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>$<span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span>\n                                <span class=\"token keyword\">do</span>\n                                                <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span><span class=\"token variable\">$fact</span> * <span class=\"token variable\">$i</span><span class=\"token punctuation\">]</span>\n                                <span class=\"token keyword\">done</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token assign-left variable\">fact</span><span class=\"token operator\">=</span><span class=\"token variable\">$fact</span>\n                                <span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                -h<span class=\"token punctuation\">)</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                *<span class=\"token punctuation\">)</span>\n                                <span class=\"token builtin class-name\">echo</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"sum and factorial tool\"</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage:\"</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -a number ...\"</span>\n                                <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -f number\"</span>\n                                <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span>\n<span class=\"token builtin class-name\">exit</span> <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"标准化选项\"><a href=\"#标准化选项\" class=\"headerlink\" title=\"标准化选项\"></a>标准化选项</h2><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note5.%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5-2023-06-16-21-20-42.png\" alt=\"5.处理用户输入-2023-06-16-21-20-42\"></p>\n"},{"title":"使用重定向呈现数据","date":"2023-04-18T03:31:23.000Z","_content":"\n有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 `bash shell`提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。\n\n## 输出重定向\n\n```shell\nubuntu@sh:~$ date > test6\nubuntu@sh:~$ ls -l test6\n-rw-rw-r-- 1 ubuntu ubuntu 29 Mar 26 19:23 test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu@sh:~$\n```\n\n重定向操作符创建了一个文件 `test6`（通过默认的 `umask`设置），并将 `date`命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。\n\n有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 `（>>）`来追加数据。\n\n```shell\nubuntu@sh:~$ who >> test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$\n```\n\n`test6`文件在原来`who`命令输出的基础上又加上了`date`命令的输出\n\n## 输入重定向\n\n输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号`（<）`\n\n```powershell\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$ wc < test6\n  3  15 122\nubuntu@sh:~$\n```\n\n`wc`命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。\n\n## 呈现数据\n\n### 标准文件描述符\n\nLinux的标准文件描述符：\n\n| 文件描述符 | 缩写 | 描述 |\n| --- | --- | --- |\n| 0 | STDIN | 标准输入 |\n| 1 | STDOUT | 标准输出 |\n| 2 | STDERR | 标准错误 |\n\n- 这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。\n\n1. STDIN(标准输入)\n\n    STDIN文件描述符代表`shell`的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。\n\n    在使用输入重定向符号`（<）`时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。\n\n    当在命令行上只输入`cat`命令时，它会从`STDIN`接受输入。输入一行，`cat`命令就会显示出一行。\n    但你也可以通过`STDIN`重定向符号强制`cat`命令接受来自另一个`非STDIN`文件的输入。\n\n    ```shell\n    ubuntu@sh:~$ cat < test6\n    Sun Mar 26 19:23:54 PDT 2023\n    ubuntu   tty1         2023-03-26 19:01\n    ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\n    ```\n\n2. STDOUT(标准输出)\n\n    `STDOUT`文件描述符代表`shell`的标准输出。在终端界面上，标准输出就是终端显示器。`shell`的所有输出（包括`shell`中运行的程序和脚本）会被定向到标准输出中，也就是显示器。\n\n    默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用`>`将输出重定向到文件。\n\n    当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。\n\n    ```shell\n    ubuntu@sh:~$ ls -al badfile > test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$ cat test3\n    ubuntu@sh:~$\n    ```\n\n3. STDERR(标准错误)\n\n    shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。\n\n### 重定向错误\n\n- 只重定向错误\n\n    STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。\n\n    ```shell\n    ubuntu@sh:~$ ls -al badfile 2> test3\n    ubuntu@sh:~$ cat test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$\n    ```\n\n- 重定向错误和数据\n\n    如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。\n\n    ```shell\n    ubuntu@sh:~$ ls -al test3 test6 badtest 2>test7 1>test8\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ubuntu@sh:~$ cat test8\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ubuntu@sh:~$\n    ```\n\n    shell利用`1>`符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入`STDOUT`的。所有本该输出到`STDERR`的错误消息通过`2>`符号被重定向到了test7文件。\n\n    可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将`STDERR`和`STDOUT`的输出重定向到同一个输出文件。为此`bash shell`提供了特殊的重定向符号`&>`。\n\n    ```shell\n    ubuntu@sh:~$ ls -al badtest test3 test6 badtest &> test7\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ls: cannot access 'badtest': No such file or directory\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ```\n\n## 在脚本中重定向输出\n\n可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：\n\n1. 临时重定向行输出\n2. 永久重定向脚本中的所有命令\n\n### 临时重定向\n\n如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&：\n\n```shell\nubuntu@sh:~$ cat test.sh\n#!/bin/bash\n\necho \"This is an error\" >&2\necho \"This is normal output\"\n\nubuntu@sh:~$ bash test.sh 2> test9\nThis is normal output\nubuntu@sh:~$ cat test9\nThis is an error\n```\n\n### 永久重定向\n\n如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。\n\n```bash\n#!/bin/bash\n# redirecting all output to a file\nexec 1>testout\necho \"This is a test of redirecting all output\"\necho \"from a script to another file.\"\necho \"without having to redirect every individual line\"\n```\n\n```shell\nubuntu@sh:~$ bash test.sh\nubuntu@sh:~$ cat testout\nThis is a test of redirecting all output\nfrom a script to another file.\nwithout having to redirect every individual line\n```\n\n- 脚本执行过程中重定向\n\n    ```bash\n    #!/bin/bash\n    # redirecting output to different locations\n    exec 2>testerror\n    echo \"This is the start of the script\"\n    echo \"now redirecting all output to another location\"\n    exec 1>testout\n    echo \"This output should go to the testout file\"\n    echo \"but this should go to the testerror file\" >&2\n    ```\n\n## 在脚本中重定向输入\n\n可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用\n\n```bash\n#!/bin/bash\n# redirecting file input\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 创建自己的重定向\n\n### 创建输出文件描述符\n\n在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。\n\n```bash\n#!/bin/bash\n# using an alternative file descriptor\nexec 3>test3out\necho \"This should display on the monitor\"\necho \"and this should be stored in the file\" >&3\necho \"Then this should be back on the monitor\"\n```\n\n### 创建输入文件描述符\n\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。\n\n```bash\n#!/bin/bash\n# redirecting input file descriptors\nexec 6<&0\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\nexec 0<&6\nread -p \"Are you done now? \" answer\ncase $answer in\nY|y) echo \"Goodbye\";;\nN|n) echo \"Sorry, this is the end.\";;\nesac\n```\n\n## 组织命令输出\n\n有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊/文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。\n\n```bash\nubuntu@sh:~$ ls -al > /dev/null\nubuntu@sh:~$\nubuntu@sh:~$ ls -al badfile 2> /dev/null\nubuntu@sh:~$\n```\n","source":"_posts/linux_shell/6.使用重定向呈现数据.md","raw":"---\ntitle: 使用重定向呈现数据\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 `bash shell`提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。\n\n## 输出重定向\n\n```shell\nubuntu@sh:~$ date > test6\nubuntu@sh:~$ ls -l test6\n-rw-rw-r-- 1 ubuntu ubuntu 29 Mar 26 19:23 test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu@sh:~$\n```\n\n重定向操作符创建了一个文件 `test6`（通过默认的 `umask`设置），并将 `date`命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。\n\n有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 `（>>）`来追加数据。\n\n```shell\nubuntu@sh:~$ who >> test6\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$\n```\n\n`test6`文件在原来`who`命令输出的基础上又加上了`date`命令的输出\n\n## 输入重定向\n\n输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号`（<）`\n\n```powershell\nubuntu@sh:~$ cat test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\nubuntu@sh:~$ wc < test6\n  3  15 122\nubuntu@sh:~$\n```\n\n`wc`命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。\n\n## 呈现数据\n\n### 标准文件描述符\n\nLinux的标准文件描述符：\n\n| 文件描述符 | 缩写 | 描述 |\n| --- | --- | --- |\n| 0 | STDIN | 标准输入 |\n| 1 | STDOUT | 标准输出 |\n| 2 | STDERR | 标准错误 |\n\n- 这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。\n\n1. STDIN(标准输入)\n\n    STDIN文件描述符代表`shell`的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。\n\n    在使用输入重定向符号`（<）`时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。\n\n    当在命令行上只输入`cat`命令时，它会从`STDIN`接受输入。输入一行，`cat`命令就会显示出一行。\n    但你也可以通过`STDIN`重定向符号强制`cat`命令接受来自另一个`非STDIN`文件的输入。\n\n    ```shell\n    ubuntu@sh:~$ cat < test6\n    Sun Mar 26 19:23:54 PDT 2023\n    ubuntu   tty1         2023-03-26 19:01\n    ubuntu   pts/0        2023-03-26 19:01 (192.168.13.1)\n    ```\n\n2. STDOUT(标准输出)\n\n    `STDOUT`文件描述符代表`shell`的标准输出。在终端界面上，标准输出就是终端显示器。`shell`的所有输出（包括`shell`中运行的程序和脚本）会被定向到标准输出中，也就是显示器。\n\n    默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用`>`将输出重定向到文件。\n\n    当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。\n\n    ```shell\n    ubuntu@sh:~$ ls -al badfile > test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$ cat test3\n    ubuntu@sh:~$\n    ```\n\n3. STDERR(标准错误)\n\n    shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。\n\n### 重定向错误\n\n- 只重定向错误\n\n    STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。\n\n    ```shell\n    ubuntu@sh:~$ ls -al badfile 2> test3\n    ubuntu@sh:~$ cat test3\n    ls: cannot access 'badfile': No such file or directory\n    ubuntu@sh:~$\n    ```\n\n- 重定向错误和数据\n\n    如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。\n\n    ```shell\n    ubuntu@sh:~$ ls -al test3 test6 badtest 2>test7 1>test8\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ubuntu@sh:~$ cat test8\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ubuntu@sh:~$\n    ```\n\n    shell利用`1>`符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入`STDOUT`的。所有本该输出到`STDERR`的错误消息通过`2>`符号被重定向到了test7文件。\n\n    可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将`STDERR`和`STDOUT`的输出重定向到同一个输出文件。为此`bash shell`提供了特殊的重定向符号`&>`。\n\n    ```shell\n    ubuntu@sh:~$ ls -al badtest test3 test6 badtest &> test7\n    ubuntu@sh:~$ cat test7\n    ls: cannot access 'badtest': No such file or directory\n    ls: cannot access 'badtest': No such file or directory\n    -rw-rw-r-- 1 ubuntu ubuntu  55 Mar 26 20:24 test3\n    -rw-rw-r-- 1 ubuntu ubuntu 122 Mar 26 19:27 test6\n    ```\n\n## 在脚本中重定向输出\n\n可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：\n\n1. 临时重定向行输出\n2. 永久重定向脚本中的所有命令\n\n### 临时重定向\n\n如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&：\n\n```shell\nubuntu@sh:~$ cat test.sh\n#!/bin/bash\n\necho \"This is an error\" >&2\necho \"This is normal output\"\n\nubuntu@sh:~$ bash test.sh 2> test9\nThis is normal output\nubuntu@sh:~$ cat test9\nThis is an error\n```\n\n### 永久重定向\n\n如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。\n\n```bash\n#!/bin/bash\n# redirecting all output to a file\nexec 1>testout\necho \"This is a test of redirecting all output\"\necho \"from a script to another file.\"\necho \"without having to redirect every individual line\"\n```\n\n```shell\nubuntu@sh:~$ bash test.sh\nubuntu@sh:~$ cat testout\nThis is a test of redirecting all output\nfrom a script to another file.\nwithout having to redirect every individual line\n```\n\n- 脚本执行过程中重定向\n\n    ```bash\n    #!/bin/bash\n    # redirecting output to different locations\n    exec 2>testerror\n    echo \"This is the start of the script\"\n    echo \"now redirecting all output to another location\"\n    exec 1>testout\n    echo \"This output should go to the testout file\"\n    echo \"but this should go to the testerror file\" >&2\n    ```\n\n## 在脚本中重定向输入\n\n可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用\n\n```bash\n#!/bin/bash\n# redirecting file input\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\n```\n\n## 创建自己的重定向\n\n### 创建输出文件描述符\n\n在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。\n\n```bash\n#!/bin/bash\n# using an alternative file descriptor\nexec 3>test3out\necho \"This should display on the monitor\"\necho \"and this should be stored in the file\" >&3\necho \"Then this should be back on the monitor\"\n```\n\n### 创建输入文件描述符\n\n可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。\n\n```bash\n#!/bin/bash\n# redirecting input file descriptors\nexec 6<&0\nexec 0< testfile\ncount=1\nwhile read line\ndo\necho \"Line #$count: $line\"\ncount=$[ $count + 1 ]\ndone\nexec 0<&6\nread -p \"Are you done now? \" answer\ncase $answer in\nY|y) echo \"Goodbye\";;\nN|n) echo \"Sorry, this is the end.\";;\nesac\n```\n\n## 组织命令输出\n\n有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊/文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示。\n\n```bash\nubuntu@sh:~$ ls -al > /dev/null\nubuntu@sh:~$\nubuntu@sh:~$ ls -al badfile 2> /dev/null\nubuntu@sh:~$\n```\n","slug":"linux_shell/6.使用重定向呈现数据","published":1,"updated":"2023-06-16T13:21:38.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04m000d1dnz1pp74yps","content":"<p>有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 <code>bash shell</code>提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。</p>\n<h2 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">date</span> <span class=\"token operator\">></span> test6\nubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> test6\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu <span class=\"token number\">29</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23 test6\nubuntu@sh:~$ <span class=\"token function\">cat</span> test6\nSun Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23:54 PDT <span class=\"token number\">2023</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>重定向操作符创建了一个文件 <code>test6</code>（通过默认的 <code>umask</code>设置），并将 <code>date</code>命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</p>\n<p>有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 <code>（&gt;&gt;）</code>来追加数据。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">who</span> <span class=\"token operator\">>></span> test6\nubuntu@sh:~$ <span class=\"token function\">cat</span> test6\nSun Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23:54 PDT <span class=\"token number\">2023</span>\nubuntu   tty1         <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01\nubuntu   pts/0        <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.13.1<span class=\"token punctuation\">)</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>test6</code>文件在原来<code>who</code>命令输出的基础上又加上了<code>date</code>命令的输出</p>\n<h2 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h2><p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号<code>（&lt;）</code></p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">ubuntu@sh:~$ <span class=\"token function\">cat</span> test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 <span class=\"token punctuation\">(</span>192<span class=\"token punctuation\">.</span>168<span class=\"token punctuation\">.</span>13<span class=\"token punctuation\">.</span>1<span class=\"token punctuation\">)</span>\nubuntu@sh:~$ wc &lt; test6\n  3  15 122\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>wc</code>命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。</p>\n<h2 id=\"呈现数据\"><a href=\"#呈现数据\" class=\"headerlink\" title=\"呈现数据\"></a>呈现数据</h2><h3 id=\"标准文件描述符\"><a href=\"#标准文件描述符\" class=\"headerlink\" title=\"标准文件描述符\"></a>标准文件描述符</h3><p>Linux的标准文件描述符：</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>缩写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>STDIN</td>\n<td>标准输入</td>\n</tr>\n<tr>\n<td>1</td>\n<td>STDOUT</td>\n<td>标准输出</td>\n</tr>\n<tr>\n<td>2</td>\n<td>STDERR</td>\n<td>标准错误</td>\n</tr>\n</tbody></table>\n<ul>\n<li>这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</li>\n</ul>\n<ol>\n<li><p>STDIN(标准输入)</p>\n<p> STDIN文件描述符代表<code>shell</code>的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>\n<p> 在使用输入重定向符号<code>（&lt;）</code>时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>\n<p> 当在命令行上只输入<code>cat</code>命令时，它会从<code>STDIN</code>接受输入。输入一行，<code>cat</code>命令就会显示出一行。<br> 但你也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个<code>非STDIN</code>文件的输入。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span> test6\nSun Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23:54 PDT <span class=\"token number\">2023</span>\nubuntu   tty1         <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01\nubuntu   pts/0        <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.13.1<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>STDOUT(标准输出)</p>\n<p> <code>STDOUT</code>文件描述符代表<code>shell</code>的标准输出。在终端界面上，标准输出就是终端显示器。<code>shell</code>的所有输出（包括<code>shell</code>中运行的程序和脚本）会被定向到标准输出中，也就是显示器。</p>\n<p> 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用<code>&gt;</code>将输出重定向到文件。</p>\n<p> 当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badfile <span class=\"token operator\">></span> test3\nls: cannot access <span class=\"token string\">'badfile'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nubuntu@sh:~$ <span class=\"token function\">cat</span> test3\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>STDERR(标准错误)</p>\n<p> shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。</p>\n</li>\n</ol>\n<h3 id=\"重定向错误\"><a href=\"#重定向错误\" class=\"headerlink\" title=\"重定向错误\"></a>重定向错误</h3><ul>\n<li><p>只重定向错误</p>\n<p>  STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badfile <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> test3\nubuntu@sh:~$ <span class=\"token function\">cat</span> test3\nls: cannot access <span class=\"token string\">'badfile'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>重定向错误和数据</p>\n<p>  如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> test3 test6 badtest <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>test7 <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>test8\nubuntu@sh:~$ <span class=\"token function\">cat</span> test7\nls: cannot access <span class=\"token string\">'badtest'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nubuntu@sh:~$ <span class=\"token function\">cat</span> test8\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu  <span class=\"token number\">55</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">20</span>:24 test3\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu <span class=\"token number\">122</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:27 test6\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了test7文件。</p>\n<p>  可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件。为此<code>bash shell</code>提供了特殊的重定向符号<code>&amp;&gt;</code>。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badtest test3 test6 badtest <span class=\"token operator\">&amp;></span> test7\nubuntu@sh:~$ <span class=\"token function\">cat</span> test7\nls: cannot access <span class=\"token string\">'badtest'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nls: cannot access <span class=\"token string\">'badtest'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu  <span class=\"token number\">55</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">20</span>:24 test3\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu <span class=\"token number\">122</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:27 test6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"在脚本中重定向输出\"><a href=\"#在脚本中重定向输出\" class=\"headerlink\" title=\"在脚本中重定向输出\"></a>在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>\n<ol>\n<li>临时重定向行输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ol>\n<h3 id=\"临时重定向\"><a href=\"#临时重定向\" class=\"headerlink\" title=\"临时重定向\"></a>临时重定向</h3><p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&amp;：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token comment\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an error\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is normal output\"</span>\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> test9\nThis is normal output\nubuntu@sh:~$ <span class=\"token function\">cat</span> test9\nThis is an error<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"永久重定向\"><a href=\"#永久重定向\" class=\"headerlink\" title=\"永久重定向\"></a>永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting all output to a file</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>testout\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a test of redirecting all output\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"from a script to another file.\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"without having to redirect every individual line\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh\nubuntu@sh:~$ <span class=\"token function\">cat</span> testout\nThis is a <span class=\"token builtin class-name\">test</span> of redirecting all output\nfrom a script to another file.\nwithout having to redirect every individual line<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>脚本执行过程中重定向</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting output to different locations</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>testerror\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the start of the script\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"now redirecting all output to another location\"</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>testout\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This output should go to the testout file\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"but this should go to the testerror file\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"在脚本中重定向输入\"><a href=\"#在脚本中重定向输入\" class=\"headerlink\" title=\"在脚本中重定向输入\"></a>在脚本中重定向输入</h2><p>可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting file input</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建自己的重定向\"><a href=\"#创建自己的重定向\" class=\"headerlink\" title=\"创建自己的重定向\"></a>创建自己的重定向</h2><h3 id=\"创建输出文件描述符\"><a href=\"#创建输出文件描述符\" class=\"headerlink\" title=\"创建输出文件描述符\"></a>创建输出文件描述符</h3><p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using an alternative file descriptor</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span>test3out\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This should display on the monitor\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"and this should be stored in the file\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Then this should be back on the monitor\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"创建输入文件描述符\"><a href=\"#创建输入文件描述符\" class=\"headerlink\" title=\"创建输入文件描述符\"></a>创建输入文件描述符</h3><p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting input file descriptors</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">6</span>&lt;</span><span class=\"token file-descriptor important\">&amp;0</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span><span class=\"token file-descriptor important\">&amp;6</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"Are you done now? \"</span> answer\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$answer</span> <span class=\"token keyword\">in</span>\nY<span class=\"token operator\">|</span>y<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Goodbye\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nN<span class=\"token operator\">|</span>n<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Sorry, this is the end.\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"组织命令输出\"><a href=\"#组织命令输出\" class=\"headerlink\" title=\"组织命令输出\"></a>组织命令输出</h2><p>有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊&#x2F;文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> <span class=\"token operator\">></span> /dev/null\nubuntu@sh:~$\nubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badfile <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> /dev/null\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>有些时候想要保存某个命令的输出而不仅仅只是让它显示在显示器上。 <code>bash shell</code>提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。</p>\n<h2 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">date</span> <span class=\"token operator\">></span> test6\nubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> test6\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu <span class=\"token number\">29</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23 test6\nubuntu@sh:~$ <span class=\"token function\">cat</span> test6\nSun Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23:54 PDT <span class=\"token number\">2023</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>重定向操作符创建了一个文件 <code>test6</code>（通过默认的 <code>umask</code>设置），并将 <code>date</code>命令的输出重定向到该文件中。如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</p>\n<p>有时，可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号 <code>（&gt;&gt;）</code>来追加数据。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">who</span> <span class=\"token operator\">>></span> test6\nubuntu@sh:~$ <span class=\"token function\">cat</span> test6\nSun Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23:54 PDT <span class=\"token number\">2023</span>\nubuntu   tty1         <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01\nubuntu   pts/0        <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.13.1<span class=\"token punctuation\">)</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>test6</code>文件在原来<code>who</code>命令输出的基础上又加上了<code>date</code>命令的输出</p>\n<h2 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h2><p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号<code>（&lt;）</code></p>\n<pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">ubuntu@sh:~$ <span class=\"token function\">cat</span> test6\nSun Mar 26 19:23:54 PDT 2023\nubuntu   tty1         2023-03-26 19:01\nubuntu   pts/0        2023-03-26 19:01 <span class=\"token punctuation\">(</span>192<span class=\"token punctuation\">.</span>168<span class=\"token punctuation\">.</span>13<span class=\"token punctuation\">.</span>1<span class=\"token punctuation\">)</span>\nubuntu@sh:~$ wc &lt; test6\n  3  15 122\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>wc</code>命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：文本的行数，文本的词数，文本的字节数。</p>\n<h2 id=\"呈现数据\"><a href=\"#呈现数据\" class=\"headerlink\" title=\"呈现数据\"></a>呈现数据</h2><h3 id=\"标准文件描述符\"><a href=\"#标准文件描述符\" class=\"headerlink\" title=\"标准文件描述符\"></a>标准文件描述符</h3><p>Linux的标准文件描述符：</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>缩写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>STDIN</td>\n<td>标准输入</td>\n</tr>\n<tr>\n<td>1</td>\n<td>STDOUT</td>\n<td>标准输出</td>\n</tr>\n<tr>\n<td>2</td>\n<td>STDERR</td>\n<td>标准错误</td>\n</tr>\n</tbody></table>\n<ul>\n<li>这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向到相应的位置。</li>\n</ul>\n<ol>\n<li><p>STDIN(标准输入)</p>\n<p> STDIN文件描述符代表<code>shell</code>的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p>\n<p> 在使用输入重定向符号<code>（&lt;）</code>时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>\n<p> 当在命令行上只输入<code>cat</code>命令时，它会从<code>STDIN</code>接受输入。输入一行，<code>cat</code>命令就会显示出一行。<br> 但你也可以通过<code>STDIN</code>重定向符号强制<code>cat</code>命令接受来自另一个<code>非STDIN</code>文件的输入。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">cat</span> <span class=\"token operator\">&lt;</span> test6\nSun Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:23:54 PDT <span class=\"token number\">2023</span>\nubuntu   tty1         <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01\nubuntu   pts/0        <span class=\"token number\">2023</span>-03-26 <span class=\"token number\">19</span>:01 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.13.1<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>STDOUT(标准输出)</p>\n<p> <code>STDOUT</code>文件描述符代表<code>shell</code>的标准输出。在终端界面上，标准输出就是终端显示器。<code>shell</code>的所有输出（包括<code>shell</code>中运行的程序和脚本）会被定向到标准输出中，也就是显示器。</p>\n<p> 默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。我们也可以使用<code>&gt;</code>将输出重定向到文件。</p>\n<p> 当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。shell对于错误消息的处理是跟普通输出分开的。如果创建了在后台模式下运行的shell脚本，通常必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。需要换种方法来处理。</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badfile <span class=\"token operator\">></span> test3\nls: cannot access <span class=\"token string\">'badfile'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nubuntu@sh:~$ <span class=\"token function\">cat</span> test3\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>STDERR(标准错误)</p>\n<p> shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时，常常会想改变这种行为，尤其是当希望将错误消息保存到日志文件中的时候。</p>\n</li>\n</ol>\n<h3 id=\"重定向错误\"><a href=\"#重定向错误\" class=\"headerlink\" title=\"重定向错误\"></a>重定向错误</h3><ul>\n<li><p>只重定向错误</p>\n<p>  STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badfile <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> test3\nubuntu@sh:~$ <span class=\"token function\">cat</span> test3\nls: cannot access <span class=\"token string\">'badfile'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>重定向错误和数据</p>\n<p>  如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> test3 test6 badtest <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>test7 <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>test8\nubuntu@sh:~$ <span class=\"token function\">cat</span> test7\nls: cannot access <span class=\"token string\">'badtest'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nubuntu@sh:~$ <span class=\"token function\">cat</span> test8\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu  <span class=\"token number\">55</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">20</span>:24 test3\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu <span class=\"token number\">122</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:27 test6\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>  shell利用<code>1&gt;</code>符号将ls命令的正常输出重定向到了test8文件，而这些输出本该是进入<code>STDOUT</code>的。所有本该输出到<code>STDERR</code>的错误消息通过<code>2&gt;</code>符号被重定向到了test7文件。</p>\n<p>  可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别出错误信息。另外也可以将<code>STDERR</code>和<code>STDOUT</code>的输出重定向到同一个输出文件。为此<code>bash shell</code>提供了特殊的重定向符号<code>&amp;&gt;</code>。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badtest test3 test6 badtest <span class=\"token operator\">&amp;></span> test7\nubuntu@sh:~$ <span class=\"token function\">cat</span> test7\nls: cannot access <span class=\"token string\">'badtest'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nls: cannot access <span class=\"token string\">'badtest'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu  <span class=\"token number\">55</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">20</span>:24 test3\n-rw-rw-r-- <span class=\"token number\">1</span> ubuntu ubuntu <span class=\"token number\">122</span> Mar <span class=\"token number\">26</span> <span class=\"token number\">19</span>:27 test6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"在脚本中重定向输出\"><a href=\"#在脚本中重定向输出\" class=\"headerlink\" title=\"在脚本中重定向输出\"></a>在脚本中重定向输出</h2><p>可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。有两种方法来在脚本中重定向输出：</p>\n<ol>\n<li>临时重定向行输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ol>\n<h3 id=\"临时重定向\"><a href=\"#临时重定向\" class=\"headerlink\" title=\"临时重定向\"></a>临时重定向</h3><p>如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。所需要做的是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，必须在文件描述符数字之前加一个&amp;：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">cat</span> test.sh\n<span class=\"token comment\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an error\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is normal output\"</span>\n\nubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> test9\nThis is normal output\nubuntu@sh:~$ <span class=\"token function\">cat</span> test9\nThis is an error<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"永久重定向\"><a href=\"#永久重定向\" class=\"headerlink\" title=\"永久重定向\"></a>永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐，用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符，exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting all output to a file</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>testout\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is a test of redirecting all output\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"from a script to another file.\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"without having to redirect every individual line\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh\nubuntu@sh:~$ <span class=\"token function\">cat</span> testout\nThis is a <span class=\"token builtin class-name\">test</span> of redirecting all output\nfrom a script to another file.\nwithout having to redirect every individual line<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>脚本执行过程中重定向</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting output to different locations</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>testerror\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the start of the script\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"now redirecting all output to another location\"</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">1</span>></span>testout\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This output should go to the testout file\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"but this should go to the testerror file\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"在脚本中重定向输入\"><a href=\"#在脚本中重定向输入\" class=\"headerlink\" title=\"在脚本中重定向输入\"></a>在脚本中重定向输入</h2><p>可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。exec命令允许将STDIN重定向到Linux系统上的文件中。这个重定向只要在脚本需要输入时就会作用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting file input</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建自己的重定向\"><a href=\"#创建自己的重定向\" class=\"headerlink\" title=\"创建自己的重定向\"></a>创建自己的重定向</h2><h3 id=\"创建输出文件描述符\"><a href=\"#创建输出文件描述符\" class=\"headerlink\" title=\"创建输出文件描述符\"></a>创建输出文件描述符</h3><p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using an alternative file descriptor</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span>test3out\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This should display on the monitor\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"and this should be stored in the file\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;3</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Then this should be back on the monitor\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"创建输入文件描述符\"><a href=\"#创建输入文件描述符\" class=\"headerlink\" title=\"创建输入文件描述符\"></a>创建输入文件描述符</h3><p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># redirecting input file descriptors</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">6</span>&lt;</span><span class=\"token file-descriptor important\">&amp;0</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span> testfile\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">read</span> line\n<span class=\"token keyword\">do</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Line #<span class=\"token variable\">$count</span>: <span class=\"token variable\">$line</span>\"</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span><span class=\"token file-descriptor important\">&amp;6</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"Are you done now? \"</span> answer\n<span class=\"token keyword\">case</span> <span class=\"token variable\">$answer</span> <span class=\"token keyword\">in</span>\nY<span class=\"token operator\">|</span>y<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Goodbye\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\nN<span class=\"token operator\">|</span>n<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Sorry, this is the end.\"</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">esac</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"组织命令输出\"><a href=\"#组织命令输出\" class=\"headerlink\" title=\"组织命令输出\"></a>组织命令输出</h2><p>有时候，可能不想显示脚本的输出。这在将脚本作为后台进程运行时很常见。可以将STDERR重定向到一个叫作null文件的特殊&#x2F;文件。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。在Linux系统上null文件的标准位置是&#x2F;dev&#x2F;null。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> <span class=\"token operator\">></span> /dev/null\nubuntu@sh:~$\nubuntu@sh:~$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-al</span> badfile <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> /dev/null\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"title":"Shell函数","date":"2023-04-18T03:31:23.000Z","_content":"\n编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。\n\n函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。\n\n## 基本脚本函数\n\n### 创建函数、调用函数\n\n1. 第一种方式采用function关键字，后面跟函数名以及代码块\n\n    ```bash\n    function 函数名 {\n        函数体\n    }\n    ```\n\n    name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。\n\n2. 第二种方式更接近其他编程语言的定义方式\n\n    ```bash\n    函数名() {\n        函数体\n    }\n    ```\n\n```bash\n#!/bin/bash\n\ngreet\nfunction greet {\n    echo \"Hello, World!\"\n}\ngreet\n\n```\n\n- 当函数在被定义之前使用的话会产生错误信息\n\n```bash\n#!/bin/bash\n# using a function located in the middle of a script\ncount=1\necho \"This line comes before the function definition\"\nfunction func1 {\necho \"This is an exam,rple of a function\"\n}\nwhile [ $count -le 5 ]\ndo\nfunc1\ncount=$[ $count + 1 ]\ndone\necho \"This is the end of the loop\"\nfunc2\necho \"Now this is the end of the script\"\nfunction func2 {\necho \"This is an example of a function\"\n}\n```\n\n## 返回值\n\n`bash shell`会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成`退出状态码`。\n\n### 默认退出状态码\n\n默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量`$?`来确定函数的退出状态码。\n\n```bash\n#!/bin/bash\n\nfunction greet {\n  # ls -l badfile\n    echo \"Hello, World!\"\n  ls -l badfile\n}\n\ngreet\necho \"the exit status is: $?\"\n```\n\n如果注释掉第一个`ls`命令，由于函数的最后一条语句`echo`运行成功，该函数的退出状态是`0`，尽管前一个命令没有运行成功。\n\n### 使用return命令\n\n`bash shell`使用`return`命令来退出函数并返回特定的退出状态码。`return`命令允许指定一个整数值来定义函数的`退出状态码`\n\n```bash\n#!/bin/bash\n# using the return command in a function\nfunction dbl {\nread -p \"Enter a value: \" value\necho \"doubling the value\"\nreturn $[ $value * 2 ]\n}\ndbl\necho \"The new value is $?\"\n```\n\n`dbl`函数会将`$value`变量中用户输入的值翻倍，然后用`return`命令返回结果。脚本用`$?`变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：\n\n1. 函数一结束就取返回值\n2. 退出状态码必须是0~255\n\n如果在用`$?`变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，`$?`变量会返回执行的最后一条命令的退出状态码。\n第二个问题界定了返回值的取值范围。由于退出状态码必须`小于256`，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。\n\n```shell\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\ndoubling the value\nThe new value is 144\n```\n\n### 使用函数输出\n\n正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：\n\n```bash\nresult=`dbl`\n```\n\n这个命令会将`dbl`函数的输出赋给`$result`变量。\n\n```bash\n#!/bin/bash\n# using the echo to return a value\nfunction dbl {\nread -p \"Enter a value: \" value\necho $[ $value * 2 ]\n}\nresult=`dbl`\necho \"The new value is $result\"\n```\n\n```shell\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\nvalue = 400\nubuntu@sh:~$\n```\n\n## 函数中使用变量\n\n### 向函数传递参数\n\nbash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。\n\n函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`等定义。也可以用特殊变量`$#`来判断传给函数的参数数目。\n\n```bash\n#!/bin/bash\n\n# 定义一个函数，接收两个参数并输出它们\nfunction print_two_args {\n    echo \"第一个参数是：$1\"\n    echo \"第二个参数是：$2\"\n}\n\n# 调用函数，并传递两个参数\nprint_two_args \"hello\" \"world\"\n```\n\n```shell\n第一个参数是：hello\n第二个参数是：world\n```\n\n### 在函数中处理变量\n\n作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。\n\n### 全局变量\n\n对于全局变量，可以直接在函数中使用或修改。例如：\n\n```bash\n#!/bin/bash\n\n# 定义全局变量\nname=\"Tom\"\n\n# 定义函数\nmy_func() {\n  echo \"Hello, $name\"\n  name=\"Jerry\"\n}\n\n# 调用函数\nmy_func\necho \"Name is $name\" # 输出 \"Name is Jerry\"\n```\n\n### 局部变量\n\n```bash\n#!/bin/bash\n\n# 定义函数\nmy_func() {\n  # 定义局部变量\n  local count=0\n\n  # 修改局部变量\n  count=$[ $count + 1 ]\n\n  # 输出局部变量\n  echo \"Count is $count\"\n}\n\n# 调用函数\nmy_func # 输出 \"Count is 1\"\n\n```\n\n需要注意的是，在函数中使用局部变量时，变量名前必须加上 **`local`**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。\n\n```bash\n#!/bin/bash\n# 在函数中使用局部变量不会影响到脚本主体中的全局变量的值\nfunction func1 {\nlocal temp=$[ $value + 5 ]\nresult=$[ $temp * 2 ]\n}\ntemp=4\nvalue=6\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\necho \"temp is larger\"\nelse\necho \"temp is smaller\"\nfi\n```\n\n## 在命令行上使用函数\n\n可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在`PATH`环境变量里。重点在于让shell能够识别这些函数。\n\n### 在命令行上创建函数\n\n- 单行方式定义函数\n\n```bash\nubuntu@sh:~$ function addem { echo $[ $1 + $2 ]; }\nubuntu@sh:~$ addem 1 2\n3\n```\n\n- 多行方式定义函数\n\n```bash\nubuntu@sh:~$ function multem {\n> echo $[ $1 * $2 ]\n> }\nubuntu@sh:~$ multem 2 4\n8\nubuntu@sh:~$\n```\n\n在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。\n\n### 在.bashrc文件中定义函数\n\n在命令行上直接定义`shell`函数的明显缺点是退出`shell`时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在`shell`启动时由`shell`重新载入。`.bashrc`文件会在每次`shell`启动时在主目录下被查找并调用，因此可以在主目录下的.`bashrc`文件中定义函数。\n\n将以下内容写入到`.bashrc`文件的末尾：\n\n```bash\nfunction addem {\necho $[ $1 + $2 ]\n}\n```\n\n## 创建库\n\n通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：\n\n```bash\nfunction addem {\necho $[ $1 + $2 ]\n}\nfunction multem {\necho $[ $1 * $2 ]\n}\nfunction divem {\nif [ $2 -ne 0 ]\nthen\necho $[ $1 / $2 ]\nelse\necho -1\nfi\n}\n```\n\n在另一个脚本中执行`myfuncs`\n\n```bash\n#!/bin/bash\n# using a library file the wrong way\n./myfuncs\nresult=$(adem 10 15)\necho \"The result is $result\"\n```\n\n输出信息\n\n```shell\naddem: command not found\nThe result is\n```\n\n使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。\n\n```bash\n#!/bin/bash\n# using functions defined in a library file\n. ./myfuncs\nvalue1=10\nvalue2=5\nresult1=$(addem $value1 $value2)\nresult2=$(multem $value1 $value2)\nresult3=$(divem $value1 $value2)\necho \"The result of adding them is: $result1\"\necho \"The result of multiplying them is: $result2\"\necho \"The result of dividing them is: $result3\"\n```\n\n## 通过函数体实现加减运算\n\n```bash\nfunction calculate {\n\n    case $op in\n        \"+\")\n            result=\n            ;;\n        \"-\")\n            result=\n            ;;\n        *)\n            echo \"Error: unsupported operator.\"\n            return 1\n            ;;\n    esac\n    echo \"Result: $result\"\n    return 0\n}\n```\n","source":"_posts/linux_shell/7.Shell函数.md","raw":"---\ntitle: Shell函数\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。\n\n函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。\n\n## 基本脚本函数\n\n### 创建函数、调用函数\n\n1. 第一种方式采用function关键字，后面跟函数名以及代码块\n\n    ```bash\n    function 函数名 {\n        函数体\n    }\n    ```\n\n    name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。\n\n2. 第二种方式更接近其他编程语言的定义方式\n\n    ```bash\n    函数名() {\n        函数体\n    }\n    ```\n\n```bash\n#!/bin/bash\n\ngreet\nfunction greet {\n    echo \"Hello, World!\"\n}\ngreet\n\n```\n\n- 当函数在被定义之前使用的话会产生错误信息\n\n```bash\n#!/bin/bash\n# using a function located in the middle of a script\ncount=1\necho \"This line comes before the function definition\"\nfunction func1 {\necho \"This is an exam,rple of a function\"\n}\nwhile [ $count -le 5 ]\ndo\nfunc1\ncount=$[ $count + 1 ]\ndone\necho \"This is the end of the loop\"\nfunc2\necho \"Now this is the end of the script\"\nfunction func2 {\necho \"This is an example of a function\"\n}\n```\n\n## 返回值\n\n`bash shell`会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成`退出状态码`。\n\n### 默认退出状态码\n\n默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量`$?`来确定函数的退出状态码。\n\n```bash\n#!/bin/bash\n\nfunction greet {\n  # ls -l badfile\n    echo \"Hello, World!\"\n  ls -l badfile\n}\n\ngreet\necho \"the exit status is: $?\"\n```\n\n如果注释掉第一个`ls`命令，由于函数的最后一条语句`echo`运行成功，该函数的退出状态是`0`，尽管前一个命令没有运行成功。\n\n### 使用return命令\n\n`bash shell`使用`return`命令来退出函数并返回特定的退出状态码。`return`命令允许指定一个整数值来定义函数的`退出状态码`\n\n```bash\n#!/bin/bash\n# using the return command in a function\nfunction dbl {\nread -p \"Enter a value: \" value\necho \"doubling the value\"\nreturn $[ $value * 2 ]\n}\ndbl\necho \"The new value is $?\"\n```\n\n`dbl`函数会将`$value`变量中用户输入的值翻倍，然后用`return`命令返回结果。脚本用`$?`变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：\n\n1. 函数一结束就取返回值\n2. 退出状态码必须是0~255\n\n如果在用`$?`变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，`$?`变量会返回执行的最后一条命令的退出状态码。\n第二个问题界定了返回值的取值范围。由于退出状态码必须`小于256`，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。\n\n```shell\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\ndoubling the value\nThe new value is 144\n```\n\n### 使用函数输出\n\n正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：\n\n```bash\nresult=`dbl`\n```\n\n这个命令会将`dbl`函数的输出赋给`$result`变量。\n\n```bash\n#!/bin/bash\n# using the echo to return a value\nfunction dbl {\nread -p \"Enter a value: \" value\necho $[ $value * 2 ]\n}\nresult=`dbl`\necho \"The new value is $result\"\n```\n\n```shell\nubuntu@sh:~$ bash test.sh\nEnter a value: 200\nvalue = 400\nubuntu@sh:~$\n```\n\n## 函数中使用变量\n\n### 向函数传递参数\n\nbash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。\n\n函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`等定义。也可以用特殊变量`$#`来判断传给函数的参数数目。\n\n```bash\n#!/bin/bash\n\n# 定义一个函数，接收两个参数并输出它们\nfunction print_two_args {\n    echo \"第一个参数是：$1\"\n    echo \"第二个参数是：$2\"\n}\n\n# 调用函数，并传递两个参数\nprint_two_args \"hello\" \"world\"\n```\n\n```shell\n第一个参数是：hello\n第二个参数是：world\n```\n\n### 在函数中处理变量\n\n作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。\n\n### 全局变量\n\n对于全局变量，可以直接在函数中使用或修改。例如：\n\n```bash\n#!/bin/bash\n\n# 定义全局变量\nname=\"Tom\"\n\n# 定义函数\nmy_func() {\n  echo \"Hello, $name\"\n  name=\"Jerry\"\n}\n\n# 调用函数\nmy_func\necho \"Name is $name\" # 输出 \"Name is Jerry\"\n```\n\n### 局部变量\n\n```bash\n#!/bin/bash\n\n# 定义函数\nmy_func() {\n  # 定义局部变量\n  local count=0\n\n  # 修改局部变量\n  count=$[ $count + 1 ]\n\n  # 输出局部变量\n  echo \"Count is $count\"\n}\n\n# 调用函数\nmy_func # 输出 \"Count is 1\"\n\n```\n\n需要注意的是，在函数中使用局部变量时，变量名前必须加上 **`local`**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。\n\n```bash\n#!/bin/bash\n# 在函数中使用局部变量不会影响到脚本主体中的全局变量的值\nfunction func1 {\nlocal temp=$[ $value + 5 ]\nresult=$[ $temp * 2 ]\n}\ntemp=4\nvalue=6\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\necho \"temp is larger\"\nelse\necho \"temp is smaller\"\nfi\n```\n\n## 在命令行上使用函数\n\n可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在`PATH`环境变量里。重点在于让shell能够识别这些函数。\n\n### 在命令行上创建函数\n\n- 单行方式定义函数\n\n```bash\nubuntu@sh:~$ function addem { echo $[ $1 + $2 ]; }\nubuntu@sh:~$ addem 1 2\n3\n```\n\n- 多行方式定义函数\n\n```bash\nubuntu@sh:~$ function multem {\n> echo $[ $1 * $2 ]\n> }\nubuntu@sh:~$ multem 2 4\n8\nubuntu@sh:~$\n```\n\n在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。\n\n### 在.bashrc文件中定义函数\n\n在命令行上直接定义`shell`函数的明显缺点是退出`shell`时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在`shell`启动时由`shell`重新载入。`.bashrc`文件会在每次`shell`启动时在主目录下被查找并调用，因此可以在主目录下的.`bashrc`文件中定义函数。\n\n将以下内容写入到`.bashrc`文件的末尾：\n\n```bash\nfunction addem {\necho $[ $1 + $2 ]\n}\n```\n\n## 创建库\n\n通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：\n\n```bash\nfunction addem {\necho $[ $1 + $2 ]\n}\nfunction multem {\necho $[ $1 * $2 ]\n}\nfunction divem {\nif [ $2 -ne 0 ]\nthen\necho $[ $1 / $2 ]\nelse\necho -1\nfi\n}\n```\n\n在另一个脚本中执行`myfuncs`\n\n```bash\n#!/bin/bash\n# using a library file the wrong way\n./myfuncs\nresult=$(adem 10 15)\necho \"The result is $result\"\n```\n\n输出信息\n\n```shell\naddem: command not found\nThe result is\n```\n\n使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。\n\n```bash\n#!/bin/bash\n# using functions defined in a library file\n. ./myfuncs\nvalue1=10\nvalue2=5\nresult1=$(addem $value1 $value2)\nresult2=$(multem $value1 $value2)\nresult3=$(divem $value1 $value2)\necho \"The result of adding them is: $result1\"\necho \"The result of multiplying them is: $result2\"\necho \"The result of dividing them is: $result3\"\n```\n\n## 通过函数体实现加减运算\n\n```bash\nfunction calculate {\n\n    case $op in\n        \"+\")\n            result=\n            ;;\n        \"-\")\n            result=\n            ;;\n        *)\n            echo \"Error: unsupported operator.\"\n            return 1\n            ;;\n    esac\n    echo \"Result: $result\"\n    return 0\n}\n```\n","slug":"linux_shell/7.Shell函数","published":1,"updated":"2023-06-16T13:23:13.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04n000e1dnz7qz4amte","content":"<p>编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。</p>\n<p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>\n<h2 id=\"基本脚本函数\"><a href=\"#基本脚本函数\" class=\"headerlink\" title=\"基本脚本函数\"></a>基本脚本函数</h2><h3 id=\"创建函数、调用函数\"><a href=\"#创建函数、调用函数\" class=\"headerlink\" title=\"创建函数、调用函数\"></a>创建函数、调用函数</h3><ol>\n<li><p>第一种方式采用function关键字，后面跟函数名以及代码块</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> 函数名 <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p> name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>\n</li>\n<li><p>第二种方式更接近其他编程语言的定义方式</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">函数名<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\ngreet\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">greet</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, World!\"</span>\n<span class=\"token punctuation\">&#125;</span>\ngreet\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>当函数在被定义之前使用的话会产生错误信息</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using a function located in the middle of a script</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This line comes before the function definition\"</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an exam,rple of a function\"</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\nfunc1\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the end of the loop\"</span>\nfunc2\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Now this is the end of the script\"</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func2</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an example of a function\"</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p><code>bash shell</code>会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成<code>退出状态码</code>。</p>\n<h3 id=\"默认退出状态码\"><a href=\"#默认退出状态码\" class=\"headerlink\" title=\"默认退出状态码\"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">greet</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\"># ls -l badfile</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, World!\"</span>\n  <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> badfile\n<span class=\"token punctuation\">&#125;</span>\n\ngreet\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"the exit status is: <span class=\"token variable\">$?</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果注释掉第一个<code>ls</code>命令，由于函数的最后一条语句<code>echo</code>运行成功，该函数的退出状态是<code>0</code>，尽管前一个命令没有运行成功。</p>\n<h3 id=\"使用return命令\"><a href=\"#使用return命令\" class=\"headerlink\" title=\"使用return命令\"></a>使用return命令</h3><p><code>bash shell</code>使用<code>return</code>命令来退出函数并返回特定的退出状态码。<code>return</code>命令允许指定一个整数值来定义函数的<code>退出状态码</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the return command in a function</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"Enter a value: \"</span> value\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"doubling the value\"</span>\n<span class=\"token builtin class-name\">return</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\ndbl\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$?</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>dbl</code>函数会将<code>$value</code>变量中用户输入的值翻倍，然后用<code>return</code>命令返回结果。脚本用<code>$?</code>变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：</p>\n<ol>\n<li>函数一结束就取返回值</li>\n<li>退出状态码必须是0~255</li>\n</ol>\n<p>如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，<code>$?</code>变量会返回执行的最后一条命令的退出状态码。<br>第二个问题界定了返回值的取值范围。由于退出状态码必须<code>小于256</code>，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh\nEnter a value: <span class=\"token number\">200</span>\ndoubling the value\nThe new value is <span class=\"token number\">144</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用函数输出\"><a href=\"#使用函数输出\" class=\"headerlink\" title=\"使用函数输出\"></a>使用函数输出</h3><p>正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>dbl<span class=\"token variable\">`</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个命令会将<code>dbl</code>函数的输出赋给<code>$result</code>变量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the echo to return a value</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"Enter a value: \"</span> value\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>dbl<span class=\"token variable\">`</span></span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$result</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh\nEnter a value: <span class=\"token number\">200</span>\nvalue <span class=\"token operator\">=</span> <span class=\"token number\">400</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"函数中使用变量\"><a href=\"#函数中使用变量\" class=\"headerlink\" title=\"函数中使用变量\"></a>函数中使用变量</h2><h3 id=\"向函数传递参数\"><a href=\"#向函数传递参数\" class=\"headerlink\" title=\"向函数传递参数\"></a>向函数传递参数</h3><p>bash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。</p>\n<p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 定义一个函数，接收两个参数并输出它们</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">print_two_args</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第一个参数是：<span class=\"token variable\">$1</span>\"</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第二个参数是：<span class=\"token variable\">$2</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 调用函数，并传递两个参数</span>\nprint_two_args <span class=\"token string\">\"hello\"</span> <span class=\"token string\">\"world\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">第一个参数是：hello\n第二个参数是：world<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"在函数中处理变量\"><a href=\"#在函数中处理变量\" class=\"headerlink\" title=\"在函数中处理变量\"></a>在函数中处理变量</h3><p>作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>对于全局变量，可以直接在函数中使用或修改。例如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 定义全局变量</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"Tom\"</span>\n\n<span class=\"token comment\"># 定义函数</span>\n<span class=\"token function-name function\">my_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$name</span>\"</span>\n  <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"Jerry\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 调用函数</span>\nmy_func\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Name is <span class=\"token variable\">$name</span>\"</span> <span class=\"token comment\"># 输出 \"Name is Jerry\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 定义函数</span>\n<span class=\"token function-name function\">my_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\"># 定义局部变量</span>\n  <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n  <span class=\"token comment\"># 修改局部变量</span>\n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n\n  <span class=\"token comment\"># 输出局部变量</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Count is <span class=\"token variable\">$count</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 调用函数</span>\nmy_func <span class=\"token comment\"># 输出 \"Count is 1\"</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，在函数中使用局部变量时，变量名前必须加上 **<code>local</code>**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># 在函数中使用局部变量不会影响到脚本主体中的全局变量的值</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> + <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span><span class=\"token number\">4</span>\n<span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token number\">6</span>\nfunc1\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is larger\"</span>\n<span class=\"token keyword\">else</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is smaller\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"在命令行上使用函数\"><a href=\"#在命令行上使用函数\" class=\"headerlink\" title=\"在命令行上使用函数\"></a>在命令行上使用函数</h2><p>可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在<code>PATH</code>环境变量里。重点在于让shell能够识别这些函数。</p>\n<h3 id=\"在命令行上创建函数\"><a href=\"#在命令行上创建函数\" class=\"headerlink\" title=\"在命令行上创建函数\"></a>在命令行上创建函数</h3><ul>\n<li>单行方式定义函数</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\nubuntu@sh:~$ addem <span class=\"token number\">1</span> <span class=\"token number\">2</span>\n<span class=\"token number\">3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>多行方式定义函数</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token keyword\">function</span> <span class=\"token function-name function\">multem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token operator\">></span> <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token operator\">></span> <span class=\"token punctuation\">&#125;</span>\nubuntu@sh:~$ multem <span class=\"token number\">2</span> <span class=\"token number\">4</span>\n<span class=\"token number\">8</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。</p>\n<h3 id=\"在-bashrc文件中定义函数\"><a href=\"#在-bashrc文件中定义函数\" class=\"headerlink\" title=\"在.bashrc文件中定义函数\"></a>在.bashrc文件中定义函数</h3><p>在命令行上直接定义<code>shell</code>函数的明显缺点是退出<code>shell</code>时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在<code>shell</code>启动时由<code>shell</code>重新载入。<code>.bashrc</code>文件会在每次<code>shell</code>启动时在主目录下被查找并调用，因此可以在主目录下的.<code>bashrc</code>文件中定义函数。</p>\n<p>将以下内容写入到<code>.bashrc</code>文件的末尾：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建库\"><a href=\"#创建库\" class=\"headerlink\" title=\"创建库\"></a>创建库</h2><p>通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">multem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">divem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$2</span> <span class=\"token parameter variable\">-ne</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> / <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">else</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-1</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在另一个脚本中执行<code>myfuncs</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using a library file the wrong way</span>\n./myfuncs\n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>adem <span class=\"token number\">10</span> <span class=\"token number\">15</span><span class=\"token variable\">)</span></span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出信息</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">addem: <span class=\"token builtin class-name\">command</span> not found\nThe result is<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using functions defined in a library file</span>\n<span class=\"token builtin class-name\">.</span> ./myfuncs\n<span class=\"token assign-left variable\">value1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n<span class=\"token assign-left variable\">value2</span><span class=\"token operator\">=</span><span class=\"token number\">5</span>\n<span class=\"token assign-left variable\">result1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>addem $value1 $value2<span class=\"token variable\">)</span></span>\n<span class=\"token assign-left variable\">result2</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>multem $value1 $value2<span class=\"token variable\">)</span></span>\n<span class=\"token assign-left variable\">result3</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>divem $value1 $value2<span class=\"token variable\">)</span></span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result of adding them is: <span class=\"token variable\">$result1</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result of multiplying them is: <span class=\"token variable\">$result2</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result of dividing them is: <span class=\"token variable\">$result3</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"通过函数体实现加减运算\"><a href=\"#通过函数体实现加减运算\" class=\"headerlink\" title=\"通过函数体实现加减运算\"></a>通过函数体实现加减运算</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">calculate</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token variable\">$op</span> <span class=\"token keyword\">in</span>\n        <span class=\"token string\">\"+\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        *<span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Error: unsupported operator.\"</span>\n            <span class=\"token builtin class-name\">return</span> <span class=\"token number\">1</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">esac</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Result: <span class=\"token variable\">$result</span>\"</span>\n    <span class=\"token builtin class-name\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>编写shell脚本时，经常需要在多个地方使用了同一段代码。如果只是一小段代码，一般也无关紧要。但要在shell脚本中多次重写大块代码段就太累人了。bash shell提供的用户自定义函数功能可以解决这个问题。可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用。</p>\n<p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块时，只要使用所起的函数名就行了（这个过程称为调用函数）。</p>\n<h2 id=\"基本脚本函数\"><a href=\"#基本脚本函数\" class=\"headerlink\" title=\"基本脚本函数\"></a>基本脚本函数</h2><h3 id=\"创建函数、调用函数\"><a href=\"#创建函数、调用函数\" class=\"headerlink\" title=\"创建函数、调用函数\"></a>创建函数、调用函数</h3><ol>\n<li><p>第一种方式采用function关键字，后面跟函数名以及代码块</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> 函数名 <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p> name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。</p>\n</li>\n<li><p>第二种方式更接近其他编程语言的定义方式</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">函数名<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    函数体\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\ngreet\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">greet</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, World!\"</span>\n<span class=\"token punctuation\">&#125;</span>\ngreet\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>当函数在被定义之前使用的话会产生错误信息</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using a function located in the middle of a script</span>\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This line comes before the function definition\"</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an exam,rple of a function\"</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> <span class=\"token parameter variable\">-le</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">do</span>\nfunc1\n<span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">done</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is the end of the loop\"</span>\nfunc2\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Now this is the end of the script\"</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func2</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"This is an example of a function\"</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p><code>bash shell</code>会把函数当作一个小型脚本，运行结束时会返回一个退出状态码。有3种不同的方法来为函数生成<code>退出状态码</code>。</p>\n<h3 id=\"默认退出状态码\"><a href=\"#默认退出状态码\" class=\"headerlink\" title=\"默认退出状态码\"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量<code>$?</code>来确定函数的退出状态码。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">greet</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\"># ls -l badfile</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, World!\"</span>\n  <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-l</span> badfile\n<span class=\"token punctuation\">&#125;</span>\n\ngreet\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"the exit status is: <span class=\"token variable\">$?</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果注释掉第一个<code>ls</code>命令，由于函数的最后一条语句<code>echo</code>运行成功，该函数的退出状态是<code>0</code>，尽管前一个命令没有运行成功。</p>\n<h3 id=\"使用return命令\"><a href=\"#使用return命令\" class=\"headerlink\" title=\"使用return命令\"></a>使用return命令</h3><p><code>bash shell</code>使用<code>return</code>命令来退出函数并返回特定的退出状态码。<code>return</code>命令允许指定一个整数值来定义函数的<code>退出状态码</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the return command in a function</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"Enter a value: \"</span> value\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"doubling the value\"</span>\n<span class=\"token builtin class-name\">return</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\ndbl\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$?</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>dbl</code>函数会将<code>$value</code>变量中用户输入的值翻倍，然后用<code>return</code>命令返回结果。脚本用<code>$?</code>变量显示了该值。当使用该方法从函数中获取返回值时有两个要点：</p>\n<ol>\n<li>函数一结束就取返回值</li>\n<li>退出状态码必须是0~255</li>\n</ol>\n<p>如果在用<code>$?</code>变量提取函数返回值之前执行了其他命令，函数的返回值就会丢失。记住，<code>$?</code>变量会返回执行的最后一条命令的退出状态码。<br>第二个问题界定了返回值的取值范围。由于退出状态码必须<code>小于256</code>，函数的结果必须生成一个小于256的整数值。任何大于256的值都会产生一个错误值。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh\nEnter a value: <span class=\"token number\">200</span>\ndoubling the value\nThe new value is <span class=\"token number\">144</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用函数输出\"><a href=\"#使用函数输出\" class=\"headerlink\" title=\"使用函数输出\"></a>使用函数输出</h3><p>正如可以将命令的输出保存到shell变量中一样，也可以对函数的输出采用同样的处理办法。可以用这种技术来获得任何类型的函数输出，并将其保存到变量中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>dbl<span class=\"token variable\">`</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个命令会将<code>dbl</code>函数的输出赋给<code>$result</code>变量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using the echo to return a value</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">dbl</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">read</span> <span class=\"token parameter variable\">-p</span> <span class=\"token string\">\"Enter a value: \"</span> value\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">`</span>dbl<span class=\"token variable\">`</span></span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The new value is <span class=\"token variable\">$result</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">bash</span> test.sh\nEnter a value: <span class=\"token number\">200</span>\nvalue <span class=\"token operator\">=</span> <span class=\"token number\">400</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"函数中使用变量\"><a href=\"#函数中使用变量\" class=\"headerlink\" title=\"函数中使用变量\"></a>函数中使用变量</h2><h3 id=\"向函数传递参数\"><a href=\"#向函数传递参数\" class=\"headerlink\" title=\"向函数传递参数\"></a>向函数传递参数</h3><p>bash shell会将函数当作小型脚本来对待。这意味着可以像普通脚本那样向函数传递参数。</p>\n<p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>等定义。也可以用特殊变量<code>$#</code>来判断传给函数的参数数目。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 定义一个函数，接收两个参数并输出它们</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">print_two_args</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第一个参数是：<span class=\"token variable\">$1</span>\"</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"第二个参数是：<span class=\"token variable\">$2</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 调用函数，并传递两个参数</span>\nprint_two_args <span class=\"token string\">\"hello\"</span> <span class=\"token string\">\"world\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">第一个参数是：hello\n第二个参数是：world<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"在函数中处理变量\"><a href=\"#在函数中处理变量\" class=\"headerlink\" title=\"在函数中处理变量\"></a>在函数中处理变量</h3><p>作用域是变量可见的区域。函数中定义的变量与普通变量的作用域不同。也就是说，对脚本的其他部分而言，它们是隐藏的。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>对于全局变量，可以直接在函数中使用或修改。例如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 定义全局变量</span>\n<span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"Tom\"</span>\n\n<span class=\"token comment\"># 定义函数</span>\n<span class=\"token function-name function\">my_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Hello, <span class=\"token variable\">$name</span>\"</span>\n  <span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"Jerry\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 调用函数</span>\nmy_func\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Name is <span class=\"token variable\">$name</span>\"</span> <span class=\"token comment\"># 输出 \"Name is Jerry\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token comment\"># 定义函数</span>\n<span class=\"token function-name function\">my_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\"># 定义局部变量</span>\n  <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n  <span class=\"token comment\"># 修改局部变量</span>\n  <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$count</span> + <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n\n  <span class=\"token comment\"># 输出局部变量</span>\n  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Count is <span class=\"token variable\">$count</span>\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 调用函数</span>\nmy_func <span class=\"token comment\"># 输出 \"Count is 1\"</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，在函数中使用局部变量时，变量名前必须加上 **<code>local</code>**关键字，否则会被认为是全局变量。如果函数中定义了一个与全局变量同名的局部变量，则在函数中访问该变量时，会优先使用局部变量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># 在函数中使用局部变量不会影响到脚本主体中的全局变量的值</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">func1</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$value</span> + <span class=\"token number\">5</span> <span class=\"token punctuation\">]</span>\n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>$<span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> * <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token assign-left variable\">temp</span><span class=\"token operator\">=</span><span class=\"token number\">4</span>\n<span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token number\">6</span>\nfunc1\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$temp</span> <span class=\"token parameter variable\">-gt</span> <span class=\"token variable\">$value</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is larger\"</span>\n<span class=\"token keyword\">else</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp is smaller\"</span>\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"在命令行上使用函数\"><a href=\"#在命令行上使用函数\" class=\"headerlink\" title=\"在命令行上使用函数\"></a>在命令行上使用函数</h2><p>可以用脚本函数来执行一些十分复杂的操作。有时也很有必要在命令行界面的提示符下直接使用这些函数。一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在<code>PATH</code>环境变量里。重点在于让shell能够识别这些函数。</p>\n<h3 id=\"在命令行上创建函数\"><a href=\"#在命令行上创建函数\" class=\"headerlink\" title=\"在命令行上创建函数\"></a>在命令行上创建函数</h3><ul>\n<li>单行方式定义函数</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\nubuntu@sh:~$ addem <span class=\"token number\">1</span> <span class=\"token number\">2</span>\n<span class=\"token number\">3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>多行方式定义函数</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token keyword\">function</span> <span class=\"token function-name function\">multem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token operator\">></span> <span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token operator\">></span> <span class=\"token punctuation\">&#125;</span>\nubuntu@sh:~$ multem <span class=\"token number\">2</span> <span class=\"token number\">4</span>\n<span class=\"token number\">8</span>\nubuntu@sh:~$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在函数的尾部使用花括号，shell就会知道你已经完成了函数的定义。</p>\n<h3 id=\"在-bashrc文件中定义函数\"><a href=\"#在-bashrc文件中定义函数\" class=\"headerlink\" title=\"在.bashrc文件中定义函数\"></a>在.bashrc文件中定义函数</h3><p>在命令行上直接定义<code>shell</code>函数的明显缺点是退出<code>shell</code>时，函数就消失了，这对于一些复杂函数并不适用。此时可以将函数写入一个特定位置并且在<code>shell</code>启动时由<code>shell</code>重新载入。<code>.bashrc</code>文件会在每次<code>shell</code>启动时在主目录下被查找并调用，因此可以在主目录下的.<code>bashrc</code>文件中定义函数。</p>\n<p>将以下内容写入到<code>.bashrc</code>文件的末尾：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建库\"><a href=\"#创建库\" class=\"headerlink\" title=\"创建库\"></a>创建库</h2><p>通过创建函数库文件可以方便在多个脚本中使用同一段代码。以下代码保存在myfuncs文件中：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">addem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> + <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">multem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> * <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function-name function\">divem</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token variable\">$2</span> <span class=\"token parameter variable\">-ne</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">then</span>\n<span class=\"token builtin class-name\">echo</span> $<span class=\"token punctuation\">[</span> <span class=\"token variable\">$1</span> / <span class=\"token variable\">$2</span> <span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">else</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-1</span>\n<span class=\"token keyword\">fi</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在另一个脚本中执行<code>myfuncs</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using a library file the wrong way</span>\n./myfuncs\n<span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>adem <span class=\"token number\">10</span> <span class=\"token number\">15</span><span class=\"token variable\">)</span></span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result is <span class=\"token variable\">$result</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出信息</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">addem: <span class=\"token builtin class-name\">command</span> not found\nThe result is<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用函数库的关键在于source命令。source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n<span class=\"token comment\"># using functions defined in a library file</span>\n<span class=\"token builtin class-name\">.</span> ./myfuncs\n<span class=\"token assign-left variable\">value1</span><span class=\"token operator\">=</span><span class=\"token number\">10</span>\n<span class=\"token assign-left variable\">value2</span><span class=\"token operator\">=</span><span class=\"token number\">5</span>\n<span class=\"token assign-left variable\">result1</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>addem $value1 $value2<span class=\"token variable\">)</span></span>\n<span class=\"token assign-left variable\">result2</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>multem $value1 $value2<span class=\"token variable\">)</span></span>\n<span class=\"token assign-left variable\">result3</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>divem $value1 $value2<span class=\"token variable\">)</span></span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result of adding them is: <span class=\"token variable\">$result1</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result of multiplying them is: <span class=\"token variable\">$result2</span>\"</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The result of dividing them is: <span class=\"token variable\">$result3</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"通过函数体实现加减运算\"><a href=\"#通过函数体实现加减运算\" class=\"headerlink\" title=\"通过函数体实现加减运算\"></a>通过函数体实现加减运算</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">function</span> <span class=\"token function-name function\">calculate</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token variable\">$op</span> <span class=\"token keyword\">in</span>\n        <span class=\"token string\">\"+\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token assign-left variable\">result</span><span class=\"token operator\">=</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        *<span class=\"token punctuation\">)</span>\n            <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Error: unsupported operator.\"</span>\n            <span class=\"token builtin class-name\">return</span> <span class=\"token number\">1</span>\n            <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">esac</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Result: <span class=\"token variable\">$result</span>\"</span>\n    <span class=\"token builtin class-name\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n"},{"title":"正则表达式","date":"2023-04-18T03:31:23.000Z","_content":"\n正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，**正则表达式就是记录文本规则的代码**。\n\n![8.正则表达式-2023-06-16-21-24-50](https://raw.githubusercontent.com/yefreee/picture/main/note8.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2023-06-16-21-24-50.png)\n\n如果你想查找某个目录下的所有的Word文档的话，你会搜索`*.doc`。在这里，`*`会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号\"-\"，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321*)。\n\n## 入门\n\n正则表达式练习平台：[https://tool.oschina.net/regex/](https://tool.oschina.net/regex/)\n\n最简单的正则表达式举例： `hi` ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是`h`,后一个是`i`。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配`hi,HI,Hi,hI`这四种情况中的任意一种。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi\" |grep -i \"hi\"\nhi,Hi\nubuntu@sh:~$\nubuntu@sh:~$ echo \"hi,Hi,HI,hI\" |grep -i \"hi\"\nhi,Hi,HI,hI\n```\n\n## 元字符\n\n当目标文本中包含很多字符，比如`him,history,high`等等。用hi来查找的话，这里边的`hi`也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用`\\bhi\\b`。\\b是正则表达式规定的一个特殊代码（元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。\n\n假如要找的是`hi`后面不远处跟着一个`Lucy`，应该用`\\bhi\\b.*\\bLucy\\b`。\n\n这里，`.`是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，`.`连在一起就意味着任意数量的不包含换行的字符。现在`\\bhi\\b.*\\bLucy\\b`的意思就很明显：先是一个单词`hi`,然后是任意个任意字符(但不能是换行)，最后是`Lucy`这个单词。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi,HI,hI,Lucy\" |grep -o \"\\bhi\\b.*\\bLucy\\b\"\nhi,Hi,HI,hI,Lucy\n```\n\n`0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的`\\d`是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。\n\n也可以这样写这个表达式：`0\\d{2}-\\d{8}`。这里`\\d`后面的`{2}({8})`的意思是前面`\\d`必须连续重复匹配`2次(8次)`。\n\n练习1：匹配国际格式的电话号码`+086-185-553-24528`\n\n练习2：匹配国内电话号码`0511-4405222、021-87888822`\n\n- 常用的元字符\n\n| 代码 | 说明 |\n| --- | --- |\n| . | 匹配除换行符以外的任意字符 |\n| \\w | 匹配字母或数字或下划线或汉字 |\n| \\s | 匹配任意的空白符 |\n| \\d | 匹配数字 |\n| \\b | 匹配单词的开始或结束 |\n| ^ | 匹配字符串的开始 |\n| $ | 匹配字符串的结束 |\n\n元字符`^`（和数字6在同一个键位上的符号）和`$`都匹配一个位置，这和`\\b`有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\\d{5,12}$`。\n\n- 常用的限定符\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| * | 重复零次或更多次 |\n| + | 重复一次或更多次 |\n| ? | 重复零次或一次 |\n| {n} | 重复n次 |\n| {n,} | 重复n次或更多次 |\n| {n,m} | 重复n到m次 |\n\n1. `\\ba\\w*\\b`匹配以字母`a`开头的单词——先是某个单词开始处`(\\b)`，然后是字母`a`,然后是任意数量的字母或数字`(\\w*)`，最后是单词结束处`(\\b)`。\n2. `\\d+`匹配1个或更多连续的数字。这里的`+`是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次。\n3. `\\b\\w{6}\\b` 匹配刚好6个字符的单词。\n\n## 字符转义\n\n如果想查找元字符本身的话，比如查找`.`,或者`*`,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用`\\`来取消这些字符的特殊意义。因此，应该使用`\\.`和`\\*`。当然，要查找`\\`本身，也得用`\\\\`.\n\n例如：`deerchao\\.cn`匹配`deerchao.cn`，`C:\\\\Windows`匹配`C:\\Windows`。\n\n## 字符类\n\n要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。\n\n练习3：匹配(010)88886666，或022-22334455，或02912345678。\n\n## 分组\n\n想要重复多个字符又该怎么办？可以用小括号来指定**子表达式**(也叫做**分组**)，然后就可以指定这个子表达式的重复次数了。`(\\d{1,3}\\.){3}\\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：\n\n1. `\\d{1,3}`匹配1到3位的数字\n2. `(\\d{1,3}\\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次\n3. 最后再加上一个一到三位的数字`(\\d{1,3})`。\n\n它也将匹配*`256.300.888.999`*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)`。\n\n理解这个表达式的关键是理解`2[0-4]\\d|25[0-5]|[01]?\\d\\d?`。\n\n## 反义\n\n有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**。\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |\n| \\S | 匹配任意不是空白符的字符 |\n| \\D | 匹配任意非数字的字符 |\n| \\B | 匹配不是单词开头或结束的位置 |\n| [^x] | 匹配除了x以外的任意字符 |\n| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |\n\n例子：`\\S+`匹配不包含空白符的字符串。\n\n`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。\n\n## 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以`a`开始，以`b`结束的字符串。如果用它来搜索*`aabab`*的话，它会匹配整个字符串`aabab`。这被称为**贪婪**匹配。\n\n有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n\n举例：`a.*?b`匹配最短的，以`a`开始，以`b`结束的字符串。如果把它应用于*`aabab`*的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| *? | 重复任意次，但尽可能少重复 |\n| +? | 重复1次或更多次，但尽可能少重复 |\n| ?? | 重复0次或1次，但尽可能少重复 |\n| {n,m}? | 重复n到m次，但尽可能少重复 |\n| {n,}? | 重复n次以上，但尽可能少重复 |\n\n## grep命令\n\n### grep基本用法\n\n`Linux grep (global regular expression)` 命令用于查找文件里符合条件的字符串或正则表达式。\n\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 `-`，则 grep 指令会从标准输入设备读取数据。\n\n- 基于目标文件进行查找\n\n    ```bash\n    ubuntu@sh:~$ grep \"ubuntu\" /etc/passwd\n    ubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash\n    ```\n\n- 基于标准输入进行查找\n\n    ```bash\n    ubuntu@sh:~$ ps -aux |grep ssh\n    root        864  0.0  0.1  65508  5424 ?        Ss   Mar26   0:00 /usr/sbin/sshd -D\n    root      18851  0.0  0.1  92796  6836 ?        Ss   Apr06   0:00 sshd: ubuntu [priv]\n    ubuntu    18878  0.0  0.0  92796  3988 ?        S    Apr06   0:02 sshd: ubuntu@pts/0\n    ubuntu    23726  0.0  0.0  14220  1028 pts/0    S+   21:08   0:00 grep --color=auto ssh\n    ```\n\n- 常用选项\n  - `i`：忽略大小写进行匹配。\n  - `v`：反向查找，只打印不匹配的行。\n  - `n`：显示匹配行的行号。\n  - `r`：递归查找子目录中的文件。\n  - `l`：只打印匹配的文件名。\n  - `c`：只打印匹配的行数。\n\n### grep结合正则表达式用法\n\n- 已有文本文件`example.txt`，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：\n\n    ```bash\n    John Smith, 25, Engineer\n    Alice Brown, 30, Teacher\n    Bob Johnson, 40, Lawyer\n    ```\n\n    查找年龄在 30 岁及以上的人的信息，可以使用以下命令：\n\n    ```bash\n    grep '[3-9][0-9],.*' example.txt\n    ```\n\n- 找出`~`目录下以`.sh`结尾的文件名\n\n    ```bash\n    find ~ -name \"*.sh\" |grep -Eo \"[^/]+\\.sh\"\n    ```\n\n练习4：显示/etc/passwd中不以`/bin/bash`结尾的行\n\n练习1答案：`\\+\\d{3}-\\d{3}-\\d{3}-\\d{5}`\n\n练习2答案：`0\\d{3}-\\d{7}|0\\d{2}-\\d{8}`\n\n练习3答案：`\\(?0\\d{2}[)-]?\\d{8}`\n\n练习4答案：`cat /etc/passwd |grep -Ev \"(/bin/bash)$”`\n","source":"_posts/linux_shell/8.正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。\n\n在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，**正则表达式就是记录文本规则的代码**。\n\n![8.正则表达式-2023-06-16-21-24-50](https://raw.githubusercontent.com/yefreee/picture/main/note8.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2023-06-16-21-24-50.png)\n\n如果你想查找某个目录下的所有的Word文档的话，你会搜索`*.doc`。在这里，`*`会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号\"-\"，最后是7或8位数字的字符串(像*010-12345678*或*0376-7654321*)。\n\n## 入门\n\n正则表达式练习平台：[https://tool.oschina.net/regex/](https://tool.oschina.net/regex/)\n\n最简单的正则表达式举例： `hi` ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是`h`,后一个是`i`。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配`hi,HI,Hi,hI`这四种情况中的任意一种。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi\" |grep -i \"hi\"\nhi,Hi\nubuntu@sh:~$\nubuntu@sh:~$ echo \"hi,Hi,HI,hI\" |grep -i \"hi\"\nhi,Hi,HI,hI\n```\n\n## 元字符\n\n当目标文本中包含很多字符，比如`him,history,high`等等。用hi来查找的话，这里边的`hi`也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用`\\bhi\\b`。\\b是正则表达式规定的一个特殊代码（元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。\n\n假如要找的是`hi`后面不远处跟着一个`Lucy`，应该用`\\bhi\\b.*\\bLucy\\b`。\n\n这里，`.`是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，`.`连在一起就意味着任意数量的不包含换行的字符。现在`\\bhi\\b.*\\bLucy\\b`的意思就很明显：先是一个单词`hi`,然后是任意个任意字符(但不能是换行)，最后是`Lucy`这个单词。\n\n```bash\nubuntu@sh:~$ echo \"hi,Hi,HI,hI,Lucy\" |grep -o \"\\bhi\\b.*\\bLucy\\b\"\nhi,Hi,HI,hI,Lucy\n```\n\n`0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的`\\d`是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。\n\n也可以这样写这个表达式：`0\\d{2}-\\d{8}`。这里`\\d`后面的`{2}({8})`的意思是前面`\\d`必须连续重复匹配`2次(8次)`。\n\n练习1：匹配国际格式的电话号码`+086-185-553-24528`\n\n练习2：匹配国内电话号码`0511-4405222、021-87888822`\n\n- 常用的元字符\n\n| 代码 | 说明 |\n| --- | --- |\n| . | 匹配除换行符以外的任意字符 |\n| \\w | 匹配字母或数字或下划线或汉字 |\n| \\s | 匹配任意的空白符 |\n| \\d | 匹配数字 |\n| \\b | 匹配单词的开始或结束 |\n| ^ | 匹配字符串的开始 |\n| $ | 匹配字符串的结束 |\n\n元字符`^`（和数字6在同一个键位上的符号）和`$`都匹配一个位置，这和`\\b`有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\\d{5,12}$`。\n\n- 常用的限定符\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| * | 重复零次或更多次 |\n| + | 重复一次或更多次 |\n| ? | 重复零次或一次 |\n| {n} | 重复n次 |\n| {n,} | 重复n次或更多次 |\n| {n,m} | 重复n到m次 |\n\n1. `\\ba\\w*\\b`匹配以字母`a`开头的单词——先是某个单词开始处`(\\b)`，然后是字母`a`,然后是任意数量的字母或数字`(\\w*)`，最后是单词结束处`(\\b)`。\n2. `\\d+`匹配1个或更多连续的数字。这里的`+`是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次。\n3. `\\b\\w{6}\\b` 匹配刚好6个字符的单词。\n\n## 字符转义\n\n如果想查找元字符本身的话，比如查找`.`,或者`*`,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用`\\`来取消这些字符的特殊意义。因此，应该使用`\\.`和`\\*`。当然，要查找`\\`本身，也得用`\\\\`.\n\n例如：`deerchao\\.cn`匹配`deerchao.cn`，`C:\\\\Windows`匹配`C:\\Windows`。\n\n## 字符类\n\n要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)。\n\n练习3：匹配(010)88886666，或022-22334455，或02912345678。\n\n## 分组\n\n想要重复多个字符又该怎么办？可以用小括号来指定**子表达式**(也叫做**分组**)，然后就可以指定这个子表达式的重复次数了。`(\\d{1,3}\\.){3}\\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：\n\n1. `\\d{1,3}`匹配1到3位的数字\n2. `(\\d{1,3}\\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次\n3. 最后再加上一个一到三位的数字`(\\d{1,3})`。\n\n它也将匹配*`256.300.888.999`*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)`。\n\n理解这个表达式的关键是理解`2[0-4]\\d|25[0-5]|[01]?\\d\\d?`。\n\n## 反义\n\n有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**。\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |\n| \\S | 匹配任意不是空白符的字符 |\n| \\D | 匹配任意非数字的字符 |\n| \\B | 匹配不是单词开头或结束的位置 |\n| [^x] | 匹配除了x以外的任意字符 |\n| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |\n\n例子：`\\S+`匹配不包含空白符的字符串。\n\n`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。\n\n## 贪婪与懒惰\n\n当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以`a`开始，以`b`结束的字符串。如果用它来搜索*`aabab`*的话，它会匹配整个字符串`aabab`。这被称为**贪婪**匹配。\n\n有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。\n\n举例：`a.*?b`匹配最短的，以`a`开始，以`b`结束的字符串。如果把它应用于*`aabab`*的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。\n\n| 代码/语法 | 说明 |\n| --- | --- |\n| *? | 重复任意次，但尽可能少重复 |\n| +? | 重复1次或更多次，但尽可能少重复 |\n| ?? | 重复0次或1次，但尽可能少重复 |\n| {n,m}? | 重复n到m次，但尽可能少重复 |\n| {n,}? | 重复n次以上，但尽可能少重复 |\n\n## grep命令\n\n### grep基本用法\n\n`Linux grep (global regular expression)` 命令用于查找文件里符合条件的字符串或正则表达式。\n\ngrep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 `-`，则 grep 指令会从标准输入设备读取数据。\n\n- 基于目标文件进行查找\n\n    ```bash\n    ubuntu@sh:~$ grep \"ubuntu\" /etc/passwd\n    ubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash\n    ```\n\n- 基于标准输入进行查找\n\n    ```bash\n    ubuntu@sh:~$ ps -aux |grep ssh\n    root        864  0.0  0.1  65508  5424 ?        Ss   Mar26   0:00 /usr/sbin/sshd -D\n    root      18851  0.0  0.1  92796  6836 ?        Ss   Apr06   0:00 sshd: ubuntu [priv]\n    ubuntu    18878  0.0  0.0  92796  3988 ?        S    Apr06   0:02 sshd: ubuntu@pts/0\n    ubuntu    23726  0.0  0.0  14220  1028 pts/0    S+   21:08   0:00 grep --color=auto ssh\n    ```\n\n- 常用选项\n  - `i`：忽略大小写进行匹配。\n  - `v`：反向查找，只打印不匹配的行。\n  - `n`：显示匹配行的行号。\n  - `r`：递归查找子目录中的文件。\n  - `l`：只打印匹配的文件名。\n  - `c`：只打印匹配的行数。\n\n### grep结合正则表达式用法\n\n- 已有文本文件`example.txt`，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：\n\n    ```bash\n    John Smith, 25, Engineer\n    Alice Brown, 30, Teacher\n    Bob Johnson, 40, Lawyer\n    ```\n\n    查找年龄在 30 岁及以上的人的信息，可以使用以下命令：\n\n    ```bash\n    grep '[3-9][0-9],.*' example.txt\n    ```\n\n- 找出`~`目录下以`.sh`结尾的文件名\n\n    ```bash\n    find ~ -name \"*.sh\" |grep -Eo \"[^/]+\\.sh\"\n    ```\n\n练习4：显示/etc/passwd中不以`/bin/bash`结尾的行\n\n练习1答案：`\\+\\d{3}-\\d{3}-\\d{3}-\\d{5}`\n\n练习2答案：`0\\d{3}-\\d{7}|0\\d{2}-\\d{8}`\n\n练习3答案：`\\(?0\\d{2}[)-]?\\d{8}`\n\n练习4答案：`cat /etc/passwd |grep -Ev \"(/bin/bash)$”`\n","slug":"linux_shell/8.正则表达式","published":1,"updated":"2023-06-16T15:19:35.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04o000f1dnzcicz5mjd","content":"<p>正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。</p>\n<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，<strong>正则表达式就是记录文本规则的代码</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note8.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2023-06-16-21-24-50.png\" alt=\"8.正则表达式-2023-06-16-21-24-50\"></p>\n<p>如果你想查找某个目录下的所有的Word文档的话，你会搜索<code>*.doc</code>。在这里，<code>*</code>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号”-“，最后是7或8位数字的字符串(像<em>010-12345678</em>或<em>0376-7654321</em>)。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>正则表达式练习平台：<a href=\"https://tool.oschina.net/regex/\">https://tool.oschina.net/regex/</a></p>\n<p>最简单的正则表达式举例： <code>hi</code> ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是<code>h</code>,后一个是<code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<code>hi,HI,Hi,hI</code>这四种情况中的任意一种。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hi,Hi\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">\"hi\"</span>\nhi,Hi\nubuntu@sh:~$\nubuntu@sh:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hi,Hi,HI,hI\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">\"hi\"</span>\nhi,Hi,HI,hI<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>当目标文本中包含很多字符，比如<code>him,history,high</code>等等。用hi来查找的话，这里边的<code>hi</code>也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\\bhi\\b</code>。\\b是正则表达式规定的一个特殊代码（元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。</p>\n<p>假如要找的是<code>hi</code>后面不远处跟着一个<code>Lucy</code>，应该用<code>\\bhi\\b.*\\bLucy\\b</code>。</p>\n<p>这里，<code>.</code>是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，<code>.</code>连在一起就意味着任意数量的不包含换行的字符。现在<code>\\bhi\\b.*\\bLucy\\b</code>的意思就很明显：先是一个单词<code>hi</code>,然后是任意个任意字符(但不能是换行)，最后是<code>Lucy</code>这个单词。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hi,Hi,HI,hI,Lucy\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\b\">\\b</span>hi<span class=\"token entity\" title=\"\\b\">\\b</span>.*<span class=\"token entity\" title=\"\\b\">\\b</span>Lucy<span class=\"token entity\" title=\"\\b\">\\b</span>\"</span>\nhi,Hi,HI,hI,Lucy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><code>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的<code>\\d</code>是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。</p>\n<p>也可以这样写这个表达式：<code>0\\d&#123;2&#125;-\\d&#123;8&#125;</code>。这里<code>\\d</code>后面的<code>&#123;2&#125;(&#123;8&#125;)</code>的意思是前面<code>\\d</code>必须连续重复匹配<code>2次(8次)</code>。</p>\n<p>练习1：匹配国际格式的电话号码<code>+086-185-553-24528</code></p>\n<p>练习2：匹配国内电话号码<code>0511-4405222、021-87888822</code></p>\n<ul>\n<li>常用的元字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的结束</td>\n</tr>\n</tbody></table>\n<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和<code>\\b</code>有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\\d&#123;5,12&#125;$</code>。</p>\n<ul>\n<li>常用的限定符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>\\ba\\w*\\b</code>匹配以字母<code>a</code>开头的单词——先是某个单词开始处<code>(\\b)</code>，然后是字母<code>a</code>,然后是任意数量的字母或数字<code>(\\w*)</code>，最后是单词结束处<code>(\\b)</code>。</li>\n<li><code>\\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。</li>\n<li><code>\\b\\w&#123;6&#125;\\b</code> 匹配刚好6个字符的单词。</li>\n</ol>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果想查找元字符本身的话，比如查找<code>.</code>,或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用<code>\\</code>来取消这些字符的特殊意义。因此，应该使用<code>\\.</code>和<code>\\*</code>。当然，要查找<code>\\</code>本身，也得用<code>\\\\</code>.</p>\n<p>例如：<code>deerchao\\.cn</code>匹配<code>deerchao.cn</code>，<code>C:\\\\Windows</code>匹配<code>C:\\Windows</code>。</p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号(.或?或!)。</p>\n<p>练习3：匹配(010)88886666，或022-22334455，或02912345678。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>想要重复多个字符又该怎么办？可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后就可以指定这个子表达式的重复次数了。<code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;</code>是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：</p>\n<ol>\n<li><code>\\d&#123;1,3&#125;</code>匹配1到3位的数字</li>\n<li><code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;</code>匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次</li>\n<li>最后再加上一个一到三位的数字<code>(\\d&#123;1,3&#125;)</code>。</li>\n</ol>\n<p>它也将匹配*<code>256.300.888.999</code>*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code>。</p>\n<p>理解这个表达式的关键是理解<code>2[0-4]\\d|25[0-5]|[01]?\\d\\d?</code>。</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody></table>\n<p>例子：<code>\\S+</code>匹配不包含空白符的字符串。</p>\n<p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串。如果用它来搜索*<code>aabab</code>*的话，它会匹配整个字符串<code>aabab</code>。这被称为<strong>贪婪</strong>匹配。</p>\n<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>\n<p>举例：<code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于*<code>aabab</code>*的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep命令\"><a href=\"#grep命令\" class=\"headerlink\" title=\"grep命令\"></a>grep命令</h2><h3 id=\"grep基本用法\"><a href=\"#grep基本用法\" class=\"headerlink\" title=\"grep基本用法\"></a>grep基本用法</h3><p><code>Linux grep (global regular expression)</code> 命令用于查找文件里符合条件的字符串或正则表达式。</p>\n<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <code>-</code>，则 grep 指令会从标准输入设备读取数据。</p>\n<ul>\n<li><p>基于目标文件进行查找</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">grep</span> <span class=\"token string\">\"ubuntu\"</span> /etc/passwd\nubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>基于标准输入进行查找</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-aux</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token function\">ssh</span>\nroot        <span class=\"token number\">864</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.1</span>  <span class=\"token number\">65508</span>  <span class=\"token number\">5424</span> ?        Ss   Mar26   <span class=\"token number\">0</span>:00 /usr/sbin/sshd <span class=\"token parameter variable\">-D</span>\nroot      <span class=\"token number\">18851</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.1</span>  <span class=\"token number\">92796</span>  <span class=\"token number\">6836</span> ?        Ss   Apr06   <span class=\"token number\">0</span>:00 sshd: ubuntu <span class=\"token punctuation\">[</span>priv<span class=\"token punctuation\">]</span>\nubuntu    <span class=\"token number\">18878</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">92796</span>  <span class=\"token number\">3988</span> ?        S    Apr06   <span class=\"token number\">0</span>:02 sshd: ubuntu@pts/0\nubuntu    <span class=\"token number\">23726</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">14220</span>  <span class=\"token number\">1028</span> pts/0    S+   <span class=\"token number\">21</span>:08   <span class=\"token number\">0</span>:00 <span class=\"token function\">grep</span> <span class=\"token parameter variable\">--color</span><span class=\"token operator\">=</span>auto <span class=\"token function\">ssh</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>常用选项</p>\n<ul>\n<li><code>i</code>：忽略大小写进行匹配。</li>\n<li><code>v</code>：反向查找，只打印不匹配的行。</li>\n<li><code>n</code>：显示匹配行的行号。</li>\n<li><code>r</code>：递归查找子目录中的文件。</li>\n<li><code>l</code>：只打印匹配的文件名。</li>\n<li><code>c</code>：只打印匹配的行数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"grep结合正则表达式用法\"><a href=\"#grep结合正则表达式用法\" class=\"headerlink\" title=\"grep结合正则表达式用法\"></a>grep结合正则表达式用法</h3><ul>\n<li><p>已有文本文件<code>example.txt</code>，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">John Smith, <span class=\"token number\">25</span>, Engineer\nAlice Brown, <span class=\"token number\">30</span>, Teacher\nBob Johnson, <span class=\"token number\">40</span>, Lawyer<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>  查找年龄在 30 岁及以上的人的信息，可以使用以下命令：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">grep</span> <span class=\"token string\">'[3-9][0-9],.*'</span> example.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>找出<code>~</code>目录下以<code>.sh</code>结尾的文件名</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> ~ <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.sh\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-Eo</span> <span class=\"token string\">\"[^/]+\\.sh\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p>练习4：显示&#x2F;etc&#x2F;passwd中不以<code>/bin/bash</code>结尾的行</p>\n<p>练习1答案：<code>\\+\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;5&#125;</code></p>\n<p>练习2答案：<code>0\\d&#123;3&#125;-\\d&#123;7&#125;|0\\d&#123;2&#125;-\\d&#123;8&#125;</code></p>\n<p>练习3答案：<code>\\(?0\\d&#123;2&#125;[)-]?\\d&#123;8&#125;</code></p>\n<p>练习4答案：<code>cat /etc/passwd |grep -Ev &quot;(/bin/bash)$”</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>正则表达式定义：由一系列特定字符组成的字符串，用来匹配目标文本中符合指定条件的字符或者字符串。</p>\n<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，<strong>正则表达式就是记录文本规则的代码</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note8.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-2023-06-16-21-24-50.png\" alt=\"8.正则表达式-2023-06-16-21-24-50\"></p>\n<p>如果你想查找某个目录下的所有的Word文档的话，你会搜索<code>*.doc</code>。在这里，<code>*</code>会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号”-“，最后是7或8位数字的字符串(像<em>010-12345678</em>或<em>0376-7654321</em>)。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>正则表达式练习平台：<a href=\"https://tool.oschina.net/regex/\">https://tool.oschina.net/regex/</a></p>\n<p>最简单的正则表达式举例： <code>hi</code> ，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是<code>h</code>,后一个是<code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配<code>hi,HI,Hi,hI</code>这四种情况中的任意一种。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hi,Hi\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">\"hi\"</span>\nhi,Hi\nubuntu@sh:~$\nubuntu@sh:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hi,Hi,HI,hI\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-i</span> <span class=\"token string\">\"hi\"</span>\nhi,Hi,HI,hI<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><p>当目标文本中包含很多字符，比如<code>him,history,high</code>等等。用hi来查找的话，这里边的<code>hi</code>也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用<code>\\bhi\\b</code>。\\b是正则表达式规定的一个特殊代码（元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。</p>\n<p>假如要找的是<code>hi</code>后面不远处跟着一个<code>Lucy</code>，应该用<code>\\bhi\\b.*\\bLucy\\b</code>。</p>\n<p>这里，<code>.</code>是另一个元字符，匹配除了换行符以外的任意字符。<em>同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，<code>.</code>连在一起就意味着任意数量的不包含换行的字符。现在<code>\\bhi\\b.*\\bLucy\\b</code>的意思就很明显：先是一个单词<code>hi</code>,然后是任意个任意字符(但不能是换行)，最后是<code>Lucy</code>这个单词。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"hi,Hi,HI,hI,Lucy\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-o</span> <span class=\"token string\">\"<span class=\"token entity\" title=\"\\b\">\\b</span>hi<span class=\"token entity\" title=\"\\b\">\\b</span>.*<span class=\"token entity\" title=\"\\b\">\\b</span>Lucy<span class=\"token entity\" title=\"\\b\">\\b</span>\"</span>\nhi,Hi,HI,hI,Lucy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><code>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code>匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码)。这里的<code>\\d</code>是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符。</p>\n<p>也可以这样写这个表达式：<code>0\\d&#123;2&#125;-\\d&#123;8&#125;</code>。这里<code>\\d</code>后面的<code>&#123;2&#125;(&#123;8&#125;)</code>的意思是前面<code>\\d</code>必须连续重复匹配<code>2次(8次)</code>。</p>\n<p>练习1：匹配国际格式的电话号码<code>+086-185-553-24528</code></p>\n<p>练习2：匹配国内电话号码<code>0511-4405222、021-87888822</code></p>\n<ul>\n<li>常用的元字符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.</td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意的空白符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开始或结束</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配字符串的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配字符串的结束</td>\n</tr>\n</tbody></table>\n<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和<code>\\b</code>有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\\d&#123;5,12&#125;$</code>。</p>\n<ul>\n<li>常用的限定符</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*</td>\n<td>重复零次或更多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>重复一次或更多次</td>\n</tr>\n<tr>\n<td>?</td>\n<td>重复零次或一次</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>重复n次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>重复n次或更多次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>重复n到m次</td>\n</tr>\n</tbody></table>\n<ol>\n<li><code>\\ba\\w*\\b</code>匹配以字母<code>a</code>开头的单词——先是某个单词开始处<code>(\\b)</code>，然后是字母<code>a</code>,然后是任意数量的字母或数字<code>(\\w*)</code>，最后是单词结束处<code>(\\b)</code>。</li>\n<li><code>\\d+</code>匹配1个或更多连续的数字。这里的<code>+</code>是和<em>类似的元字符，不同的是</em>匹配重复任意次(可能是0次)，而<code>+</code>则匹配重复1次或更多次。</li>\n<li><code>\\b\\w&#123;6&#125;\\b</code> 匹配刚好6个字符的单词。</li>\n</ol>\n<h2 id=\"字符转义\"><a href=\"#字符转义\" class=\"headerlink\" title=\"字符转义\"></a>字符转义</h2><p>如果想查找元字符本身的话，比如查找<code>.</code>,或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时就得使用<code>\\</code>来取消这些字符的特殊意义。因此，应该使用<code>\\.</code>和<code>\\*</code>。当然，要查找<code>\\</code>本身，也得用<code>\\\\</code>.</p>\n<p>例如：<code>deerchao\\.cn</code>匹配<code>deerchao.cn</code>，<code>C:\\\\Windows</code>匹配<code>C:\\Windows</code>。</p>\n<h2 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果想匹配没有预定义元字符的字符集合，需要在方括号中列出他们：<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号(.或?或!)。</p>\n<p>练习3：匹配(010)88886666，或022-22334455，或02912345678。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>想要重复多个字符又该怎么办？可以用小括号来指定<strong>子表达式</strong>(也叫做<strong>分组</strong>)，然后就可以指定这个子表达式的重复次数了。<code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;</code>是一个简单的IP地址匹配表达式。要理解这个表达式，按下列顺序分析它：</p>\n<ol>\n<li><code>\\d&#123;1,3&#125;</code>匹配1到3位的数字</li>\n<li><code>(\\d&#123;1,3&#125;\\.)&#123;3&#125;</code>匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次</li>\n<li>最后再加上一个一到三位的数字<code>(\\d&#123;1,3&#125;)</code>。</li>\n</ol>\n<p>它也将匹配*<code>256.300.888.999</code>*这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code>。</p>\n<p>理解这个表达式的关键是理解<code>2[0-4]\\d|25[0-5]|[01]?\\d\\d?</code>。</p>\n<h2 id=\"反义\"><a href=\"#反义\" class=\"headerlink\" title=\"反义\"></a>反义</h2><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[^aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody></table>\n<p>例子：<code>\\S+</code>匹配不包含空白符的字符串。</p>\n<p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以a开头的字符串。</p>\n<h2 id=\"贪婪与懒惰\"><a href=\"#贪婪与懒惰\" class=\"headerlink\" title=\"贪婪与懒惰\"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以<code>a</code>开始，以<code>b</code>结束的字符串。如果用它来搜索*<code>aabab</code>*的话，它会匹配整个字符串<code>aabab</code>。这被称为<strong>贪婪</strong>匹配。</p>\n<p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>\n<p>举例：<code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于*<code>aabab</code>*的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p>\n<table>\n<thead>\n<tr>\n<th>代码&#x2F;语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep命令\"><a href=\"#grep命令\" class=\"headerlink\" title=\"grep命令\"></a>grep命令</h2><h3 id=\"grep基本用法\"><a href=\"#grep基本用法\" class=\"headerlink\" title=\"grep基本用法\"></a>grep基本用法</h3><p><code>Linux grep (global regular expression)</code> 命令用于查找文件里符合条件的字符串或正则表达式。</p>\n<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <code>-</code>，则 grep 指令会从标准输入设备读取数据。</p>\n<ul>\n<li><p>基于目标文件进行查找</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">grep</span> <span class=\"token string\">\"ubuntu\"</span> /etc/passwd\nubuntu:x:1000:1000:ubuntu,,,:/home/ubuntu:/bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>基于标准输入进行查找</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ubuntu@sh:~$ <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-aux</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token function\">ssh</span>\nroot        <span class=\"token number\">864</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.1</span>  <span class=\"token number\">65508</span>  <span class=\"token number\">5424</span> ?        Ss   Mar26   <span class=\"token number\">0</span>:00 /usr/sbin/sshd <span class=\"token parameter variable\">-D</span>\nroot      <span class=\"token number\">18851</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.1</span>  <span class=\"token number\">92796</span>  <span class=\"token number\">6836</span> ?        Ss   Apr06   <span class=\"token number\">0</span>:00 sshd: ubuntu <span class=\"token punctuation\">[</span>priv<span class=\"token punctuation\">]</span>\nubuntu    <span class=\"token number\">18878</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">92796</span>  <span class=\"token number\">3988</span> ?        S    Apr06   <span class=\"token number\">0</span>:02 sshd: ubuntu@pts/0\nubuntu    <span class=\"token number\">23726</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>  <span class=\"token number\">14220</span>  <span class=\"token number\">1028</span> pts/0    S+   <span class=\"token number\">21</span>:08   <span class=\"token number\">0</span>:00 <span class=\"token function\">grep</span> <span class=\"token parameter variable\">--color</span><span class=\"token operator\">=</span>auto <span class=\"token function\">ssh</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>常用选项</p>\n<ul>\n<li><code>i</code>：忽略大小写进行匹配。</li>\n<li><code>v</code>：反向查找，只打印不匹配的行。</li>\n<li><code>n</code>：显示匹配行的行号。</li>\n<li><code>r</code>：递归查找子目录中的文件。</li>\n<li><code>l</code>：只打印匹配的文件名。</li>\n<li><code>c</code>：只打印匹配的行数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"grep结合正则表达式用法\"><a href=\"#grep结合正则表达式用法\" class=\"headerlink\" title=\"grep结合正则表达式用法\"></a>grep结合正则表达式用法</h3><ul>\n<li><p>已有文本文件<code>example.txt</code>，其中存储了一些人的信息，包括姓名、年龄和职业，每行一个人的信息：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">John Smith, <span class=\"token number\">25</span>, Engineer\nAlice Brown, <span class=\"token number\">30</span>, Teacher\nBob Johnson, <span class=\"token number\">40</span>, Lawyer<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>  查找年龄在 30 岁及以上的人的信息，可以使用以下命令：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">grep</span> <span class=\"token string\">'[3-9][0-9],.*'</span> example.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>找出<code>~</code>目录下以<code>.sh</code>结尾的文件名</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> ~ <span class=\"token parameter variable\">-name</span> <span class=\"token string\">\"*.sh\"</span> <span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-Eo</span> <span class=\"token string\">\"[^/]+\\.sh\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<p>练习4：显示&#x2F;etc&#x2F;passwd中不以<code>/bin/bash</code>结尾的行</p>\n<p>练习1答案：<code>\\+\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;3&#125;-\\d&#123;5&#125;</code></p>\n<p>练习2答案：<code>0\\d&#123;3&#125;-\\d&#123;7&#125;|0\\d&#123;2&#125;-\\d&#123;8&#125;</code></p>\n<p>练习3答案：<code>\\(?0\\d&#123;2&#125;[)-]?\\d&#123;8&#125;</code></p>\n<p>练习4答案：<code>cat /etc/passwd |grep -Ev &quot;(/bin/bash)$”</code></p>\n"},{"title":"流编辑器sed","date":"2023-04-18T03:31:23.000Z","_content":"\n## sed编辑器定义\n\n用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。\n\n## sed编辑器特点\n\n与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。\n\n## sed编辑器的工作流程\n\n1. 一次从输入中读取一行数据\n2. 根据所提供的编辑器命令匹配数据\n3. 按照命令修改流中的数据\n4. 将新的数据输出到STDOUT\n\n在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。\n\n## sed编辑器基础\n\n### sed命令格式\n\n```bash\nsed options 'command' inputfile\n```\n\n其中，`options`是可选项，`command`是sed命令，`inputfile`是要处理的文件名。如果不指定`inputfile`，sed将从标准输入读取数据。\n\n### 基本用法\n\n```bash\nsed 's/oldstring/newstring/' inputfile\n```\n\n其中，`s`表示替换操作，`oldstring`表示要被替换的字符串，`newstring`表示替换后的字符串，`inputfile`表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用`g`选项，如下所示：\n\n```bash\nsed 's/oldstring/newstring/g' inputfile\n```\n\n除了`s`命令，sed还有其他命令，如`p`命令（打印指定的行）、`d`命令（删除指定的行）、`a`命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。\n\n- 双引号和单引号的区别\n\n    在使用 `sed` 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 `$` 和```之外，其他的特殊字符都会被视为普通字符。\n\n    具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 `sed` 命令。\n\n    ```bash\n    name=\"universe\"\n    sed \"s/world/$name/\" test.txt\n    ```\n\n- 常见选项\n  - `n`：取消默认输出，使用print命令完成输出。\n  - `e`：允许多个 sed 命令被执行。\n\n    ```bash\n    sed -e 's/apple/orange/g' -e 's/\\s*$//' file.txt\n    ```\n\n  - `f`：指定 sed 命令文件。\n\n    ```bash\n    sed -f commands.sed file.txt\n    ```\n\n    commands.sed文件内容：\n\n    ```text\n    s/Hello/Hi/\n    s/World/There/\n    ```\n\n  - `i`：直接修改文件，而不是输出到终端。\n  - `r` 或 `E`：使用扩展正则表达式。\n- 常见命令\n  - `s`：替换字符\n\n    ```bash\n    # 将文件中的 apple 替换为 banana\n    sed 's/apple/banana/g' file.txt\n    \n    # 将每行的第一个 apple 替换为 banana\n    sed 's/apple/banana/' file.txt\n    ```\n\n  - `d`：删除命令，用于删除文件中的指定行或指定模式。\n\n    ```bash\n    # 删除匹配模式的行\n    sed '/pattern/d' file.txt\n    \n    # 删除 :10 到 20 行\n    sed '10,20d' file.txt\n    \n    # 删除空行\n    sed '/^$/d' file.txt\n    ```\n\n  - `a`：添加命令，用于在文件中的指定行后面添加新的内容。\n\n    ```bash\n    # 在匹配模式所在行的下一行添加新的内容\n    sed '/pattern/a new line' file.txt\n    \n    # 在指定行号的下一行添加新的内容\n    sed '3a new line' file.txt\n    ```\n\n  - `i`：插入命令，用于在文件中的指定行前面插入新的内容。\n\n    ```bash\n    # 在匹配模式所在行的上一行插入新的内容\n    sed '/pattern/i new line' file.txt\n    \n    # 在指定行号的上一行插入新的内容\n    sed '3i new line' file.txt\n    \n    # 在文件中插入新的文本行：\n    sed '1i\\New Text' filename\n    ```\n\n  - `c`：替换命令，用于将指定行替换为新的内容。\n\n    ```bash\n    # 将匹配模式所在行替换为新的内容\n    sed '/pattern/c new line' file.txt\n    \n    # 将指定行号替换为新的内容\n    sed '3c new line' file.txt\n    ```\n\n## sed正则表达式用法\n\n1. 删除文件中的空行：\n\n    ```bash\n    sed '/^$/d' filename\n    ```\n\n    使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 `d` 命令删除这些行。\n\n2. 删除文件中的注释行：\n\n    ```bash\n    sed '/^#/d' filename\n    ```\n\n    使用正则表达式匹配以 `#`开头的行，然后使用 `d`命令删除这些行。\n\n3. 按照指定格式输出文件内容：\n\n    ```bash\n    sed 's/\\(.*\\)/<p>\\1<\\/p>/' filename\n    ```\n\n4. 指定行前添加#号：\n\n    ```bash\n    sed -r '1,5s/(.*)/#\\1/' filename\n    ```\n\n5. 将文本文件中的每一行都替换为该行的第一个单词：\n\n    ```bash\n    sed 's/\\([a-zA-Z]*\\).*/\\1/' test.txt\n    ```\n\n6. 提取文本文件中的URL：\n\n    ```bash\n    sed -nE 's#.*(https?://[^ ]*).*#\\1#p' test.txt\n    ```\n\n## vim中的sed用法\n\n1. 替换文件中的指定字符串\n\n    在Vim中，可以使用“:%s/old/new/g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“/”用于分隔替换前、替换后的内容，“g”表示全局替换。\n\n2. 删除文件中的指定行\n\n    在Vim中，可以使用“:g/pattern/d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。\n\n3. 在文件中插入指定字符串\n\n    在Vim中，可以使用“:1,$s/^/string/”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。\n","source":"_posts/linux_shell/9.流编辑器sed.md","raw":"---\ntitle: 流编辑器sed\ndate: 2023-04-18 11:31:23\ntags:\n---\n\n## sed编辑器定义\n\n用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。\n\n## sed编辑器特点\n\n与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。\n\n## sed编辑器的工作流程\n\n1. 一次从输入中读取一行数据\n2. 根据所提供的编辑器命令匹配数据\n3. 按照命令修改流中的数据\n4. 将新的数据输出到STDOUT\n\n在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。\n\n## sed编辑器基础\n\n### sed命令格式\n\n```bash\nsed options 'command' inputfile\n```\n\n其中，`options`是可选项，`command`是sed命令，`inputfile`是要处理的文件名。如果不指定`inputfile`，sed将从标准输入读取数据。\n\n### 基本用法\n\n```bash\nsed 's/oldstring/newstring/' inputfile\n```\n\n其中，`s`表示替换操作，`oldstring`表示要被替换的字符串，`newstring`表示替换后的字符串，`inputfile`表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用`g`选项，如下所示：\n\n```bash\nsed 's/oldstring/newstring/g' inputfile\n```\n\n除了`s`命令，sed还有其他命令，如`p`命令（打印指定的行）、`d`命令（删除指定的行）、`a`命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。\n\n- 双引号和单引号的区别\n\n    在使用 `sed` 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 `$` 和```之外，其他的特殊字符都会被视为普通字符。\n\n    具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 `sed` 命令。\n\n    ```bash\n    name=\"universe\"\n    sed \"s/world/$name/\" test.txt\n    ```\n\n- 常见选项\n  - `n`：取消默认输出，使用print命令完成输出。\n  - `e`：允许多个 sed 命令被执行。\n\n    ```bash\n    sed -e 's/apple/orange/g' -e 's/\\s*$//' file.txt\n    ```\n\n  - `f`：指定 sed 命令文件。\n\n    ```bash\n    sed -f commands.sed file.txt\n    ```\n\n    commands.sed文件内容：\n\n    ```text\n    s/Hello/Hi/\n    s/World/There/\n    ```\n\n  - `i`：直接修改文件，而不是输出到终端。\n  - `r` 或 `E`：使用扩展正则表达式。\n- 常见命令\n  - `s`：替换字符\n\n    ```bash\n    # 将文件中的 apple 替换为 banana\n    sed 's/apple/banana/g' file.txt\n    \n    # 将每行的第一个 apple 替换为 banana\n    sed 's/apple/banana/' file.txt\n    ```\n\n  - `d`：删除命令，用于删除文件中的指定行或指定模式。\n\n    ```bash\n    # 删除匹配模式的行\n    sed '/pattern/d' file.txt\n    \n    # 删除 :10 到 20 行\n    sed '10,20d' file.txt\n    \n    # 删除空行\n    sed '/^$/d' file.txt\n    ```\n\n  - `a`：添加命令，用于在文件中的指定行后面添加新的内容。\n\n    ```bash\n    # 在匹配模式所在行的下一行添加新的内容\n    sed '/pattern/a new line' file.txt\n    \n    # 在指定行号的下一行添加新的内容\n    sed '3a new line' file.txt\n    ```\n\n  - `i`：插入命令，用于在文件中的指定行前面插入新的内容。\n\n    ```bash\n    # 在匹配模式所在行的上一行插入新的内容\n    sed '/pattern/i new line' file.txt\n    \n    # 在指定行号的上一行插入新的内容\n    sed '3i new line' file.txt\n    \n    # 在文件中插入新的文本行：\n    sed '1i\\New Text' filename\n    ```\n\n  - `c`：替换命令，用于将指定行替换为新的内容。\n\n    ```bash\n    # 将匹配模式所在行替换为新的内容\n    sed '/pattern/c new line' file.txt\n    \n    # 将指定行号替换为新的内容\n    sed '3c new line' file.txt\n    ```\n\n## sed正则表达式用法\n\n1. 删除文件中的空行：\n\n    ```bash\n    sed '/^$/d' filename\n    ```\n\n    使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 `d` 命令删除这些行。\n\n2. 删除文件中的注释行：\n\n    ```bash\n    sed '/^#/d' filename\n    ```\n\n    使用正则表达式匹配以 `#`开头的行，然后使用 `d`命令删除这些行。\n\n3. 按照指定格式输出文件内容：\n\n    ```bash\n    sed 's/\\(.*\\)/<p>\\1<\\/p>/' filename\n    ```\n\n4. 指定行前添加#号：\n\n    ```bash\n    sed -r '1,5s/(.*)/#\\1/' filename\n    ```\n\n5. 将文本文件中的每一行都替换为该行的第一个单词：\n\n    ```bash\n    sed 's/\\([a-zA-Z]*\\).*/\\1/' test.txt\n    ```\n\n6. 提取文本文件中的URL：\n\n    ```bash\n    sed -nE 's#.*(https?://[^ ]*).*#\\1#p' test.txt\n    ```\n\n## vim中的sed用法\n\n1. 替换文件中的指定字符串\n\n    在Vim中，可以使用“:%s/old/new/g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“/”用于分隔替换前、替换后的内容，“g”表示全局替换。\n\n2. 删除文件中的指定行\n\n    在Vim中，可以使用“:g/pattern/d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。\n\n3. 在文件中插入指定字符串\n\n    在Vim中，可以使用“:1,$s/^/string/”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。\n","slug":"linux_shell/9.流编辑器sed","published":1,"updated":"2023-06-16T13:28:48.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04o000g1dnzc4xsg646","content":"<h2 id=\"sed编辑器定义\"><a href=\"#sed编辑器定义\" class=\"headerlink\" title=\"sed编辑器定义\"></a>sed编辑器定义</h2><p>用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。</p>\n<h2 id=\"sed编辑器特点\"><a href=\"#sed编辑器特点\" class=\"headerlink\" title=\"sed编辑器特点\"></a>sed编辑器特点</h2><p>与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。</p>\n<h2 id=\"sed编辑器的工作流程\"><a href=\"#sed编辑器的工作流程\" class=\"headerlink\" title=\"sed编辑器的工作流程\"></a>sed编辑器的工作流程</h2><ol>\n<li>一次从输入中读取一行数据</li>\n<li>根据所提供的编辑器命令匹配数据</li>\n<li>按照命令修改流中的数据</li>\n<li>将新的数据输出到STDOUT</li>\n</ol>\n<p>在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。</p>\n<h2 id=\"sed编辑器基础\"><a href=\"#sed编辑器基础\" class=\"headerlink\" title=\"sed编辑器基础\"></a>sed编辑器基础</h2><h3 id=\"sed命令格式\"><a href=\"#sed命令格式\" class=\"headerlink\" title=\"sed命令格式\"></a>sed命令格式</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> options <span class=\"token string\">'command'</span> inputfile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>其中，<code>options</code>是可选项，<code>command</code>是sed命令，<code>inputfile</code>是要处理的文件名。如果不指定<code>inputfile</code>，sed将从标准输入读取数据。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/oldstring/newstring/'</span> inputfile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>其中，<code>s</code>表示替换操作，<code>oldstring</code>表示要被替换的字符串，<code>newstring</code>表示替换后的字符串，<code>inputfile</code>表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用<code>g</code>选项，如下所示：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/oldstring/newstring/g'</span> inputfile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>除了<code>s</code>命令，sed还有其他命令，如<code>p</code>命令（打印指定的行）、<code>d</code>命令（删除指定的行）、<code>a</code>命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。</p>\n<ul>\n<li><p>双引号和单引号的区别</p>\n<p>  在使用 <code>sed</code> 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 <code>$</code> 和&#96;&#96;&#96;之外，其他的特殊字符都会被视为普通字符。</p>\n<p>  具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 <code>sed</code> 命令。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"universe\"</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">\"s/world/<span class=\"token variable\">$name</span>/\"</span> test.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>常见选项</p>\n<ul>\n<li><p><code>n</code>：取消默认输出，使用print命令完成输出。</p>\n</li>\n<li><p><code>e</code>：允许多个 sed 命令被执行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">'s/apple/orange/g'</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">'s/\\s*$//'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><code>f</code>：指定 sed 命令文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-f</span> commands.sed file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>commands.sed文件内容：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">s/Hello/Hi/\ns/World/There/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>i</code>：直接修改文件，而不是输出到终端。</p>\n</li>\n<li><p><code>r</code> 或 <code>E</code>：使用扩展正则表达式。</p>\n</li>\n</ul>\n</li>\n<li><p>常见命令</p>\n<ul>\n<li><p><code>s</code>：替换字符</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 将文件中的 apple 替换为 banana</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/apple/banana/g'</span> file.txt\n\n<span class=\"token comment\"># 将每行的第一个 apple 替换为 banana</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/apple/banana/'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>d</code>：删除命令，用于删除文件中的指定行或指定模式。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 删除匹配模式的行</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/d'</span> file.txt\n\n<span class=\"token comment\"># 删除 :10 到 20 行</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'10,20d'</span> file.txt\n\n<span class=\"token comment\"># 删除空行</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/^$/d'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>a</code>：添加命令，用于在文件中的指定行后面添加新的内容。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在匹配模式所在行的下一行添加新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/a new line'</span> file.txt\n\n<span class=\"token comment\"># 在指定行号的下一行添加新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'3a new line'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>i</code>：插入命令，用于在文件中的指定行前面插入新的内容。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在匹配模式所在行的上一行插入新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/i new line'</span> file.txt\n\n<span class=\"token comment\"># 在指定行号的上一行插入新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'3i new line'</span> file.txt\n\n<span class=\"token comment\"># 在文件中插入新的文本行：</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'1i\\New Text'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>c</code>：替换命令，用于将指定行替换为新的内容。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 将匹配模式所在行替换为新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/c new line'</span> file.txt\n\n<span class=\"token comment\"># 将指定行号替换为新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'3c new line'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"sed正则表达式用法\"><a href=\"#sed正则表达式用法\" class=\"headerlink\" title=\"sed正则表达式用法\"></a>sed正则表达式用法</h2><ol>\n<li><p>删除文件中的空行：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'/^$/d'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 <code>d</code> 命令删除这些行。</p>\n</li>\n<li><p>删除文件中的注释行：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'/^#/d'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 使用正则表达式匹配以 <code>#</code>开头的行，然后使用 <code>d</code>命令删除这些行。</p>\n</li>\n<li><p>按照指定格式输出文件内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/\\(.*\\)/&lt;p>\\1&lt;\\/p>/'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>指定行前添加#号：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'1,5s/(.*)/#\\1/'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>将文本文件中的每一行都替换为该行的第一个单词：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/\\([a-zA-Z]*\\).*/\\1/'</span> test.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>提取文本文件中的URL：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-nE</span> <span class=\"token string\">'s#.*(https?://[^ ]*).*#\\1#p'</span> test.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"vim中的sed用法\"><a href=\"#vim中的sed用法\" class=\"headerlink\" title=\"vim中的sed用法\"></a>vim中的sed用法</h2><ol>\n<li><p>替换文件中的指定字符串</p>\n<p> 在Vim中，可以使用“:%s&#x2F;old&#x2F;new&#x2F;g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“&#x2F;”用于分隔替换前、替换后的内容，“g”表示全局替换。</p>\n</li>\n<li><p>删除文件中的指定行</p>\n<p> 在Vim中，可以使用“:g&#x2F;pattern&#x2F;d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。</p>\n</li>\n<li><p>在文件中插入指定字符串</p>\n<p> 在Vim中，可以使用“:1,$s&#x2F;^&#x2F;string&#x2F;”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sed编辑器定义\"><a href=\"#sed编辑器定义\" class=\"headerlink\" title=\"sed编辑器定义\"></a>sed编辑器定义</h2><p>用于处理文本文件中的数据流。它是一种非交互式的编辑器，可以从标准输入（stdin）或文件中读取输入，然后将文本进行转换、替换、删除、添加等操作，最后将处理后的文本输出到标准输出（stdout）或文件中。它的名字来源于“流编辑器（stream editor）”。</p>\n<h2 id=\"sed编辑器特点\"><a href=\"#sed编辑器特点\" class=\"headerlink\" title=\"sed编辑器特点\"></a>sed编辑器特点</h2><p>与传统的文本编辑器（如vi和emacs）不同，sed对文件进行的修改是非常快速和高效的，因为它不需要打开文件并读取整个文件内容，而是按行处理文件，只处理必要的部分。此外，sed支持正则表达式，可以在文本文件中进行高级搜索和替换操作。</p>\n<h2 id=\"sed编辑器的工作流程\"><a href=\"#sed编辑器的工作流程\" class=\"headerlink\" title=\"sed编辑器的工作流程\"></a>sed编辑器的工作流程</h2><ol>\n<li>一次从输入中读取一行数据</li>\n<li>根据所提供的编辑器命令匹配数据</li>\n<li>按照命令修改流中的数据</li>\n<li>将新的数据输出到STDOUT</li>\n</ol>\n<p>在执行过程中，sed编辑器使用的是基于行的处理方式，即每次处理一行数据。而指令则是根据正则表达式来匹配和处理数据的。通过指令的组合使用，可以实现很多文本处理和编辑的功能，比如替换、删除、插入等操作。</p>\n<h2 id=\"sed编辑器基础\"><a href=\"#sed编辑器基础\" class=\"headerlink\" title=\"sed编辑器基础\"></a>sed编辑器基础</h2><h3 id=\"sed命令格式\"><a href=\"#sed命令格式\" class=\"headerlink\" title=\"sed命令格式\"></a>sed命令格式</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> options <span class=\"token string\">'command'</span> inputfile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>其中，<code>options</code>是可选项，<code>command</code>是sed命令，<code>inputfile</code>是要处理的文件名。如果不指定<code>inputfile</code>，sed将从标准输入读取数据。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/oldstring/newstring/'</span> inputfile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>其中，<code>s</code>表示替换操作，<code>oldstring</code>表示要被替换的字符串，<code>newstring</code>表示替换后的字符串，<code>inputfile</code>表示要处理的文件名。此命令将替换文件中的第一个匹配项。如果要替换所有匹配项，则需要使用<code>g</code>选项，如下所示：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/oldstring/newstring/g'</span> inputfile<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>除了<code>s</code>命令，sed还有其他命令，如<code>p</code>命令（打印指定的行）、<code>d</code>命令（删除指定的行）、<code>a</code>命令（在指定行后添加一行文本）等。这些命令可以组合使用，构成一个完整的sed脚本，用于对文本进行复杂的处理。</p>\n<ul>\n<li><p>双引号和单引号的区别</p>\n<p>  在使用 <code>sed</code> 命令时，单引号和双引号的使用是有区别的。在单引号中，所有的特殊字符都会被视为普通字符，而在双引号中，除了 <code>$</code> 和&#96;&#96;&#96;之外，其他的特殊字符都会被视为普通字符。</p>\n<p>  具体来说，在单引号中，变量和命令替换不会被执行，而在双引号中，会先进行变量和命令替换，然后再执行 <code>sed</code> 命令。</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">name</span><span class=\"token operator\">=</span><span class=\"token string\">\"universe\"</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">\"s/world/<span class=\"token variable\">$name</span>/\"</span> test.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>常见选项</p>\n<ul>\n<li><p><code>n</code>：取消默认输出，使用print命令完成输出。</p>\n</li>\n<li><p><code>e</code>：允许多个 sed 命令被执行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">'s/apple/orange/g'</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">'s/\\s*$//'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><code>f</code>：指定 sed 命令文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-f</span> commands.sed file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>commands.sed文件内容：</p>\n<pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">s/Hello/Hi/\ns/World/There/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>i</code>：直接修改文件，而不是输出到终端。</p>\n</li>\n<li><p><code>r</code> 或 <code>E</code>：使用扩展正则表达式。</p>\n</li>\n</ul>\n</li>\n<li><p>常见命令</p>\n<ul>\n<li><p><code>s</code>：替换字符</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 将文件中的 apple 替换为 banana</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/apple/banana/g'</span> file.txt\n\n<span class=\"token comment\"># 将每行的第一个 apple 替换为 banana</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/apple/banana/'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>d</code>：删除命令，用于删除文件中的指定行或指定模式。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 删除匹配模式的行</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/d'</span> file.txt\n\n<span class=\"token comment\"># 删除 :10 到 20 行</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'10,20d'</span> file.txt\n\n<span class=\"token comment\"># 删除空行</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/^$/d'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>a</code>：添加命令，用于在文件中的指定行后面添加新的内容。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在匹配模式所在行的下一行添加新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/a new line'</span> file.txt\n\n<span class=\"token comment\"># 在指定行号的下一行添加新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'3a new line'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>i</code>：插入命令，用于在文件中的指定行前面插入新的内容。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在匹配模式所在行的上一行插入新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/i new line'</span> file.txt\n\n<span class=\"token comment\"># 在指定行号的上一行插入新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'3i new line'</span> file.txt\n\n<span class=\"token comment\"># 在文件中插入新的文本行：</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'1i\\New Text'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>c</code>：替换命令，用于将指定行替换为新的内容。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 将匹配模式所在行替换为新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'/pattern/c new line'</span> file.txt\n\n<span class=\"token comment\"># 将指定行号替换为新的内容</span>\n<span class=\"token function\">sed</span> <span class=\"token string\">'3c new line'</span> file.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"sed正则表达式用法\"><a href=\"#sed正则表达式用法\" class=\"headerlink\" title=\"sed正则表达式用法\"></a>sed正则表达式用法</h2><ol>\n<li><p>删除文件中的空行：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'/^$/d'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 使用正则表达式匹配空行（以行首和行尾之间没有任何字符的行），然后使用 <code>d</code> 命令删除这些行。</p>\n</li>\n<li><p>删除文件中的注释行：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'/^#/d'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 使用正则表达式匹配以 <code>#</code>开头的行，然后使用 <code>d</code>命令删除这些行。</p>\n</li>\n<li><p>按照指定格式输出文件内容：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/\\(.*\\)/&lt;p>\\1&lt;\\/p>/'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>指定行前添加#号：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-r</span> <span class=\"token string\">'1,5s/(.*)/#\\1/'</span> filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>将文本文件中的每一行都替换为该行的第一个单词：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token string\">'s/\\([a-zA-Z]*\\).*/\\1/'</span> test.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>提取文本文件中的URL：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sed</span> <span class=\"token parameter variable\">-nE</span> <span class=\"token string\">'s#.*(https?://[^ ]*).*#\\1#p'</span> test.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"vim中的sed用法\"><a href=\"#vim中的sed用法\" class=\"headerlink\" title=\"vim中的sed用法\"></a>vim中的sed用法</h2><ol>\n<li><p>替换文件中的指定字符串</p>\n<p> 在Vim中，可以使用“:%s&#x2F;old&#x2F;new&#x2F;g”命令来替换文件中的指定字符串，其中“%”表示对整个文件进行操作，“s”表示替换，“&#x2F;”用于分隔替换前、替换后的内容，“g”表示全局替换。</p>\n</li>\n<li><p>删除文件中的指定行</p>\n<p> 在Vim中，可以使用“:g&#x2F;pattern&#x2F;d”命令来删除文件中包含指定字符串的行，其中“g”表示全局匹配，“pattern”表示要匹配的字符串，“d”表示删除操作。</p>\n</li>\n<li><p>在文件中插入指定字符串</p>\n<p> 在Vim中，可以使用“:1,$s&#x2F;^&#x2F;string&#x2F;”命令在文件的每一行前插入指定字符串，其中“1,$”表示对整个文件进行操作，“^”表示行首，“string”表示要插入的字符串。</p>\n</li>\n</ol>\n"},{"title":"初识云计算与OpenStack","date":"2023-06-27T14:11:49.000Z","_content":"\n\n## 传统的计算模式\n\n### 计算机系统结构\n\n![1.初识云计算与Openstack-2023-08-25-22-09-05](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-25-22-09-05.png)\n\n传统的计算模式是指企业或个人在自己的本地环境中构建、管理和维护硬件设备、操作系统和应用程序，以满足其计算和存储需求。\n\n>对于个人用户的场景：需要搭建服务或者使用Linux系统环境时，我们往往需要在本地计算机上搭建虚拟机或者单独购买一套硬件来实现。  \n>对于企业用户的场景：需要对内向员工提供项目管理等等办公服务、对外向用户提供web服务，数据库服务等等，同样需要在企业内部通过搭建数据中心来实现。\n\n* 需要购买和维护物理硬件设备，同时需要专业的IT团队来管理硬件和软件设施。（成本过高）\n* 资源利用率可能不高，硬件设备难以进行快速的资源分配和释放。（企业达到一定规模后难以适应多变的需求）\n* 扩展时需要购买更多硬件，时间和成本较高。（扩展性差）\n* 需要考虑容灾和高可用性，可能需要复杂的架构设计。（安全性需要得到保障）\n\n## 云计算的概念\n\n**云计算的定义：** 云计算是一种按使用量付费的模式，它可以实现随时随地，便捷地，随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。\n\n>和传统模式特点比较\n\n**资源池化：** 传统的虚拟化技术是将单个服务器硬件虚拟成多个虚拟机，其目的也是在于提高服务器资源的利用率。但是，由于单个服务器的CPU、内存、硬盘资源颗粒度较小，因此在虚拟化应用中，经常出现资源配置空洞，要么是CPU核数没有分配完，要么是内存没有分配完，更多的情况是硬盘容量存在大量空闲。而服务器资源池化可以更好的解决上述问题。\n\n![1.初识云计算与Openstack-2023-08-26-14-41-36](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-14-41-36.jpg)\n\n## 云计算的特点\n\n1. 资源池化：云计算中的资源（如计算能力、存储、网络等）被集中管理并池化，供多个用户共享。这种资源的共享和动态分配提高了资源的利用率。\n2. 按需分配： 用户可以根据自己的需求，自主地获取和配置计算资源，无需人工干预。这种自服务模式使用户能够快速获取所需资源，提高了效率。\n3. 快速弹性扩展： 用户可以根据需要快速扩展或缩减资源，以适应业务的变化。这种弹性特性允许用户在高峰时段获得更多资源，而在低谷时段释放资源。\n4. 可用性和容灾性：许多云服务提供商提供高可用性和容灾选项，确保服务在故障时能够持续运行，减少了业务中断的风险。\n\n>按需分配、按量付费，各种计费方式；可扩展一方面使得上云的应用能够根据不同时段的业务需求动态调整资源另一方面，企业可以在不停机的情况下增加任意资源；可用性使得服务器出现故障时会无缝切换到资源池上的其他资源，不管是计算资源还是存储设备都能保证24小时不间断提供服务。  \n>基于以上特点总结：用户不需要为应用单独购买服务器、同时不需要付出管理成本，只需要付出租用的成本就可以使用到随时能够扩容的并且有专业人员维护以保障安全的计算服务。\n\n## 云计算的分类\n\n### 按服务对象或者运营模式分类\n\n1. 公有云：“公有”反映了这类云服务并非用户所拥有，公有云是面向大众提供计算资源的服务。是由第三方云服务提供商提供资源，如应用和存储，这些资源是在服务商的场所内部署。用户通过Internet互联网来获取这些资源的使用。  \n   公有云的优势是成本低，扩展性非常好。缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能问题。  \n   规模最大的几个公有云厂商：阿里云、Amazon Web Services（AWS）、Google Cloud\n\n2. 私有云：“私有”更多是指此类平台属于非共享资源，而非指其安全优势。私有云是为了一个客户单独使用而构建的，所以这些数据、安全和服务质量都较公有云有着更好地保障。\n   在私有云模式中，云平台的资源为包含多个用户的单一组织专用。私有云可由该组织、第三方或两者联合拥有、管理和运营。私有云的部署场所可以是在机构内部，也可以在外部。\n\n3. 混合云：混合云结合了公有云和私有云的特点，允许数据和应用在这两者之间流动。组织可以在私有云中部署敏感数据或关键业务应用，同时利用公有云的弹性来处理突发业务需求。混合云模型可以最大程度地平衡安全性、灵活性和成本效益。\n\n![1.初识云计算与Openstack-2023-08-26-20-09-02](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-09-02.png)\n\n### 按服务类型分类\n\n![1.初识云计算与Openstack-2023-08-26-20-00-39](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-00-39.jpg)\n\n1. IaaS（Infrastructure as a Service–基础架构即服务）：\n   IaaS提供了基础的计算、存储和网络资源，用户可以在这些资源上构建和管理自己的应用环境。它为用户提供了虚拟化的计算资源，包括虚拟机、存储和网络连接。用户可以根据需要自主配置和管理操作系统、应用程序和数据。\n\n    >阿里云的ECS服务器，腾讯云的CVM服务器\n\n2. PaaS（Platform as a Service–平台即服务）：\n   PaaS在IaaS的基础上提供了更高层次的服务，除了计算、存储和网络，还包括了开发和部署应用程序所需的平台环境。PaaS提供了开发工具、数据库、中间件和运行时环境等，使开发人员能够更专注于应用程序的开发而不必关心底层基础设施。\n\n   >阿里云的EDAS\n\n   ![1.初识云计算与Openstack-2023-08-26-16-31-49](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-31-49.png)\n\n3. SaaS（Software as a Service–软件即服务）：\n   SaaS提供完整的应用程序，用户通过互联网访问这些应用程序，无需安装和维护。SaaS应用程序由云服务提供商托管和维护，用户只需要通过浏览器或移动应用访问应用功能。\n\n   >微软的Microsoft 365，各种在线工具。\n\n![1.初识云计算与Openstack-2023-08-26-16-32-26](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-32-26.png)\n\n## OpenStack介绍\n\nOpenStack是一个自由、开源的云计算平台。它主要作为基础设施即服务（IaaS）部署在公用云和私有云中，提供虚拟服务器和其他资源给用户使用。该软件平台由相互关联的组件组成，控制着整个数据中心内不同的厂商的处理器、存储和网络资源的硬件池。用户可以通过基于网络的仪表盘、命令行工具或RESTful网络服务来管理。\n\nOpenStack始于2010年，是Rackspace和美国国家航空航天局的合作项目。截至2012年，它由2012年9月成立的非营利组织OpenStack基金会管理，旨在促进OpenStack软件及其社区。到2018年，已经有500多家公司加入了该项目。在2020年，该基金会宣布它将在2021年更名为Open Infrastructure Foundation（开放基础设施基金会）。\n\n### 适用范围\n\nOpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行建立和提供云计算服务。\n\n此外，OpenStack也用作建立防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。\n\n### 发展历程\n\nOpenStack每半年会发布一个版本，版本从字母A开始向后按顺序的命名；OpenStack社区为了方便描述，因此他们为每一个字母来进行投票，来选出一个单词。\n\n![1.初识云计算与Openstack-2023-08-26-20-34-27](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-34-27.png)\n\n### OpenStack架构\n\n![1.初识云计算与Openstack-2023-08-26-21-59-40](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-59-40.png)\n\n#### 核心组件\n\n1. Keystone： 身份认证服务，用于管理用户、项目和角色，并提供认证和授权功能。\n2. Nova： 计算服务，用于创建和管理虚拟机实例，提供计算资源。\n3. Neutron： 网络服务，提供网络资源的管理和连接，包括虚拟网络、子网、路由等。\n4. Glance： 镜像服务，用于管理虚拟机镜像，用户可以从镜像创建虚拟机实例。\n5. Placement： 该组件于OpenStack Stein版本引入，主要用于优化虚拟机实例的资源分配和调度。\n\n其他常用组件：\n\n1. Cinder： 块存储服务，提供虚拟机实例所需的持久性块存储，如挂载到虚拟机的卷。\n2. Swift： 对象存储服务，用于存储非结构化数据，如文件、图像和视频等。\n3. Horizon： Web 控制台，提供用户界面，用于管理和监控 OpenStack 系统。\n\n![1.初识云计算与Openstack-2023-08-26-21-11-14](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-11-14.png)\n\n>OpenStack本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署。\n>这种分布式特性让OpenStack具备极大的灵活性、伸缩性和高可用性。\n\n### 示例架构\n\n示例架构需要至少两个节点（主机）来启动基本虚拟机或实例。块存储和对象存储等可选服务需要额外的节点。\n\n基本两节点OpenStack部署示例：\n\n1. 控制节点（Controller Node）： 这个节点承担了OpenStack核心服务的角色，例如Identity服务 (Keystone)、Dashboard服务 (Horizon)、Compute服务 (Nova API)、网络服务 (Neutron API) 等。这个节点管理OpenStack环境的整体状态。\n\n2. 计算节点（Compute Node）： 这个节点用于运行虚拟机实例。虚拟机的资源会在计算节点上分配和运行。它连接到控制节点以获取任务和指令，并与存储和网络资源进行交互。\n\n>这种配置适用于非常基本的测试、学习或演示用途，但在生产环境中，为了实现更高的性能、可用性和容错性，通常会使用更多的节点和组件。\n\n![1.初识云计算与Openstack-2023-08-26-22-58-14](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-22-58-14.png)\n\n## 使用packstack部署OpenStack平台\n\n### 资源清单\n\n| 资源名称                          | 说明                       | 地址 |\n| --------------------------------- | -------------------------- | ---- |\n| openStack-train.iso               | Centos + OpenStack平台镜像 |      |\n\n### 基础环境配置\n\n#### 节点规划\n\n| 节点名称（主机名） | 外网网卡IP地址（网卡名：ens34） | 内网网卡IP地址（网卡名：ens33） |\n| ------------------ | ------------------------------- | ------------------------------- |\n| controller         | 192.168.20.10                   | 192.168.10.10                   |\n| compute            | 192.168.20.20                   | 192.168.10.20                   |\n\n#### 利用快照快速恢复系统\n\n1. 控制节点虚拟机环境准备\n\n   虚拟机列表中右键名为`控制节点`的虚拟机->快照->快照管理器，选中`项目2 系统安装完成`后转到并确认。此时虚拟机`控制节点`已恢复到系统安装完毕后的版本（利用快照管理器可以将虚拟机快速恢复到之前已经保存过的任意状态）。\n\n   >这一步创建好的系统ROOT账户密码`000000`\n\n   ![1.初识云计算与Openstack-2023-08-27-20-43-21](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-27-20-43-21.png)\n\n2. 计算节点虚拟机环境准备\n\n   先关闭`控制节点`虚拟机，在虚拟机列表中右键名为`计算节点`的虚拟机->移除，右键`控制节点`虚拟机->管理->克隆，按照向导提示完成虚拟机克隆，克隆自虚拟机中的当前状态，克隆方法选择`完整克隆`，虚拟机名称设置为`计算节点`。\n\n此时运行OpenStack所需的双节点系统环境已经创建完成，接下来做基础配置。\n\n#### 虚拟机网络配置\n\n此步骤的配置需要在`控制节点`和`计算节点`上完成，每个节点分别有两个网卡需要配置：一个内网网卡和一个外网网卡。\n\n1. 在编辑->虚拟网络编辑器可以为虚拟机配置桥接模式网络连接、NAT 和仅主机模式网络连接。\n\n   1. 桥接模式\n\n      桥接模式网络连接通过使用主机系统上的网络适配器将虚拟机连接到网络。如果主机系统位于网络中，桥接模式网络连接通常是虚拟机访问该网络的最简单途径。\n\n   2. NAT模式\n\n      使用 NAT 模式网络时，虚拟机在外部网络中不必具有自己的 IP 地址。主机系统上会建立单独的专用网络。在默认配置中，虚拟机会在此专用网络中通过 DHCP 服务器获取地址。虚拟机和主机系统共享一个网络标识，此标识在外部网络中不可见。\n\n   3. 仅主机模式\n\n      编辑->虚拟网络编辑器，右下角更改设置，按照[节点规划](#节点规划)将`仅主机模式`和`NAT模式`配置为如下图。其中`仅主机模式`的子网地址为`192.168.10.0`，`NAT模式`的子网地址为`192.168.20.0`。\n\n      ![1.初识云计算与Openstack-2023-08-29-14-43-53](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-29-14-43-53.png)\n\n2. 启动`控制节点`虚拟机，在控制节点中使用如下命令编辑`网卡ens33`的配置文件：\n\n   ```shell\n   vi /etc/sysconfig/network-scripts/ifcfg-ens33\n   ```\n\n   编辑文件如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens33\n   UUID=266c663e-d288-4d54-b100-00741dda6c70\n   DEVICE=ens33\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.10.10    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   ```\n\n   >ens33作为内网网口不需要配置默认网关。\n\n   用相同的方法配置外网网卡`ens34`，配置如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens34\n   UUID=bf2fdda3-d6bf-4a72-953f-02cd83115887\n   DEVICE=ens34\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.20.10    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   GATEWAY=192.168.20.2    # 5. 配置网关\n   DNS1=114.114.114.114    # 6. 配置dns\n   ```\n\n3. 使用命令`ifup + 网卡名`激活上一步修改的两个网卡配置\n\n   ```shell\n   [root@localhost ~]# ifup ens33\n   [root@localhost ~]# ifup ens34\n   ```\n\n   使用命令`ip addr`查看当前网卡配置：\n\n   ```shell\n   [root@localhost ~]# ip addr\n   1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n      inet 127.0.0.1/8 scope host lo\n         valid_lft forever preferred_lft forever\n      inet6 ::1/128 scope host\n         valid_lft forever preferred_lft forever\n   2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n      link/ether 00:0c:29:f2:ca:50 brd ff:ff:ff:ff:ff:ff\n      inet 192.168.10.10/24 brd 192.168.10.255 scope global noprefixroute ens33\n         valid_lft forever preferred_lft forever\n      inet6 fe80::922:6217:cb6c:e63/64 scope link noprefixroute\n         valid_lft forever preferred_lft forever\n   3: ens34: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n      link/ether 00:0c:29:f2:ca:5a brd ff:ff:ff:ff:ff:ff\n      inet 192.168.20.10/24 brd 192.168.20.255 scope global noprefixroute ens34\n         valid_lft forever preferred_lft forever\n      inet6 fe80::9b23:9dcb:6af7:812d/64 scope link noprefixroute\n         valid_lft forever preferred_lft forever \n   ```\n\n4. 使用`ping`命令验证当前虚拟机网络\n\n   ```shell\n   //验证内网网卡和宿主机之间的网络连通性\n   [root@localhost ~]# ping -c3 -I ens33 192.168.10.1\n   PING 192.168.10.1 (192.168.10.1) from 192.168.10.10 ens33: 56(84) bytes of data.\n   64 bytes from 192.168.10.1: icmp_seq=1 ttl=128 time=0.154 ms\n   64 bytes from 192.168.10.1: icmp_seq=2 ttl=128 time=0.587 ms\n   64 bytes from 192.168.10.1: icmp_seq=3 ttl=128 time=0.461 ms \n   ```\n\n   ```shell\n   //验证外网网卡和外网资源的网络连通性\n   [root@localhost ~]# ping -c3 -I ens34 www.baidu.com\n   PING www.a.shifen.com (153.3.238.110) from 192.168.20.10 ens34: 56(84) bytes of data.\n   64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=6.73 ms\n   64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=6.99 ms\n   64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=6.96 ms\n   ```\n\n5. 启动`计算节点`虚拟机，上述步骤完成后用相同的方法在`计算节点`上完成网络配置，首先配置内网网卡`ens33`：\n\n   ```shell\n   vi /etc/sysconfig/network-scripts/ifcfg-ens33\n   ```\n\n   编辑文件如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens33\n   UUID=266c663e-d288-4d54-b100-00741dda6c70\n   DEVICE=ens33\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.10.20    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   ```\n\n   用相同的方法配置外网网卡`ens34`，配置如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens34\n   UUID=bf2fdda3-d6bf-4a72-953f-02cd83115887\n   DEVICE=ens34\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.20.20    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   GATEWAY=192.168.20.2    # 5. 配置网关\n   DNS1=114.114.114.114    # 6. 配置dns\n   ```\n\n   * 使用命令`ifup + 网卡名`激活上一步修改的两个网卡配置  \n\n      ```shell\n      [root@localhost ~]# ifdown ens33\n      [root@localhost ~]# ifdown ens34\n      [root@localhost ~]# ifup ens33\n      [root@localhost ~]# ifup ens34\n      ```\n\n   * 重复`步骤4`验证`计算节点`的网络配置\n\n到目前为止网络配置完成，下一步开始配置本地yum源\n\n#### 配置本地YUM源、FTP服务、防火墙\n\n1. 这一步是加载[资源清单](#资源清单)中列出的两个镜像源文件到虚拟机`控制节点`中。\n\n   * 右键虚拟机`控制节点`->设置->选择已有的CD/DVD驱动器->浏览，选择本地的`openStack-train.iso`文件后完成镜像的加载，同时勾选已连接。\n\n      ![1.初识云计算与Openstack-2023-08-28-20-13-50](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-28-20-13-50.png)\n\n2. 重启`控制节点`虚拟机，镜像加载到虚拟机`控制节点`后还需要挂载到系统目录下才能进行读取。\n\n   * 首先创建挂载点，挂载驱动器中的镜像到指定目录\n\n      ```shell\n      [root@localhost ~]# mkdir /opt/openstack    # 1. 创建挂载点\n      [root@localhost ~]#\n      [root@localhost ~]# mount /dev/sr0 /opt/openstack  # 3. 挂载openStack-train.iso镜像\n      mount: /dev/sr0 is write-protected, mounting read-only\n      ```\n\n      >挂载完成后`df -h`查看挂载情况\n\n      ```shell\n      /dev/sr0                  16G   16G     0 100% /opt/openstack\n      ```\n\n3. 这一步配置`控制节点`的YUM源，`控制节点`的源文件在本地。\n\n   * 删除现有的配置文件\n\n      ```shell\n      [root@localhost ~]# rm -rf /etc/yum.repos.d/*.repo\n      ```\n\n   * 在`/etc/yum.repos.d`目录下创建配置文件`local.repo`，并添加以下配置：\n\n      ```text\n      [base]\n      name=base\n      baseurl=file:///opt/openstack/base/\n      gpgcheck=0\n      enabled=1\n      [extras]\n      name=extras\n      baseurl=file:///opt/openstack/extras/\n      gpgcheck=0\n      enabled=1\n      [updates]\n      name=updates\n      baseurl=file:///opt/openstack/updates/\n      gpgcheck=0\n      enabled=1\n      [train]\n      name=train\n      baseurl=file:///opt/openstack/train/\n      gpgcheck=0\n      enabled=1\n      [virt]\n      name=virt\n      baseurl=file:///opt/openstack/virt/\n      gpgcheck=0\n      enabled=1\n      ```\n\n   * 执行以下命令检查YUM源是否可用：\n\n      ```shell\n      [root@controller ~]# yum clean all           # 1. 清除缓存\n      Loaded plugins: fastestmirror\n      Cleaning repos: base extras train updates virt\n      Cleaning up list of fastest mirrors\n      [root@controller ~]# yum makecache           # 2. 重建缓存\n      Loaded plugins: fastestmirror\n      Determining fastest mirrors\n      base                                                                                                                      | 2.9 kB  00:00:00\n      extras                                                                                                                    | 2.9 kB  00:00:00\n      train                                                                                                                     | 2.9 kB  00:00:00\n      updates                                                                                                                   | 2.9 kB  00:00:00\n      virt                                                                                                                      | 2.9 kB  00:00:00\n      (1/15): base/primary_db                                                                                                   | 6.0 MB  00:00:00\n      (2/15): base/filelists_db                                                                                                 | 7.0 MB  00:00:00\n      (3/15): base/other_db                                                                                                     | 2.5 MB  00:00:00\n      (4/15): extras/filelists_db                                                                                               | 259 kB  00:00:00\n      (5/15): extras/other_db                                                                                                   | 145 kB  00:00:00\n      (6/15): extras/primary_db                                                                                                 | 241 kB  00:00:00\n      (7/15): train/filelists_db                                                                                               | 3.6 MB  00:00:00\n      (8/15): train/primary_db                                                                                                 | 1.2 MB  00:00:00\n      (9/15): train/other_db                                                                                                   | 465 kB  00:00:00\n      (10/15): updates/filelists_db                                                                                             | 6.5 MB  00:00:00\n      (11/15): updates/primary_db                                                                                               |  14 MB  00:00:00\n      (12/15): updates/other_db                                                                                                 | 914 kB  00:00:00\n      (13/15): virt/filelists_db                                                                                                |  14 kB  00:00:00\n      (14/15): virt/other_db                                                                                                    |  45 kB  00:00:00\n      (15/15): virt/primary_db                                                                                                  |  56 kB  00:00:00\n      Metadata Cache Created\n      [root@controller ~]# yum repolist            # 3. 查看仓库列表\n      Loaded plugins: fastestmirror\n      Loading mirror speeds from cached hostfile\n      repo id                                                              repo name                                                             status\n      base                                                                 base                                                                  10,039\n      extras                                                               extras                                                                   500\n      train                                                                train                                                                  3,168\n      updates                                                              updates                                                                3,182\n      virt                                                                 virt                                                                      63\n      ```\n\n   * 到目前为止`控制节点`的YUM源配置完毕，最后在`控制节点`上设置域名解析、关闭防火墙、安装FTP服务器为`计算节点`提供服务\n\n      ```shell\n      [root@controller ~]# hostnamectl set-hostname controller  # 1. 修改主机名\n      ```\n\n      >修改完主机名后`ctrl + D`退出当前会话重新登录验证主机名设置是否生效。\n\n      * 在`/etc/hosts`文件最后添加以下两行域名解析\n\n         ```text\n         192.168.10.10 controller\n         192.168.10.20 compute\n         ```\n\n      * 修改`/etc/selinux/config`文件中的`SELINUX=enforcing`为`SELINUX=disabled`\n\n         ```shell\n         [root@controller ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config \n         ```\n\n      * 禁用SELinux和防火墙\n\n         ```shell\n         [root@controller ~]# setenforce 0                   # 1. 禁用SELinux\n         [root@controller ~]# systemctl disable firewalld    # 2. 关闭开机启动防火墙\n         Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\n         Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n         [root@controller ~]# systemctl stop firewalld       # 3. 立即关闭防火墙\n         [root@controller ~]# yum remove -y NetworkManager   # 4. 卸载网络管理器\n         ```\n\n      * 安装配置deltarpm来兼容packstack\n\n         ```shell\n         [root@controller ~]# yum -y install deltarpm\n         ```\n\n         在`/etc/yum.conf`文件中加一行禁用deltarpm\n\n         ```shell\n         [root@controller ~]# echo \"deltarpm=0\" >>/etc/yum.conf\n         ```\n\n      * 安装配置FTP服务端\n\n         ```shell\n         [root@controller ~]# yum -y install vsftpd       # 1. 安装ftp服务端\n         ```\n\n         在`/etc/vsftpd/vsftpd.conf`文件中加入一行`anon_root=/opt`，设置匿名用户访问的根目录为YUM源所挂载的目录\n\n         ```shell\n         [root@controller ~]# systemctl start vsftpd      # 1. 立刻启动FTP服务端\n         [root@controller ~]# systemctl enable vsftpd     # 2. 设置开机启动\n         Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.\n         ```\n\n      * 配置`iptables`允许ftp服务的20/21端口\n\n         1. 编辑文件 `/etc/sysconfig/iptables-config` ，设置第6行`IPTABLES_MODULES=`值为`ip_conntrack_ftp`\n\n            ```shell\n            IPTABLES_MODULES=\"ip_conntrack_ftp\"\n            ```\n\n         2. 编辑文件`/etc/sysconfig/iptables`添加两行规则\n\n            ```shell\n            [root@controller ~]# iptables -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT\n            [root@controller ~]# iptables -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT\n            [root@controller ~]# iptables -L\n            [root@controller ~]# iptables-save > /etc/sysconfig/iptables\n            ```\n\n4. 这一步配置`计算节点`的YUM源，通过FTP服务访问挂载到`控制节点`的源文件。\n\n   * 修改`计算节点`的主机名\n\n      ```shell\n      [root@localhost ~]# hostnamectl set-hostname compute  # 1. 修改主机名\n      ```\n\n   * 在`/etc/hosts`文件最后添加以下两行域名解析\n\n      ```text\n      192.168.10.10 controller\n      192.168.10.20 compute\n      ```\n\n   * 修改`/etc/selinux/config`文件中的`SELINUX=enforcing`为`SELINUX=disabled`\n\n      ```shell\n      [root@compute ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config \n      ```\n\n   * 禁用SELinux和防火墙\n\n      ```shell\n      [root@compute ~]# setenforce 0                   # 1. 禁用SELinux\n      [root@compute ~]# systemctl disable firewalld    # 2. 关闭开机启动防火墙\n      Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\n      Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n      [root@compute ~]# systemctl stop firewalld       # 3. 立即关闭防火墙\n      [root@compute ~]# yum remove -y NetworkManager   # 4. 卸载网络管理器\n      ```\n\n   * 删除已有配置文件\n\n      ```shell\n      [root@compute ~]# rm -rf /etc/yum.repos.d/*.repo\n      ```\n\n      在`/etc/yum.repos.d`目录下创建配置文件`local.repo`，并添加以下配置：\n\n      ```text\n      [base]\n      name=base\n      baseurl=ftp://controller/openstack/base/\n      gpgcheck=0\n      enabled=1\n      [extras]\n      name=extras\n      baseurl=ftp://controller/openstack/extras/\n      gpgcheck=0\n      enabled=1\n      [updates]\n      name=updates\n      baseurl=ftp://controller/openstack/updates/\n      gpgcheck=0\n      enabled=1\n      [train]\n      name=train\n      baseurl=ftp://controller/openstack/train/\n      gpgcheck=0\n      enabled=1\n      [virt]\n      name=virt\n      baseurl=ftp://controller/openstack/virt/\n      gpgcheck=0\n      enabled=1\n      ```\n\n   * 执行以下命令检查YUM源是否可用：\n\n      ```shell\n      [root@compute ~]# yum clean all           # 1. 清除缓存\n      Loaded plugins: fastestmirror\n      Cleaning repos: base extras train updates virt\n      Repository base is listed more than once in the configuration\n      Repository extras is listed more than once in the configuration\n      Repository updates is listed more than once in the configuration\n      Cleaning up list of fastest mirrors\n      [root@compute ~]# yum makecache         # 2. 重建缓存\n      Loaded plugins: fastestmirror\n      Repository base is listed more than once in the configuration\n      Repository extras is listed more than once in the configuration\n      Repository updates is listed more than once in the configuration\n      Determining fastest mirrors\n      * base: mirrors.aliyun.com\n      * extras: mirrors.aliyun.com\n      * updates: mirrors.aliyun.com\n      base                                                                                                                      | 3.6 kB  00:00:00\n      extras                                                                                                                    | 2.9 kB  00:00:00\n      train                                                                                                                     | 2.9 kB  00:00:00\n      updates                                                                                                                   | 2.9 kB  00:00:00\n      virt                                                                                                                      | 2.9 kB  00:00:00\n      (1/15): base/primary_db                                                                                                   | 6.0 MB  00:00:00\n      (2/15): base/filelists_db                                                                                                 | 7.0 MB  00:00:00\n      (3/15): base/other_db                                                                                                     | 2.5 MB  00:00:00\n      (4/15): extras/filelists_db                                                                                               | 259 kB  00:00:00\n      (5/15): extras/other_db                                                                                                   | 145 kB  00:00:00\n      (6/15): extras/primary_db                                                                                                 | 241 kB  00:00:00\n      (7/15): train/filelists_db                                                                                               | 3.6 MB  00:00:00\n      (8/15): train/primary_db                                                                                                 | 1.2 MB  00:00:00\n      (9/15): train/other_db                                                                                                   | 465 kB  00:00:00\n      (10/15): updates/filelists_db                                                                                             | 6.5 MB  00:00:00\n      (11/15): updates/primary_db                                                                                               |  14 MB  00:00:00\n      (12/15): updates/other_db                                                                                                 | 914 kB  00:00:00\n      (13/15): virt/filelists_db                                                                                                |  14 kB  00:00:00\n      (14/15): virt/other_db                                                                                                    |  45 kB  00:00:00\n      (15/15): virt/primary_db                                                                                                  |  56 kB  00:00:00\n      Metadata Cache Created\n      [root@compute ~]# yum repolist          # 3. 查看仓库列表\n      Loaded plugins: fastestmirror\n      Loading mirror speeds from cached hostfile\n      repo id                                                              repo name                                                             status\n      base                                                                 base                                                                  10,039\n      extras                                                               extras                                                                   500\n      train                                                                train                                                                  3,168\n      updates                                                              updates                                                                3,182\n      virt                                                                 virt                                                                      63\n      repolist: 17,906\n      ```\n\n   * 安装配置deltarpm来兼容packstack\n\n      ```shell\n      [root@compute ~]# yum -y install deltarpm\n      ```\n\n      在`/etc/yum.conf`文件中加一行禁用deltarpm\n\n      ```shell\n      [root@compute ~]# echo \"deltarpm=0\" >>/etc/yum.conf\n      ```\n\n### 安装OpenStack平台\n\n* 在控制节点安装packstack\n\n   ```shell\n   [root@controller ~]# yum install -y openstack-packstack\n   ```\n\n* 生成配置文件\n\n   ```shell\n   [root@controller ~]# packstack --gen-answer-file=openstack.txt --os-neutron-l2-agent=openvswitch --os-neutron-ml2-mechanism-drivers=openvswitch --os-neutron-ml2-tenant-network-types=vxlan --os-neutron-ml2-type-drivers=vxlan,flat --provision-demo=n --os-neutron-ovs-bridge-mappings=extnet:br-ex --os-neutron-ovs-bridge-interfaces=br-ex:ens34\n   ```\n\n* 修改配置文件中的IP地址为内网IP\n\n   ```shell\n   [root@controller ~]# sed -i 's/192.168.20.10/192.168.10.10/g' openstack.txt\n   ```\n\n   修改文件`openstack.txt`中计算机点的IP\n\n   ```shell\n   [root@controller ~]# sed -i 's/CONFIG_COMPUTE_HOSTS=.*/CONFIG_COMPUTE_HOSTS=192.168.10.20/g' openstack.txt\n   ```\n\n* 开始安装OpenStack\n\n   ```shell\n   packstack --answer-file=openstack.txt\n   ```\n\n   packstack运行结束后如下图\n\n   ![1.初识云计算与Openstack-2023-08-31-01-28-23](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-31-01-28-23.png)\n\n* 登录OpenStack平台\n\n   接下来可以通过预先配置的网址[http://192.168.10.10/dashboard](http://192.168.10.10/dashboard)访问OpenStack平台\n\n   账户信息通过`cat keystonerc_admin`查看\n","source":"_posts/private_clouds/1.初识云计算与OpenStack.md","raw":"---\ntitle: 初识云计算与OpenStack\ndate: 2023-06-27 22:11:49\ntags:\n---\n\n\n## 传统的计算模式\n\n### 计算机系统结构\n\n![1.初识云计算与Openstack-2023-08-25-22-09-05](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-25-22-09-05.png)\n\n传统的计算模式是指企业或个人在自己的本地环境中构建、管理和维护硬件设备、操作系统和应用程序，以满足其计算和存储需求。\n\n>对于个人用户的场景：需要搭建服务或者使用Linux系统环境时，我们往往需要在本地计算机上搭建虚拟机或者单独购买一套硬件来实现。  \n>对于企业用户的场景：需要对内向员工提供项目管理等等办公服务、对外向用户提供web服务，数据库服务等等，同样需要在企业内部通过搭建数据中心来实现。\n\n* 需要购买和维护物理硬件设备，同时需要专业的IT团队来管理硬件和软件设施。（成本过高）\n* 资源利用率可能不高，硬件设备难以进行快速的资源分配和释放。（企业达到一定规模后难以适应多变的需求）\n* 扩展时需要购买更多硬件，时间和成本较高。（扩展性差）\n* 需要考虑容灾和高可用性，可能需要复杂的架构设计。（安全性需要得到保障）\n\n## 云计算的概念\n\n**云计算的定义：** 云计算是一种按使用量付费的模式，它可以实现随时随地，便捷地，随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。\n\n>和传统模式特点比较\n\n**资源池化：** 传统的虚拟化技术是将单个服务器硬件虚拟成多个虚拟机，其目的也是在于提高服务器资源的利用率。但是，由于单个服务器的CPU、内存、硬盘资源颗粒度较小，因此在虚拟化应用中，经常出现资源配置空洞，要么是CPU核数没有分配完，要么是内存没有分配完，更多的情况是硬盘容量存在大量空闲。而服务器资源池化可以更好的解决上述问题。\n\n![1.初识云计算与Openstack-2023-08-26-14-41-36](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-14-41-36.jpg)\n\n## 云计算的特点\n\n1. 资源池化：云计算中的资源（如计算能力、存储、网络等）被集中管理并池化，供多个用户共享。这种资源的共享和动态分配提高了资源的利用率。\n2. 按需分配： 用户可以根据自己的需求，自主地获取和配置计算资源，无需人工干预。这种自服务模式使用户能够快速获取所需资源，提高了效率。\n3. 快速弹性扩展： 用户可以根据需要快速扩展或缩减资源，以适应业务的变化。这种弹性特性允许用户在高峰时段获得更多资源，而在低谷时段释放资源。\n4. 可用性和容灾性：许多云服务提供商提供高可用性和容灾选项，确保服务在故障时能够持续运行，减少了业务中断的风险。\n\n>按需分配、按量付费，各种计费方式；可扩展一方面使得上云的应用能够根据不同时段的业务需求动态调整资源另一方面，企业可以在不停机的情况下增加任意资源；可用性使得服务器出现故障时会无缝切换到资源池上的其他资源，不管是计算资源还是存储设备都能保证24小时不间断提供服务。  \n>基于以上特点总结：用户不需要为应用单独购买服务器、同时不需要付出管理成本，只需要付出租用的成本就可以使用到随时能够扩容的并且有专业人员维护以保障安全的计算服务。\n\n## 云计算的分类\n\n### 按服务对象或者运营模式分类\n\n1. 公有云：“公有”反映了这类云服务并非用户所拥有，公有云是面向大众提供计算资源的服务。是由第三方云服务提供商提供资源，如应用和存储，这些资源是在服务商的场所内部署。用户通过Internet互联网来获取这些资源的使用。  \n   公有云的优势是成本低，扩展性非常好。缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能问题。  \n   规模最大的几个公有云厂商：阿里云、Amazon Web Services（AWS）、Google Cloud\n\n2. 私有云：“私有”更多是指此类平台属于非共享资源，而非指其安全优势。私有云是为了一个客户单独使用而构建的，所以这些数据、安全和服务质量都较公有云有着更好地保障。\n   在私有云模式中，云平台的资源为包含多个用户的单一组织专用。私有云可由该组织、第三方或两者联合拥有、管理和运营。私有云的部署场所可以是在机构内部，也可以在外部。\n\n3. 混合云：混合云结合了公有云和私有云的特点，允许数据和应用在这两者之间流动。组织可以在私有云中部署敏感数据或关键业务应用，同时利用公有云的弹性来处理突发业务需求。混合云模型可以最大程度地平衡安全性、灵活性和成本效益。\n\n![1.初识云计算与Openstack-2023-08-26-20-09-02](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-09-02.png)\n\n### 按服务类型分类\n\n![1.初识云计算与Openstack-2023-08-26-20-00-39](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-00-39.jpg)\n\n1. IaaS（Infrastructure as a Service–基础架构即服务）：\n   IaaS提供了基础的计算、存储和网络资源，用户可以在这些资源上构建和管理自己的应用环境。它为用户提供了虚拟化的计算资源，包括虚拟机、存储和网络连接。用户可以根据需要自主配置和管理操作系统、应用程序和数据。\n\n    >阿里云的ECS服务器，腾讯云的CVM服务器\n\n2. PaaS（Platform as a Service–平台即服务）：\n   PaaS在IaaS的基础上提供了更高层次的服务，除了计算、存储和网络，还包括了开发和部署应用程序所需的平台环境。PaaS提供了开发工具、数据库、中间件和运行时环境等，使开发人员能够更专注于应用程序的开发而不必关心底层基础设施。\n\n   >阿里云的EDAS\n\n   ![1.初识云计算与Openstack-2023-08-26-16-31-49](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-31-49.png)\n\n3. SaaS（Software as a Service–软件即服务）：\n   SaaS提供完整的应用程序，用户通过互联网访问这些应用程序，无需安装和维护。SaaS应用程序由云服务提供商托管和维护，用户只需要通过浏览器或移动应用访问应用功能。\n\n   >微软的Microsoft 365，各种在线工具。\n\n![1.初识云计算与Openstack-2023-08-26-16-32-26](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-32-26.png)\n\n## OpenStack介绍\n\nOpenStack是一个自由、开源的云计算平台。它主要作为基础设施即服务（IaaS）部署在公用云和私有云中，提供虚拟服务器和其他资源给用户使用。该软件平台由相互关联的组件组成，控制着整个数据中心内不同的厂商的处理器、存储和网络资源的硬件池。用户可以通过基于网络的仪表盘、命令行工具或RESTful网络服务来管理。\n\nOpenStack始于2010年，是Rackspace和美国国家航空航天局的合作项目。截至2012年，它由2012年9月成立的非营利组织OpenStack基金会管理，旨在促进OpenStack软件及其社区。到2018年，已经有500多家公司加入了该项目。在2020年，该基金会宣布它将在2021年更名为Open Infrastructure Foundation（开放基础设施基金会）。\n\n### 适用范围\n\nOpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行建立和提供云计算服务。\n\n此外，OpenStack也用作建立防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。\n\n### 发展历程\n\nOpenStack每半年会发布一个版本，版本从字母A开始向后按顺序的命名；OpenStack社区为了方便描述，因此他们为每一个字母来进行投票，来选出一个单词。\n\n![1.初识云计算与Openstack-2023-08-26-20-34-27](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-34-27.png)\n\n### OpenStack架构\n\n![1.初识云计算与Openstack-2023-08-26-21-59-40](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-59-40.png)\n\n#### 核心组件\n\n1. Keystone： 身份认证服务，用于管理用户、项目和角色，并提供认证和授权功能。\n2. Nova： 计算服务，用于创建和管理虚拟机实例，提供计算资源。\n3. Neutron： 网络服务，提供网络资源的管理和连接，包括虚拟网络、子网、路由等。\n4. Glance： 镜像服务，用于管理虚拟机镜像，用户可以从镜像创建虚拟机实例。\n5. Placement： 该组件于OpenStack Stein版本引入，主要用于优化虚拟机实例的资源分配和调度。\n\n其他常用组件：\n\n1. Cinder： 块存储服务，提供虚拟机实例所需的持久性块存储，如挂载到虚拟机的卷。\n2. Swift： 对象存储服务，用于存储非结构化数据，如文件、图像和视频等。\n3. Horizon： Web 控制台，提供用户界面，用于管理和监控 OpenStack 系统。\n\n![1.初识云计算与Openstack-2023-08-26-21-11-14](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-11-14.png)\n\n>OpenStack本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署。\n>这种分布式特性让OpenStack具备极大的灵活性、伸缩性和高可用性。\n\n### 示例架构\n\n示例架构需要至少两个节点（主机）来启动基本虚拟机或实例。块存储和对象存储等可选服务需要额外的节点。\n\n基本两节点OpenStack部署示例：\n\n1. 控制节点（Controller Node）： 这个节点承担了OpenStack核心服务的角色，例如Identity服务 (Keystone)、Dashboard服务 (Horizon)、Compute服务 (Nova API)、网络服务 (Neutron API) 等。这个节点管理OpenStack环境的整体状态。\n\n2. 计算节点（Compute Node）： 这个节点用于运行虚拟机实例。虚拟机的资源会在计算节点上分配和运行。它连接到控制节点以获取任务和指令，并与存储和网络资源进行交互。\n\n>这种配置适用于非常基本的测试、学习或演示用途，但在生产环境中，为了实现更高的性能、可用性和容错性，通常会使用更多的节点和组件。\n\n![1.初识云计算与Openstack-2023-08-26-22-58-14](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-22-58-14.png)\n\n## 使用packstack部署OpenStack平台\n\n### 资源清单\n\n| 资源名称                          | 说明                       | 地址 |\n| --------------------------------- | -------------------------- | ---- |\n| openStack-train.iso               | Centos + OpenStack平台镜像 |      |\n\n### 基础环境配置\n\n#### 节点规划\n\n| 节点名称（主机名） | 外网网卡IP地址（网卡名：ens34） | 内网网卡IP地址（网卡名：ens33） |\n| ------------------ | ------------------------------- | ------------------------------- |\n| controller         | 192.168.20.10                   | 192.168.10.10                   |\n| compute            | 192.168.20.20                   | 192.168.10.20                   |\n\n#### 利用快照快速恢复系统\n\n1. 控制节点虚拟机环境准备\n\n   虚拟机列表中右键名为`控制节点`的虚拟机->快照->快照管理器，选中`项目2 系统安装完成`后转到并确认。此时虚拟机`控制节点`已恢复到系统安装完毕后的版本（利用快照管理器可以将虚拟机快速恢复到之前已经保存过的任意状态）。\n\n   >这一步创建好的系统ROOT账户密码`000000`\n\n   ![1.初识云计算与Openstack-2023-08-27-20-43-21](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-27-20-43-21.png)\n\n2. 计算节点虚拟机环境准备\n\n   先关闭`控制节点`虚拟机，在虚拟机列表中右键名为`计算节点`的虚拟机->移除，右键`控制节点`虚拟机->管理->克隆，按照向导提示完成虚拟机克隆，克隆自虚拟机中的当前状态，克隆方法选择`完整克隆`，虚拟机名称设置为`计算节点`。\n\n此时运行OpenStack所需的双节点系统环境已经创建完成，接下来做基础配置。\n\n#### 虚拟机网络配置\n\n此步骤的配置需要在`控制节点`和`计算节点`上完成，每个节点分别有两个网卡需要配置：一个内网网卡和一个外网网卡。\n\n1. 在编辑->虚拟网络编辑器可以为虚拟机配置桥接模式网络连接、NAT 和仅主机模式网络连接。\n\n   1. 桥接模式\n\n      桥接模式网络连接通过使用主机系统上的网络适配器将虚拟机连接到网络。如果主机系统位于网络中，桥接模式网络连接通常是虚拟机访问该网络的最简单途径。\n\n   2. NAT模式\n\n      使用 NAT 模式网络时，虚拟机在外部网络中不必具有自己的 IP 地址。主机系统上会建立单独的专用网络。在默认配置中，虚拟机会在此专用网络中通过 DHCP 服务器获取地址。虚拟机和主机系统共享一个网络标识，此标识在外部网络中不可见。\n\n   3. 仅主机模式\n\n      编辑->虚拟网络编辑器，右下角更改设置，按照[节点规划](#节点规划)将`仅主机模式`和`NAT模式`配置为如下图。其中`仅主机模式`的子网地址为`192.168.10.0`，`NAT模式`的子网地址为`192.168.20.0`。\n\n      ![1.初识云计算与Openstack-2023-08-29-14-43-53](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-29-14-43-53.png)\n\n2. 启动`控制节点`虚拟机，在控制节点中使用如下命令编辑`网卡ens33`的配置文件：\n\n   ```shell\n   vi /etc/sysconfig/network-scripts/ifcfg-ens33\n   ```\n\n   编辑文件如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens33\n   UUID=266c663e-d288-4d54-b100-00741dda6c70\n   DEVICE=ens33\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.10.10    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   ```\n\n   >ens33作为内网网口不需要配置默认网关。\n\n   用相同的方法配置外网网卡`ens34`，配置如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens34\n   UUID=bf2fdda3-d6bf-4a72-953f-02cd83115887\n   DEVICE=ens34\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.20.10    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   GATEWAY=192.168.20.2    # 5. 配置网关\n   DNS1=114.114.114.114    # 6. 配置dns\n   ```\n\n3. 使用命令`ifup + 网卡名`激活上一步修改的两个网卡配置\n\n   ```shell\n   [root@localhost ~]# ifup ens33\n   [root@localhost ~]# ifup ens34\n   ```\n\n   使用命令`ip addr`查看当前网卡配置：\n\n   ```shell\n   [root@localhost ~]# ip addr\n   1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n      inet 127.0.0.1/8 scope host lo\n         valid_lft forever preferred_lft forever\n      inet6 ::1/128 scope host\n         valid_lft forever preferred_lft forever\n   2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n      link/ether 00:0c:29:f2:ca:50 brd ff:ff:ff:ff:ff:ff\n      inet 192.168.10.10/24 brd 192.168.10.255 scope global noprefixroute ens33\n         valid_lft forever preferred_lft forever\n      inet6 fe80::922:6217:cb6c:e63/64 scope link noprefixroute\n         valid_lft forever preferred_lft forever\n   3: ens34: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n      link/ether 00:0c:29:f2:ca:5a brd ff:ff:ff:ff:ff:ff\n      inet 192.168.20.10/24 brd 192.168.20.255 scope global noprefixroute ens34\n         valid_lft forever preferred_lft forever\n      inet6 fe80::9b23:9dcb:6af7:812d/64 scope link noprefixroute\n         valid_lft forever preferred_lft forever \n   ```\n\n4. 使用`ping`命令验证当前虚拟机网络\n\n   ```shell\n   //验证内网网卡和宿主机之间的网络连通性\n   [root@localhost ~]# ping -c3 -I ens33 192.168.10.1\n   PING 192.168.10.1 (192.168.10.1) from 192.168.10.10 ens33: 56(84) bytes of data.\n   64 bytes from 192.168.10.1: icmp_seq=1 ttl=128 time=0.154 ms\n   64 bytes from 192.168.10.1: icmp_seq=2 ttl=128 time=0.587 ms\n   64 bytes from 192.168.10.1: icmp_seq=3 ttl=128 time=0.461 ms \n   ```\n\n   ```shell\n   //验证外网网卡和外网资源的网络连通性\n   [root@localhost ~]# ping -c3 -I ens34 www.baidu.com\n   PING www.a.shifen.com (153.3.238.110) from 192.168.20.10 ens34: 56(84) bytes of data.\n   64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=6.73 ms\n   64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=6.99 ms\n   64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=6.96 ms\n   ```\n\n5. 启动`计算节点`虚拟机，上述步骤完成后用相同的方法在`计算节点`上完成网络配置，首先配置内网网卡`ens33`：\n\n   ```shell\n   vi /etc/sysconfig/network-scripts/ifcfg-ens33\n   ```\n\n   编辑文件如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens33\n   UUID=266c663e-d288-4d54-b100-00741dda6c70\n   DEVICE=ens33\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.10.20    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   ```\n\n   用相同的方法配置外网网卡`ens34`，配置如下：\n\n   ```shell\n   TYPE=Ethernet\n   PROXY_METHOD=none\n   BROWSER_ONLY=no\n   BOOTPROTO=static        # 1. 配置静态分配ip\n   DEFROUTE=yes\n   IPV4_FAILURE_FATAL=no\n   IPV6INIT=yes\n   IPV6_AUTOCONF=yes\n   IPV6_DEFROUTE=yes\n   IPV6_FAILURE_FATAL=no\n   IPV6_ADDR_GEN_MODE=stable-privacy\n   NAME=ens34\n   UUID=bf2fdda3-d6bf-4a72-953f-02cd83115887\n   DEVICE=ens34\n   ONBOOT=yes              # 2. 配置开机激活网卡\n   IPADDR=192.168.20.20    # 3. 配置ip地址\n   NETMASK=255.255.255.0   # 4. 配置子网掩码\n   GATEWAY=192.168.20.2    # 5. 配置网关\n   DNS1=114.114.114.114    # 6. 配置dns\n   ```\n\n   * 使用命令`ifup + 网卡名`激活上一步修改的两个网卡配置  \n\n      ```shell\n      [root@localhost ~]# ifdown ens33\n      [root@localhost ~]# ifdown ens34\n      [root@localhost ~]# ifup ens33\n      [root@localhost ~]# ifup ens34\n      ```\n\n   * 重复`步骤4`验证`计算节点`的网络配置\n\n到目前为止网络配置完成，下一步开始配置本地yum源\n\n#### 配置本地YUM源、FTP服务、防火墙\n\n1. 这一步是加载[资源清单](#资源清单)中列出的两个镜像源文件到虚拟机`控制节点`中。\n\n   * 右键虚拟机`控制节点`->设置->选择已有的CD/DVD驱动器->浏览，选择本地的`openStack-train.iso`文件后完成镜像的加载，同时勾选已连接。\n\n      ![1.初识云计算与Openstack-2023-08-28-20-13-50](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-28-20-13-50.png)\n\n2. 重启`控制节点`虚拟机，镜像加载到虚拟机`控制节点`后还需要挂载到系统目录下才能进行读取。\n\n   * 首先创建挂载点，挂载驱动器中的镜像到指定目录\n\n      ```shell\n      [root@localhost ~]# mkdir /opt/openstack    # 1. 创建挂载点\n      [root@localhost ~]#\n      [root@localhost ~]# mount /dev/sr0 /opt/openstack  # 3. 挂载openStack-train.iso镜像\n      mount: /dev/sr0 is write-protected, mounting read-only\n      ```\n\n      >挂载完成后`df -h`查看挂载情况\n\n      ```shell\n      /dev/sr0                  16G   16G     0 100% /opt/openstack\n      ```\n\n3. 这一步配置`控制节点`的YUM源，`控制节点`的源文件在本地。\n\n   * 删除现有的配置文件\n\n      ```shell\n      [root@localhost ~]# rm -rf /etc/yum.repos.d/*.repo\n      ```\n\n   * 在`/etc/yum.repos.d`目录下创建配置文件`local.repo`，并添加以下配置：\n\n      ```text\n      [base]\n      name=base\n      baseurl=file:///opt/openstack/base/\n      gpgcheck=0\n      enabled=1\n      [extras]\n      name=extras\n      baseurl=file:///opt/openstack/extras/\n      gpgcheck=0\n      enabled=1\n      [updates]\n      name=updates\n      baseurl=file:///opt/openstack/updates/\n      gpgcheck=0\n      enabled=1\n      [train]\n      name=train\n      baseurl=file:///opt/openstack/train/\n      gpgcheck=0\n      enabled=1\n      [virt]\n      name=virt\n      baseurl=file:///opt/openstack/virt/\n      gpgcheck=0\n      enabled=1\n      ```\n\n   * 执行以下命令检查YUM源是否可用：\n\n      ```shell\n      [root@controller ~]# yum clean all           # 1. 清除缓存\n      Loaded plugins: fastestmirror\n      Cleaning repos: base extras train updates virt\n      Cleaning up list of fastest mirrors\n      [root@controller ~]# yum makecache           # 2. 重建缓存\n      Loaded plugins: fastestmirror\n      Determining fastest mirrors\n      base                                                                                                                      | 2.9 kB  00:00:00\n      extras                                                                                                                    | 2.9 kB  00:00:00\n      train                                                                                                                     | 2.9 kB  00:00:00\n      updates                                                                                                                   | 2.9 kB  00:00:00\n      virt                                                                                                                      | 2.9 kB  00:00:00\n      (1/15): base/primary_db                                                                                                   | 6.0 MB  00:00:00\n      (2/15): base/filelists_db                                                                                                 | 7.0 MB  00:00:00\n      (3/15): base/other_db                                                                                                     | 2.5 MB  00:00:00\n      (4/15): extras/filelists_db                                                                                               | 259 kB  00:00:00\n      (5/15): extras/other_db                                                                                                   | 145 kB  00:00:00\n      (6/15): extras/primary_db                                                                                                 | 241 kB  00:00:00\n      (7/15): train/filelists_db                                                                                               | 3.6 MB  00:00:00\n      (8/15): train/primary_db                                                                                                 | 1.2 MB  00:00:00\n      (9/15): train/other_db                                                                                                   | 465 kB  00:00:00\n      (10/15): updates/filelists_db                                                                                             | 6.5 MB  00:00:00\n      (11/15): updates/primary_db                                                                                               |  14 MB  00:00:00\n      (12/15): updates/other_db                                                                                                 | 914 kB  00:00:00\n      (13/15): virt/filelists_db                                                                                                |  14 kB  00:00:00\n      (14/15): virt/other_db                                                                                                    |  45 kB  00:00:00\n      (15/15): virt/primary_db                                                                                                  |  56 kB  00:00:00\n      Metadata Cache Created\n      [root@controller ~]# yum repolist            # 3. 查看仓库列表\n      Loaded plugins: fastestmirror\n      Loading mirror speeds from cached hostfile\n      repo id                                                              repo name                                                             status\n      base                                                                 base                                                                  10,039\n      extras                                                               extras                                                                   500\n      train                                                                train                                                                  3,168\n      updates                                                              updates                                                                3,182\n      virt                                                                 virt                                                                      63\n      ```\n\n   * 到目前为止`控制节点`的YUM源配置完毕，最后在`控制节点`上设置域名解析、关闭防火墙、安装FTP服务器为`计算节点`提供服务\n\n      ```shell\n      [root@controller ~]# hostnamectl set-hostname controller  # 1. 修改主机名\n      ```\n\n      >修改完主机名后`ctrl + D`退出当前会话重新登录验证主机名设置是否生效。\n\n      * 在`/etc/hosts`文件最后添加以下两行域名解析\n\n         ```text\n         192.168.10.10 controller\n         192.168.10.20 compute\n         ```\n\n      * 修改`/etc/selinux/config`文件中的`SELINUX=enforcing`为`SELINUX=disabled`\n\n         ```shell\n         [root@controller ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config \n         ```\n\n      * 禁用SELinux和防火墙\n\n         ```shell\n         [root@controller ~]# setenforce 0                   # 1. 禁用SELinux\n         [root@controller ~]# systemctl disable firewalld    # 2. 关闭开机启动防火墙\n         Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\n         Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n         [root@controller ~]# systemctl stop firewalld       # 3. 立即关闭防火墙\n         [root@controller ~]# yum remove -y NetworkManager   # 4. 卸载网络管理器\n         ```\n\n      * 安装配置deltarpm来兼容packstack\n\n         ```shell\n         [root@controller ~]# yum -y install deltarpm\n         ```\n\n         在`/etc/yum.conf`文件中加一行禁用deltarpm\n\n         ```shell\n         [root@controller ~]# echo \"deltarpm=0\" >>/etc/yum.conf\n         ```\n\n      * 安装配置FTP服务端\n\n         ```shell\n         [root@controller ~]# yum -y install vsftpd       # 1. 安装ftp服务端\n         ```\n\n         在`/etc/vsftpd/vsftpd.conf`文件中加入一行`anon_root=/opt`，设置匿名用户访问的根目录为YUM源所挂载的目录\n\n         ```shell\n         [root@controller ~]# systemctl start vsftpd      # 1. 立刻启动FTP服务端\n         [root@controller ~]# systemctl enable vsftpd     # 2. 设置开机启动\n         Created symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.\n         ```\n\n      * 配置`iptables`允许ftp服务的20/21端口\n\n         1. 编辑文件 `/etc/sysconfig/iptables-config` ，设置第6行`IPTABLES_MODULES=`值为`ip_conntrack_ftp`\n\n            ```shell\n            IPTABLES_MODULES=\"ip_conntrack_ftp\"\n            ```\n\n         2. 编辑文件`/etc/sysconfig/iptables`添加两行规则\n\n            ```shell\n            [root@controller ~]# iptables -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT\n            [root@controller ~]# iptables -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT\n            [root@controller ~]# iptables -L\n            [root@controller ~]# iptables-save > /etc/sysconfig/iptables\n            ```\n\n4. 这一步配置`计算节点`的YUM源，通过FTP服务访问挂载到`控制节点`的源文件。\n\n   * 修改`计算节点`的主机名\n\n      ```shell\n      [root@localhost ~]# hostnamectl set-hostname compute  # 1. 修改主机名\n      ```\n\n   * 在`/etc/hosts`文件最后添加以下两行域名解析\n\n      ```text\n      192.168.10.10 controller\n      192.168.10.20 compute\n      ```\n\n   * 修改`/etc/selinux/config`文件中的`SELINUX=enforcing`为`SELINUX=disabled`\n\n      ```shell\n      [root@compute ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config \n      ```\n\n   * 禁用SELinux和防火墙\n\n      ```shell\n      [root@compute ~]# setenforce 0                   # 1. 禁用SELinux\n      [root@compute ~]# systemctl disable firewalld    # 2. 关闭开机启动防火墙\n      Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\n      Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n      [root@compute ~]# systemctl stop firewalld       # 3. 立即关闭防火墙\n      [root@compute ~]# yum remove -y NetworkManager   # 4. 卸载网络管理器\n      ```\n\n   * 删除已有配置文件\n\n      ```shell\n      [root@compute ~]# rm -rf /etc/yum.repos.d/*.repo\n      ```\n\n      在`/etc/yum.repos.d`目录下创建配置文件`local.repo`，并添加以下配置：\n\n      ```text\n      [base]\n      name=base\n      baseurl=ftp://controller/openstack/base/\n      gpgcheck=0\n      enabled=1\n      [extras]\n      name=extras\n      baseurl=ftp://controller/openstack/extras/\n      gpgcheck=0\n      enabled=1\n      [updates]\n      name=updates\n      baseurl=ftp://controller/openstack/updates/\n      gpgcheck=0\n      enabled=1\n      [train]\n      name=train\n      baseurl=ftp://controller/openstack/train/\n      gpgcheck=0\n      enabled=1\n      [virt]\n      name=virt\n      baseurl=ftp://controller/openstack/virt/\n      gpgcheck=0\n      enabled=1\n      ```\n\n   * 执行以下命令检查YUM源是否可用：\n\n      ```shell\n      [root@compute ~]# yum clean all           # 1. 清除缓存\n      Loaded plugins: fastestmirror\n      Cleaning repos: base extras train updates virt\n      Repository base is listed more than once in the configuration\n      Repository extras is listed more than once in the configuration\n      Repository updates is listed more than once in the configuration\n      Cleaning up list of fastest mirrors\n      [root@compute ~]# yum makecache         # 2. 重建缓存\n      Loaded plugins: fastestmirror\n      Repository base is listed more than once in the configuration\n      Repository extras is listed more than once in the configuration\n      Repository updates is listed more than once in the configuration\n      Determining fastest mirrors\n      * base: mirrors.aliyun.com\n      * extras: mirrors.aliyun.com\n      * updates: mirrors.aliyun.com\n      base                                                                                                                      | 3.6 kB  00:00:00\n      extras                                                                                                                    | 2.9 kB  00:00:00\n      train                                                                                                                     | 2.9 kB  00:00:00\n      updates                                                                                                                   | 2.9 kB  00:00:00\n      virt                                                                                                                      | 2.9 kB  00:00:00\n      (1/15): base/primary_db                                                                                                   | 6.0 MB  00:00:00\n      (2/15): base/filelists_db                                                                                                 | 7.0 MB  00:00:00\n      (3/15): base/other_db                                                                                                     | 2.5 MB  00:00:00\n      (4/15): extras/filelists_db                                                                                               | 259 kB  00:00:00\n      (5/15): extras/other_db                                                                                                   | 145 kB  00:00:00\n      (6/15): extras/primary_db                                                                                                 | 241 kB  00:00:00\n      (7/15): train/filelists_db                                                                                               | 3.6 MB  00:00:00\n      (8/15): train/primary_db                                                                                                 | 1.2 MB  00:00:00\n      (9/15): train/other_db                                                                                                   | 465 kB  00:00:00\n      (10/15): updates/filelists_db                                                                                             | 6.5 MB  00:00:00\n      (11/15): updates/primary_db                                                                                               |  14 MB  00:00:00\n      (12/15): updates/other_db                                                                                                 | 914 kB  00:00:00\n      (13/15): virt/filelists_db                                                                                                |  14 kB  00:00:00\n      (14/15): virt/other_db                                                                                                    |  45 kB  00:00:00\n      (15/15): virt/primary_db                                                                                                  |  56 kB  00:00:00\n      Metadata Cache Created\n      [root@compute ~]# yum repolist          # 3. 查看仓库列表\n      Loaded plugins: fastestmirror\n      Loading mirror speeds from cached hostfile\n      repo id                                                              repo name                                                             status\n      base                                                                 base                                                                  10,039\n      extras                                                               extras                                                                   500\n      train                                                                train                                                                  3,168\n      updates                                                              updates                                                                3,182\n      virt                                                                 virt                                                                      63\n      repolist: 17,906\n      ```\n\n   * 安装配置deltarpm来兼容packstack\n\n      ```shell\n      [root@compute ~]# yum -y install deltarpm\n      ```\n\n      在`/etc/yum.conf`文件中加一行禁用deltarpm\n\n      ```shell\n      [root@compute ~]# echo \"deltarpm=0\" >>/etc/yum.conf\n      ```\n\n### 安装OpenStack平台\n\n* 在控制节点安装packstack\n\n   ```shell\n   [root@controller ~]# yum install -y openstack-packstack\n   ```\n\n* 生成配置文件\n\n   ```shell\n   [root@controller ~]# packstack --gen-answer-file=openstack.txt --os-neutron-l2-agent=openvswitch --os-neutron-ml2-mechanism-drivers=openvswitch --os-neutron-ml2-tenant-network-types=vxlan --os-neutron-ml2-type-drivers=vxlan,flat --provision-demo=n --os-neutron-ovs-bridge-mappings=extnet:br-ex --os-neutron-ovs-bridge-interfaces=br-ex:ens34\n   ```\n\n* 修改配置文件中的IP地址为内网IP\n\n   ```shell\n   [root@controller ~]# sed -i 's/192.168.20.10/192.168.10.10/g' openstack.txt\n   ```\n\n   修改文件`openstack.txt`中计算机点的IP\n\n   ```shell\n   [root@controller ~]# sed -i 's/CONFIG_COMPUTE_HOSTS=.*/CONFIG_COMPUTE_HOSTS=192.168.10.20/g' openstack.txt\n   ```\n\n* 开始安装OpenStack\n\n   ```shell\n   packstack --answer-file=openstack.txt\n   ```\n\n   packstack运行结束后如下图\n\n   ![1.初识云计算与Openstack-2023-08-31-01-28-23](https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-31-01-28-23.png)\n\n* 登录OpenStack平台\n\n   接下来可以通过预先配置的网址[http://192.168.10.10/dashboard](http://192.168.10.10/dashboard)访问OpenStack平台\n\n   账户信息通过`cat keystonerc_admin`查看\n","slug":"private_clouds/1.初识云计算与OpenStack","published":1,"updated":"2023-08-30T17:36:59.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clly1p04p000h1dnzchum0efw","content":"<h2 id=\"传统的计算模式\"><a href=\"#传统的计算模式\" class=\"headerlink\" title=\"传统的计算模式\"></a>传统的计算模式</h2><h3 id=\"计算机系统结构\"><a href=\"#计算机系统结构\" class=\"headerlink\" title=\"计算机系统结构\"></a>计算机系统结构</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-25-22-09-05.png\" alt=\"1.初识云计算与Openstack-2023-08-25-22-09-05\"></p>\n<p>传统的计算模式是指企业或个人在自己的本地环境中构建、管理和维护硬件设备、操作系统和应用程序，以满足其计算和存储需求。</p>\n<blockquote>\n<p>对于个人用户的场景：需要搭建服务或者使用Linux系统环境时，我们往往需要在本地计算机上搭建虚拟机或者单独购买一套硬件来实现。<br>对于企业用户的场景：需要对内向员工提供项目管理等等办公服务、对外向用户提供web服务，数据库服务等等，同样需要在企业内部通过搭建数据中心来实现。</p>\n</blockquote>\n<ul>\n<li>需要购买和维护物理硬件设备，同时需要专业的IT团队来管理硬件和软件设施。（成本过高）</li>\n<li>资源利用率可能不高，硬件设备难以进行快速的资源分配和释放。（企业达到一定规模后难以适应多变的需求）</li>\n<li>扩展时需要购买更多硬件，时间和成本较高。（扩展性差）</li>\n<li>需要考虑容灾和高可用性，可能需要复杂的架构设计。（安全性需要得到保障）</li>\n</ul>\n<h2 id=\"云计算的概念\"><a href=\"#云计算的概念\" class=\"headerlink\" title=\"云计算的概念\"></a>云计算的概念</h2><p><strong>云计算的定义：</strong> 云计算是一种按使用量付费的模式，它可以实现随时随地，便捷地，随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。</p>\n<blockquote>\n<p>和传统模式特点比较</p>\n</blockquote>\n<p><strong>资源池化：</strong> 传统的虚拟化技术是将单个服务器硬件虚拟成多个虚拟机，其目的也是在于提高服务器资源的利用率。但是，由于单个服务器的CPU、内存、硬盘资源颗粒度较小，因此在虚拟化应用中，经常出现资源配置空洞，要么是CPU核数没有分配完，要么是内存没有分配完，更多的情况是硬盘容量存在大量空闲。而服务器资源池化可以更好的解决上述问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-14-41-36.jpg\" alt=\"1.初识云计算与Openstack-2023-08-26-14-41-36\"></p>\n<h2 id=\"云计算的特点\"><a href=\"#云计算的特点\" class=\"headerlink\" title=\"云计算的特点\"></a>云计算的特点</h2><ol>\n<li>资源池化：云计算中的资源（如计算能力、存储、网络等）被集中管理并池化，供多个用户共享。这种资源的共享和动态分配提高了资源的利用率。</li>\n<li>按需分配： 用户可以根据自己的需求，自主地获取和配置计算资源，无需人工干预。这种自服务模式使用户能够快速获取所需资源，提高了效率。</li>\n<li>快速弹性扩展： 用户可以根据需要快速扩展或缩减资源，以适应业务的变化。这种弹性特性允许用户在高峰时段获得更多资源，而在低谷时段释放资源。</li>\n<li>可用性和容灾性：许多云服务提供商提供高可用性和容灾选项，确保服务在故障时能够持续运行，减少了业务中断的风险。</li>\n</ol>\n<blockquote>\n<p>按需分配、按量付费，各种计费方式；可扩展一方面使得上云的应用能够根据不同时段的业务需求动态调整资源另一方面，企业可以在不停机的情况下增加任意资源；可用性使得服务器出现故障时会无缝切换到资源池上的其他资源，不管是计算资源还是存储设备都能保证24小时不间断提供服务。<br>基于以上特点总结：用户不需要为应用单独购买服务器、同时不需要付出管理成本，只需要付出租用的成本就可以使用到随时能够扩容的并且有专业人员维护以保障安全的计算服务。</p>\n</blockquote>\n<h2 id=\"云计算的分类\"><a href=\"#云计算的分类\" class=\"headerlink\" title=\"云计算的分类\"></a>云计算的分类</h2><h3 id=\"按服务对象或者运营模式分类\"><a href=\"#按服务对象或者运营模式分类\" class=\"headerlink\" title=\"按服务对象或者运营模式分类\"></a>按服务对象或者运营模式分类</h3><ol>\n<li><p>公有云：“公有”反映了这类云服务并非用户所拥有，公有云是面向大众提供计算资源的服务。是由第三方云服务提供商提供资源，如应用和存储，这些资源是在服务商的场所内部署。用户通过Internet互联网来获取这些资源的使用。<br>公有云的优势是成本低，扩展性非常好。缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能问题。<br>规模最大的几个公有云厂商：阿里云、Amazon Web Services（AWS）、Google Cloud</p>\n</li>\n<li><p>私有云：“私有”更多是指此类平台属于非共享资源，而非指其安全优势。私有云是为了一个客户单独使用而构建的，所以这些数据、安全和服务质量都较公有云有着更好地保障。<br>在私有云模式中，云平台的资源为包含多个用户的单一组织专用。私有云可由该组织、第三方或两者联合拥有、管理和运营。私有云的部署场所可以是在机构内部，也可以在外部。</p>\n</li>\n<li><p>混合云：混合云结合了公有云和私有云的特点，允许数据和应用在这两者之间流动。组织可以在私有云中部署敏感数据或关键业务应用，同时利用公有云的弹性来处理突发业务需求。混合云模型可以最大程度地平衡安全性、灵活性和成本效益。</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-09-02.png\" alt=\"1.初识云计算与Openstack-2023-08-26-20-09-02\"></p>\n<h3 id=\"按服务类型分类\"><a href=\"#按服务类型分类\" class=\"headerlink\" title=\"按服务类型分类\"></a>按服务类型分类</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-00-39.jpg\" alt=\"1.初识云计算与Openstack-2023-08-26-20-00-39\"></p>\n<ol>\n<li><p>IaaS（Infrastructure as a Service–基础架构即服务）：<br>IaaS提供了基础的计算、存储和网络资源，用户可以在这些资源上构建和管理自己的应用环境。它为用户提供了虚拟化的计算资源，包括虚拟机、存储和网络连接。用户可以根据需要自主配置和管理操作系统、应用程序和数据。</p>\n<blockquote>\n<p>阿里云的ECS服务器，腾讯云的CVM服务器</p>\n</blockquote>\n</li>\n<li><p>PaaS（Platform as a Service–平台即服务）：<br>PaaS在IaaS的基础上提供了更高层次的服务，除了计算、存储和网络，还包括了开发和部署应用程序所需的平台环境。PaaS提供了开发工具、数据库、中间件和运行时环境等，使开发人员能够更专注于应用程序的开发而不必关心底层基础设施。</p>\n<blockquote>\n<p>阿里云的EDAS</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-31-49.png\" alt=\"1.初识云计算与Openstack-2023-08-26-16-31-49\"></p>\n</li>\n<li><p>SaaS（Software as a Service–软件即服务）：<br>SaaS提供完整的应用程序，用户通过互联网访问这些应用程序，无需安装和维护。SaaS应用程序由云服务提供商托管和维护，用户只需要通过浏览器或移动应用访问应用功能。</p>\n<blockquote>\n<p>微软的Microsoft 365，各种在线工具。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-32-26.png\" alt=\"1.初识云计算与Openstack-2023-08-26-16-32-26\"></p>\n<h2 id=\"OpenStack介绍\"><a href=\"#OpenStack介绍\" class=\"headerlink\" title=\"OpenStack介绍\"></a>OpenStack介绍</h2><p>OpenStack是一个自由、开源的云计算平台。它主要作为基础设施即服务（IaaS）部署在公用云和私有云中，提供虚拟服务器和其他资源给用户使用。该软件平台由相互关联的组件组成，控制着整个数据中心内不同的厂商的处理器、存储和网络资源的硬件池。用户可以通过基于网络的仪表盘、命令行工具或RESTful网络服务来管理。</p>\n<p>OpenStack始于2010年，是Rackspace和美国国家航空航天局的合作项目。截至2012年，它由2012年9月成立的非营利组织OpenStack基金会管理，旨在促进OpenStack软件及其社区。到2018年，已经有500多家公司加入了该项目。在2020年，该基金会宣布它将在2021年更名为Open Infrastructure Foundation（开放基础设施基金会）。</p>\n<h3 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h3><p>OpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行建立和提供云计算服务。</p>\n<p>此外，OpenStack也用作建立防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。</p>\n<h3 id=\"发展历程\"><a href=\"#发展历程\" class=\"headerlink\" title=\"发展历程\"></a>发展历程</h3><p>OpenStack每半年会发布一个版本，版本从字母A开始向后按顺序的命名；OpenStack社区为了方便描述，因此他们为每一个字母来进行投票，来选出一个单词。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-34-27.png\" alt=\"1.初识云计算与Openstack-2023-08-26-20-34-27\"></p>\n<h3 id=\"OpenStack架构\"><a href=\"#OpenStack架构\" class=\"headerlink\" title=\"OpenStack架构\"></a>OpenStack架构</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-59-40.png\" alt=\"1.初识云计算与Openstack-2023-08-26-21-59-40\"></p>\n<h4 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><ol>\n<li>Keystone： 身份认证服务，用于管理用户、项目和角色，并提供认证和授权功能。</li>\n<li>Nova： 计算服务，用于创建和管理虚拟机实例，提供计算资源。</li>\n<li>Neutron： 网络服务，提供网络资源的管理和连接，包括虚拟网络、子网、路由等。</li>\n<li>Glance： 镜像服务，用于管理虚拟机镜像，用户可以从镜像创建虚拟机实例。</li>\n<li>Placement： 该组件于OpenStack Stein版本引入，主要用于优化虚拟机实例的资源分配和调度。</li>\n</ol>\n<p>其他常用组件：</p>\n<ol>\n<li>Cinder： 块存储服务，提供虚拟机实例所需的持久性块存储，如挂载到虚拟机的卷。</li>\n<li>Swift： 对象存储服务，用于存储非结构化数据，如文件、图像和视频等。</li>\n<li>Horizon： Web 控制台，提供用户界面，用于管理和监控 OpenStack 系统。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-11-14.png\" alt=\"1.初识云计算与Openstack-2023-08-26-21-11-14\"></p>\n<blockquote>\n<p>OpenStack本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署。<br>这种分布式特性让OpenStack具备极大的灵活性、伸缩性和高可用性。</p>\n</blockquote>\n<h3 id=\"示例架构\"><a href=\"#示例架构\" class=\"headerlink\" title=\"示例架构\"></a>示例架构</h3><p>示例架构需要至少两个节点（主机）来启动基本虚拟机或实例。块存储和对象存储等可选服务需要额外的节点。</p>\n<p>基本两节点OpenStack部署示例：</p>\n<ol>\n<li><p>控制节点（Controller Node）： 这个节点承担了OpenStack核心服务的角色，例如Identity服务 (Keystone)、Dashboard服务 (Horizon)、Compute服务 (Nova API)、网络服务 (Neutron API) 等。这个节点管理OpenStack环境的整体状态。</p>\n</li>\n<li><p>计算节点（Compute Node）： 这个节点用于运行虚拟机实例。虚拟机的资源会在计算节点上分配和运行。它连接到控制节点以获取任务和指令，并与存储和网络资源进行交互。</p>\n</li>\n</ol>\n<blockquote>\n<p>这种配置适用于非常基本的测试、学习或演示用途，但在生产环境中，为了实现更高的性能、可用性和容错性，通常会使用更多的节点和组件。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-22-58-14.png\" alt=\"1.初识云计算与Openstack-2023-08-26-22-58-14\"></p>\n<h2 id=\"使用packstack部署OpenStack平台\"><a href=\"#使用packstack部署OpenStack平台\" class=\"headerlink\" title=\"使用packstack部署OpenStack平台\"></a>使用packstack部署OpenStack平台</h2><h3 id=\"资源清单\"><a href=\"#资源清单\" class=\"headerlink\" title=\"资源清单\"></a>资源清单</h3><table>\n<thead>\n<tr>\n<th>资源名称</th>\n<th>说明</th>\n<th>地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>openStack-train.iso</td>\n<td>Centos + OpenStack平台镜像</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"基础环境配置\"><a href=\"#基础环境配置\" class=\"headerlink\" title=\"基础环境配置\"></a>基础环境配置</h3><h4 id=\"节点规划\"><a href=\"#节点规划\" class=\"headerlink\" title=\"节点规划\"></a>节点规划</h4><table>\n<thead>\n<tr>\n<th>节点名称（主机名）</th>\n<th>外网网卡IP地址（网卡名：ens34）</th>\n<th>内网网卡IP地址（网卡名：ens33）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>controller</td>\n<td>192.168.20.10</td>\n<td>192.168.10.10</td>\n</tr>\n<tr>\n<td>compute</td>\n<td>192.168.20.20</td>\n<td>192.168.10.20</td>\n</tr>\n</tbody></table>\n<h4 id=\"利用快照快速恢复系统\"><a href=\"#利用快照快速恢复系统\" class=\"headerlink\" title=\"利用快照快速恢复系统\"></a>利用快照快速恢复系统</h4><ol>\n<li><p>控制节点虚拟机环境准备</p>\n<p>虚拟机列表中右键名为<code>控制节点</code>的虚拟机-&gt;快照-&gt;快照管理器，选中<code>项目2 系统安装完成</code>后转到并确认。此时虚拟机<code>控制节点</code>已恢复到系统安装完毕后的版本（利用快照管理器可以将虚拟机快速恢复到之前已经保存过的任意状态）。</p>\n<blockquote>\n<p>这一步创建好的系统ROOT账户密码<code>000000</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-27-20-43-21.png\" alt=\"1.初识云计算与Openstack-2023-08-27-20-43-21\"></p>\n</li>\n<li><p>计算节点虚拟机环境准备</p>\n<p>先关闭<code>控制节点</code>虚拟机，在虚拟机列表中右键名为<code>计算节点</code>的虚拟机-&gt;移除，右键<code>控制节点</code>虚拟机-&gt;管理-&gt;克隆，按照向导提示完成虚拟机克隆，克隆自虚拟机中的当前状态，克隆方法选择<code>完整克隆</code>，虚拟机名称设置为<code>计算节点</code>。</p>\n</li>\n</ol>\n<p>此时运行OpenStack所需的双节点系统环境已经创建完成，接下来做基础配置。</p>\n<h4 id=\"虚拟机网络配置\"><a href=\"#虚拟机网络配置\" class=\"headerlink\" title=\"虚拟机网络配置\"></a>虚拟机网络配置</h4><p>此步骤的配置需要在<code>控制节点</code>和<code>计算节点</code>上完成，每个节点分别有两个网卡需要配置：一个内网网卡和一个外网网卡。</p>\n<ol>\n<li><p>在编辑-&gt;虚拟网络编辑器可以为虚拟机配置桥接模式网络连接、NAT 和仅主机模式网络连接。</p>\n<ol>\n<li><p>桥接模式</p>\n<p>桥接模式网络连接通过使用主机系统上的网络适配器将虚拟机连接到网络。如果主机系统位于网络中，桥接模式网络连接通常是虚拟机访问该网络的最简单途径。</p>\n</li>\n<li><p>NAT模式</p>\n<p>使用 NAT 模式网络时，虚拟机在外部网络中不必具有自己的 IP 地址。主机系统上会建立单独的专用网络。在默认配置中，虚拟机会在此专用网络中通过 DHCP 服务器获取地址。虚拟机和主机系统共享一个网络标识，此标识在外部网络中不可见。</p>\n</li>\n<li><p>仅主机模式</p>\n<p>编辑-&gt;虚拟网络编辑器，右下角更改设置，按照<a href=\"#%E8%8A%82%E7%82%B9%E8%A7%84%E5%88%92\">节点规划</a>将<code>仅主机模式</code>和<code>NAT模式</code>配置为如下图。其中<code>仅主机模式</code>的子网地址为<code>192.168.10.0</code>，<code>NAT模式</code>的子网地址为<code>192.168.20.0</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-29-14-43-53.png\" alt=\"1.初识云计算与Openstack-2023-08-29-14-43-53\"></p>\n</li>\n</ol>\n</li>\n<li><p>启动<code>控制节点</code>虚拟机，在控制节点中使用如下命令编辑<code>网卡ens33</code>的配置文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vi</span> /etc/sysconfig/network-scripts/ifcfg-ens33<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>编辑文件如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>266c663e-d288-4d54-b100-00741dda6c70\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.10    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>ens33作为内网网口不需要配置默认网关。</p>\n</blockquote>\n<p>用相同的方法配置外网网卡<code>ens34</code>，配置如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>bf2fdda3-d6bf-4a72-953f-02cd83115887\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.10    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span>\n<span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.2    <span class=\"token comment\"># 5. 配置网关</span>\n<span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span><span class=\"token number\">114.114</span>.114.114    <span class=\"token comment\"># 6. 配置dns</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用命令<code>ifup + 网卡名</code>激活上一步修改的两个网卡配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens33</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens34</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用命令<code>ip addr</code>查看当前网卡配置：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ip addr</span>\n<span class=\"token number\">1</span>: lo: <span class=\"token operator\">&lt;</span>LOOPBACK,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class=\"token number\">1000</span>\n   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n   inet <span class=\"token number\">127.0</span>.0.1/8 scope <span class=\"token function\">host</span> lo\n      valid_lft forever preferred_lft forever\n   inet6 ::1/128 scope <span class=\"token function\">host</span>\n      valid_lft forever preferred_lft forever\n<span class=\"token number\">2</span>: ens33: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc pfifo_fast state UP group default qlen <span class=\"token number\">1000</span>\n   link/ether 00:0c:29:f2:ca:50 brd ff:ff:ff:ff:ff:ff\n   inet <span class=\"token number\">192.168</span>.10.10/24 brd <span class=\"token number\">192.168</span>.10.255 scope global noprefixroute ens33\n      valid_lft forever preferred_lft forever\n   inet6 fe80::922:6217:cb6c:e63/64 scope <span class=\"token function\">link</span> noprefixroute\n      valid_lft forever preferred_lft forever\n<span class=\"token number\">3</span>: ens34: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc pfifo_fast state UP group default qlen <span class=\"token number\">1000</span>\n   link/ether 00:0c:29:f2:ca:5a brd ff:ff:ff:ff:ff:ff\n   inet <span class=\"token number\">192.168</span>.20.10/24 brd <span class=\"token number\">192.168</span>.20.255 scope global noprefixroute ens34\n      valid_lft forever preferred_lft forever\n   inet6 fe80::9b23:9dcb:6af7:812d/64 scope <span class=\"token function\">link</span> noprefixroute\n      valid_lft forever preferred_lft forever <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用<code>ping</code>命令验证当前虚拟机网络</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">//验证内网网卡和宿主机之间的网络连通性\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ping -c3 -I ens33 192.168.10.1</span>\nPING <span class=\"token number\">192.168</span>.10.1 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.10.1<span class=\"token punctuation\">)</span> from <span class=\"token number\">192.168</span>.10.10 ens33: <span class=\"token number\">56</span><span class=\"token punctuation\">(</span><span class=\"token number\">84</span><span class=\"token punctuation\">)</span> bytes of data.\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">192.168</span>.10.1: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">0.154</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">192.168</span>.10.1: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">0.587</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">192.168</span>.10.1: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">3</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">0.461</span> ms <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">//验证外网网卡和外网资源的网络连通性\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ping -c3 -I ens34 www.baidu.com</span>\nPING www.a.shifen.com <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span> from <span class=\"token number\">192.168</span>.20.10 ens34: <span class=\"token number\">56</span><span class=\"token punctuation\">(</span><span class=\"token number\">84</span><span class=\"token punctuation\">)</span> bytes of data.\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">153.3</span>.238.110 <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span>: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">6.73</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">153.3</span>.238.110 <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span>: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">6.99</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">153.3</span>.238.110 <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span>: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">3</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">6.96</span> ms<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>启动<code>计算节点</code>虚拟机，上述步骤完成后用相同的方法在<code>计算节点</code>上完成网络配置，首先配置内网网卡<code>ens33</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vi</span> /etc/sysconfig/network-scripts/ifcfg-ens33<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>编辑文件如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>266c663e-d288-4d54-b100-00741dda6c70\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.20    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用相同的方法配置外网网卡<code>ens34</code>，配置如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>bf2fdda3-d6bf-4a72-953f-02cd83115887\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.20    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span>\n<span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.2    <span class=\"token comment\"># 5. 配置网关</span>\n<span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span><span class=\"token number\">114.114</span>.114.114    <span class=\"token comment\"># 6. 配置dns</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>使用命令<code>ifup + 网卡名</code>激活上一步修改的两个网卡配置  </p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifdown ens33</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifdown ens34</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens33</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens34</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>重复<code>步骤4</code>验证<code>计算节点</code>的网络配置</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>到目前为止网络配置完成，下一步开始配置本地yum源</p>\n<h4 id=\"配置本地YUM源、FTP服务、防火墙\"><a href=\"#配置本地YUM源、FTP服务、防火墙\" class=\"headerlink\" title=\"配置本地YUM源、FTP服务、防火墙\"></a>配置本地YUM源、FTP服务、防火墙</h4><ol>\n<li><p>这一步是加载<a href=\"#%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95\">资源清单</a>中列出的两个镜像源文件到虚拟机<code>控制节点</code>中。</p>\n<ul>\n<li><p>右键虚拟机<code>控制节点</code>-&gt;设置-&gt;选择已有的CD&#x2F;DVD驱动器-&gt;浏览，选择本地的<code>openStack-train.iso</code>文件后完成镜像的加载，同时勾选已连接。</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-28-20-13-50.png\" alt=\"1.初识云计算与Openstack-2023-08-28-20-13-50\"></p>\n</li>\n</ul>\n</li>\n<li><p>重启<code>控制节点</code>虚拟机，镜像加载到虚拟机<code>控制节点</code>后还需要挂载到系统目录下才能进行读取。</p>\n<ul>\n<li><p>首先创建挂载点，挂载驱动器中的镜像到指定目录</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir /opt/openstack    # 1. 创建挂载点</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mount /dev/sr0 /opt/openstack  # 3. 挂载openStack-train.iso镜像</span>\nmount: /dev/sr0 is write-protected, mounting read-only<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>挂载完成后<code>df -h</code>查看挂载情况</p>\n</blockquote>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">/dev/sr0                  16G   16G     <span class=\"token number\">0</span> <span class=\"token number\">100</span>% /opt/openstack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>这一步配置<code>控制节点</code>的YUM源，<code>控制节点</code>的源文件在本地。</p>\n<ul>\n<li><p>删除现有的配置文件</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># rm -rf /etc/yum.repos.d/*.repo</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>在<code>/etc/yum.repos.d</code>目录下创建配置文件<code>local.repo</code>，并添加以下配置：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">[base]\nname=base\nbaseurl=file:///opt/openstack/base/\ngpgcheck=0\nenabled=1\n[extras]\nname=extras\nbaseurl=file:///opt/openstack/extras/\ngpgcheck=0\nenabled=1\n[updates]\nname=updates\nbaseurl=file:///opt/openstack/updates/\ngpgcheck=0\nenabled=1\n[train]\nname=train\nbaseurl=file:///opt/openstack/train/\ngpgcheck=0\nenabled=1\n[virt]\nname=virt\nbaseurl=file:///opt/openstack/virt/\ngpgcheck=0\nenabled=1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>执行以下命令检查YUM源是否可用：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum clean all           # 1. 清除缓存</span>\nLoaded plugins: fastestmirror\nCleaning repos: base extras train updates virt\nCleaning up list of fastest mirrors\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum makecache           # 2. 重建缓存</span>\nLoaded plugins: fastestmirror\nDetermining fastest mirrors\nbase                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nextras                                                                                                                    <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\ntrain                                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nupdates                                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nvirt                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>/15<span class=\"token punctuation\">)</span>: base/primary_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">6.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span>/15<span class=\"token punctuation\">)</span>: base/filelists_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">7.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">3</span>/15<span class=\"token punctuation\">)</span>: base/other_db                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">4</span>/15<span class=\"token punctuation\">)</span>: extras/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">259</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">5</span>/15<span class=\"token punctuation\">)</span>: extras/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">145</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">6</span>/15<span class=\"token punctuation\">)</span>: extras/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">241</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">7</span>/15<span class=\"token punctuation\">)</span>: train/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">3.6</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">8</span>/15<span class=\"token punctuation\">)</span>: train/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">1.2</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">9</span>/15<span class=\"token punctuation\">)</span>: train/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">465</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">10</span>/15<span class=\"token punctuation\">)</span>: updates/filelists_db                                                                                             <span class=\"token operator\">|</span> <span class=\"token number\">6.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">11</span>/15<span class=\"token punctuation\">)</span>: updates/primary_db                                                                                               <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">12</span>/15<span class=\"token punctuation\">)</span>: updates/other_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">914</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">13</span>/15<span class=\"token punctuation\">)</span>: virt/filelists_db                                                                                                <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">14</span>/15<span class=\"token punctuation\">)</span>: virt/other_db                                                                                                    <span class=\"token operator\">|</span>  <span class=\"token number\">45</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">15</span>/15<span class=\"token punctuation\">)</span>: virt/primary_db                                                                                                  <span class=\"token operator\">|</span>  <span class=\"token number\">56</span> kB  00:00:00\nMetadata Cache Created\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum repolist            # 3. 查看仓库列表</span>\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\nrepo <span class=\"token function\">id</span>                                                              repo name                                                             status\nbase                                                                 base                                                                  <span class=\"token number\">10,039</span>\nextras                                                               extras                                                                   <span class=\"token number\">500</span>\ntrain                                                                train                                                                  <span class=\"token number\">3,168</span>\nupdates                                                              updates                                                                <span class=\"token number\">3,182</span>\nvirt                                                                 virt                                                                      <span class=\"token number\">63</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>到目前为止<code>控制节点</code>的YUM源配置完毕，最后在<code>控制节点</code>上设置域名解析、关闭防火墙、安装FTP服务器为<code>计算节点</code>提供服务</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># hostnamectl set-hostname controller  # 1. 修改主机名</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<blockquote>\n<p>修改完主机名后<code>ctrl + D</code>退出当前会话重新登录验证主机名设置是否生效。</p>\n</blockquote>\n<ul>\n<li><p>在<code>/etc/hosts</code>文件最后添加以下两行域名解析</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">192.168.10.10 controller\n192.168.10.20 compute<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>修改<code>/etc/selinux/config</code>文件中的<code>SELINUX=enforcing</code>为<code>SELINUX=disabled</code></p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>禁用SELinux和防火墙</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># setenforce 0                   # 1. 禁用SELinux</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl disable firewalld    # 2. 关闭开机启动防火墙</span>\nRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\nRemoved symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl stop firewalld       # 3. 立即关闭防火墙</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum remove -y NetworkManager   # 4. 卸载网络管理器</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>安装配置deltarpm来兼容packstack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum -y install deltarpm</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/yum.conf</code>文件中加一行禁用deltarpm</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># echo \"deltarpm=0\" >>/etc/yum.conf</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>安装配置FTP服务端</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum -y install vsftpd       # 1. 安装ftp服务端</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/vsftpd/vsftpd.conf</code>文件中加入一行<code>anon_root=/opt</code>，设置匿名用户访问的根目录为YUM源所挂载的目录</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl start vsftpd      # 1. 立刻启动FTP服务端</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl enable vsftpd     # 2. 设置开机启动</span>\nCreated symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>配置<code>iptables</code>允许ftp服务的20&#x2F;21端口</p>\n<ol>\n<li><p>编辑文件 <code>/etc/sysconfig/iptables-config</code> ，设置第6行<code>IPTABLES_MODULES=</code>值为<code>ip_conntrack_ftp</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">IPTABLES_MODULES</span><span class=\"token operator\">=</span><span class=\"token string\">\"ip_conntrack_ftp\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>编辑文件<code>/etc/sysconfig/iptables</code>添加两行规则</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables -L</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables-save > /etc/sysconfig/iptables</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>这一步配置<code>计算节点</code>的YUM源，通过FTP服务访问挂载到<code>控制节点</code>的源文件。</p>\n<ul>\n<li><p>修改<code>计算节点</code>的主机名</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># hostnamectl set-hostname compute  # 1. 修改主机名</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>在<code>/etc/hosts</code>文件最后添加以下两行域名解析</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">192.168.10.10 controller\n192.168.10.20 compute<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>修改<code>/etc/selinux/config</code>文件中的<code>SELINUX=enforcing</code>为<code>SELINUX=disabled</code></p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>禁用SELinux和防火墙</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># setenforce 0                   # 1. 禁用SELinux</span>\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl disable firewalld    # 2. 关闭开机启动防火墙</span>\nRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\nRemoved symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl stop firewalld       # 3. 立即关闭防火墙</span>\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum remove -y NetworkManager   # 4. 卸载网络管理器</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除已有配置文件</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># rm -rf /etc/yum.repos.d/*.repo</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/yum.repos.d</code>目录下创建配置文件<code>local.repo</code>，并添加以下配置：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">[base]\nname=base\nbaseurl=ftp://controller/openstack/base/\ngpgcheck=0\nenabled=1\n[extras]\nname=extras\nbaseurl=ftp://controller/openstack/extras/\ngpgcheck=0\nenabled=1\n[updates]\nname=updates\nbaseurl=ftp://controller/openstack/updates/\ngpgcheck=0\nenabled=1\n[train]\nname=train\nbaseurl=ftp://controller/openstack/train/\ngpgcheck=0\nenabled=1\n[virt]\nname=virt\nbaseurl=ftp://controller/openstack/virt/\ngpgcheck=0\nenabled=1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>执行以下命令检查YUM源是否可用：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum clean all           # 1. 清除缓存</span>\nLoaded plugins: fastestmirror\nCleaning repos: base extras train updates virt\nRepository base is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository extras is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository updates is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nCleaning up list of fastest mirrors\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum makecache         # 2. 重建缓存</span>\nLoaded plugins: fastestmirror\nRepository base is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository extras is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository updates is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nDetermining fastest mirrors\n* base: mirrors.aliyun.com\n* extras: mirrors.aliyun.com\n* updates: mirrors.aliyun.com\nbase                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">3.6</span> kB  00:00:00\nextras                                                                                                                    <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\ntrain                                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nupdates                                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nvirt                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>/15<span class=\"token punctuation\">)</span>: base/primary_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">6.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span>/15<span class=\"token punctuation\">)</span>: base/filelists_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">7.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">3</span>/15<span class=\"token punctuation\">)</span>: base/other_db                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">4</span>/15<span class=\"token punctuation\">)</span>: extras/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">259</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">5</span>/15<span class=\"token punctuation\">)</span>: extras/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">145</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">6</span>/15<span class=\"token punctuation\">)</span>: extras/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">241</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">7</span>/15<span class=\"token punctuation\">)</span>: train/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">3.6</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">8</span>/15<span class=\"token punctuation\">)</span>: train/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">1.2</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">9</span>/15<span class=\"token punctuation\">)</span>: train/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">465</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">10</span>/15<span class=\"token punctuation\">)</span>: updates/filelists_db                                                                                             <span class=\"token operator\">|</span> <span class=\"token number\">6.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">11</span>/15<span class=\"token punctuation\">)</span>: updates/primary_db                                                                                               <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">12</span>/15<span class=\"token punctuation\">)</span>: updates/other_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">914</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">13</span>/15<span class=\"token punctuation\">)</span>: virt/filelists_db                                                                                                <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">14</span>/15<span class=\"token punctuation\">)</span>: virt/other_db                                                                                                    <span class=\"token operator\">|</span>  <span class=\"token number\">45</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">15</span>/15<span class=\"token punctuation\">)</span>: virt/primary_db                                                                                                  <span class=\"token operator\">|</span>  <span class=\"token number\">56</span> kB  00:00:00\nMetadata Cache Created\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum repolist          # 3. 查看仓库列表</span>\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\nrepo <span class=\"token function\">id</span>                                                              repo name                                                             status\nbase                                                                 base                                                                  <span class=\"token number\">10,039</span>\nextras                                                               extras                                                                   <span class=\"token number\">500</span>\ntrain                                                                train                                                                  <span class=\"token number\">3,168</span>\nupdates                                                              updates                                                                <span class=\"token number\">3,182</span>\nvirt                                                                 virt                                                                      <span class=\"token number\">63</span>\nrepolist: <span class=\"token number\">17,906</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>安装配置deltarpm来兼容packstack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum -y install deltarpm</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/yum.conf</code>文件中加一行禁用deltarpm</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># echo \"deltarpm=0\" >>/etc/yum.conf</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"安装OpenStack平台\"><a href=\"#安装OpenStack平台\" class=\"headerlink\" title=\"安装OpenStack平台\"></a>安装OpenStack平台</h3><ul>\n<li><p>在控制节点安装packstack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum install -y openstack-packstack</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>生成配置文件</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># packstack --gen-answer-file=openstack.txt --os-neutron-l2-agent=openvswitch --os-neutron-ml2-mechanism-drivers=openvswitch --os-neutron-ml2-tenant-network-types=vxlan --os-neutron-ml2-type-drivers=vxlan,flat --provision-demo=n --os-neutron-ovs-bridge-mappings=extnet:br-ex --os-neutron-ovs-bridge-interfaces=br-ex:ens34</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>修改配置文件中的IP地址为内网IP</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/192.168.20.10/192.168.10.10/g' openstack.txt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 修改文件<code>openstack.txt</code>中计算机点的IP</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/CONFIG_COMPUTE_HOSTS=.*/CONFIG_COMPUTE_HOSTS=192.168.10.20/g' openstack.txt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>开始安装OpenStack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">packstack --answer-file<span class=\"token operator\">=</span>openstack.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> packstack运行结束后如下图</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-31-01-28-23.png\" alt=\"1.初识云计算与Openstack-2023-08-31-01-28-23\"></p>\n</li>\n<li><p>登录OpenStack平台</p>\n<p> 接下来可以通过预先配置的网址<a href=\"http://192.168.10.10/dashboard\">http://192.168.10.10/dashboard</a>访问OpenStack平台</p>\n<p> 账户信息通过<code>cat keystonerc_admin</code>查看</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"传统的计算模式\"><a href=\"#传统的计算模式\" class=\"headerlink\" title=\"传统的计算模式\"></a>传统的计算模式</h2><h3 id=\"计算机系统结构\"><a href=\"#计算机系统结构\" class=\"headerlink\" title=\"计算机系统结构\"></a>计算机系统结构</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-25-22-09-05.png\" alt=\"1.初识云计算与Openstack-2023-08-25-22-09-05\"></p>\n<p>传统的计算模式是指企业或个人在自己的本地环境中构建、管理和维护硬件设备、操作系统和应用程序，以满足其计算和存储需求。</p>\n<blockquote>\n<p>对于个人用户的场景：需要搭建服务或者使用Linux系统环境时，我们往往需要在本地计算机上搭建虚拟机或者单独购买一套硬件来实现。<br>对于企业用户的场景：需要对内向员工提供项目管理等等办公服务、对外向用户提供web服务，数据库服务等等，同样需要在企业内部通过搭建数据中心来实现。</p>\n</blockquote>\n<ul>\n<li>需要购买和维护物理硬件设备，同时需要专业的IT团队来管理硬件和软件设施。（成本过高）</li>\n<li>资源利用率可能不高，硬件设备难以进行快速的资源分配和释放。（企业达到一定规模后难以适应多变的需求）</li>\n<li>扩展时需要购买更多硬件，时间和成本较高。（扩展性差）</li>\n<li>需要考虑容灾和高可用性，可能需要复杂的架构设计。（安全性需要得到保障）</li>\n</ul>\n<h2 id=\"云计算的概念\"><a href=\"#云计算的概念\" class=\"headerlink\" title=\"云计算的概念\"></a>云计算的概念</h2><p><strong>云计算的定义：</strong> 云计算是一种按使用量付费的模式，它可以实现随时随地，便捷地，随需应变地从可配置计算资源共享池中获取所需的资源（例如，网络、服务器、存储、应用、及服务），资源能够快速供应并释放，使管理资源的工作量和与服务提供商的交互减小到最低限度。</p>\n<blockquote>\n<p>和传统模式特点比较</p>\n</blockquote>\n<p><strong>资源池化：</strong> 传统的虚拟化技术是将单个服务器硬件虚拟成多个虚拟机，其目的也是在于提高服务器资源的利用率。但是，由于单个服务器的CPU、内存、硬盘资源颗粒度较小，因此在虚拟化应用中，经常出现资源配置空洞，要么是CPU核数没有分配完，要么是内存没有分配完，更多的情况是硬盘容量存在大量空闲。而服务器资源池化可以更好的解决上述问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-14-41-36.jpg\" alt=\"1.初识云计算与Openstack-2023-08-26-14-41-36\"></p>\n<h2 id=\"云计算的特点\"><a href=\"#云计算的特点\" class=\"headerlink\" title=\"云计算的特点\"></a>云计算的特点</h2><ol>\n<li>资源池化：云计算中的资源（如计算能力、存储、网络等）被集中管理并池化，供多个用户共享。这种资源的共享和动态分配提高了资源的利用率。</li>\n<li>按需分配： 用户可以根据自己的需求，自主地获取和配置计算资源，无需人工干预。这种自服务模式使用户能够快速获取所需资源，提高了效率。</li>\n<li>快速弹性扩展： 用户可以根据需要快速扩展或缩减资源，以适应业务的变化。这种弹性特性允许用户在高峰时段获得更多资源，而在低谷时段释放资源。</li>\n<li>可用性和容灾性：许多云服务提供商提供高可用性和容灾选项，确保服务在故障时能够持续运行，减少了业务中断的风险。</li>\n</ol>\n<blockquote>\n<p>按需分配、按量付费，各种计费方式；可扩展一方面使得上云的应用能够根据不同时段的业务需求动态调整资源另一方面，企业可以在不停机的情况下增加任意资源；可用性使得服务器出现故障时会无缝切换到资源池上的其他资源，不管是计算资源还是存储设备都能保证24小时不间断提供服务。<br>基于以上特点总结：用户不需要为应用单独购买服务器、同时不需要付出管理成本，只需要付出租用的成本就可以使用到随时能够扩容的并且有专业人员维护以保障安全的计算服务。</p>\n</blockquote>\n<h2 id=\"云计算的分类\"><a href=\"#云计算的分类\" class=\"headerlink\" title=\"云计算的分类\"></a>云计算的分类</h2><h3 id=\"按服务对象或者运营模式分类\"><a href=\"#按服务对象或者运营模式分类\" class=\"headerlink\" title=\"按服务对象或者运营模式分类\"></a>按服务对象或者运营模式分类</h3><ol>\n<li><p>公有云：“公有”反映了这类云服务并非用户所拥有，公有云是面向大众提供计算资源的服务。是由第三方云服务提供商提供资源，如应用和存储，这些资源是在服务商的场所内部署。用户通过Internet互联网来获取这些资源的使用。<br>公有云的优势是成本低，扩展性非常好。缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能问题。<br>规模最大的几个公有云厂商：阿里云、Amazon Web Services（AWS）、Google Cloud</p>\n</li>\n<li><p>私有云：“私有”更多是指此类平台属于非共享资源，而非指其安全优势。私有云是为了一个客户单独使用而构建的，所以这些数据、安全和服务质量都较公有云有着更好地保障。<br>在私有云模式中，云平台的资源为包含多个用户的单一组织专用。私有云可由该组织、第三方或两者联合拥有、管理和运营。私有云的部署场所可以是在机构内部，也可以在外部。</p>\n</li>\n<li><p>混合云：混合云结合了公有云和私有云的特点，允许数据和应用在这两者之间流动。组织可以在私有云中部署敏感数据或关键业务应用，同时利用公有云的弹性来处理突发业务需求。混合云模型可以最大程度地平衡安全性、灵活性和成本效益。</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-09-02.png\" alt=\"1.初识云计算与Openstack-2023-08-26-20-09-02\"></p>\n<h3 id=\"按服务类型分类\"><a href=\"#按服务类型分类\" class=\"headerlink\" title=\"按服务类型分类\"></a>按服务类型分类</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-00-39.jpg\" alt=\"1.初识云计算与Openstack-2023-08-26-20-00-39\"></p>\n<ol>\n<li><p>IaaS（Infrastructure as a Service–基础架构即服务）：<br>IaaS提供了基础的计算、存储和网络资源，用户可以在这些资源上构建和管理自己的应用环境。它为用户提供了虚拟化的计算资源，包括虚拟机、存储和网络连接。用户可以根据需要自主配置和管理操作系统、应用程序和数据。</p>\n<blockquote>\n<p>阿里云的ECS服务器，腾讯云的CVM服务器</p>\n</blockquote>\n</li>\n<li><p>PaaS（Platform as a Service–平台即服务）：<br>PaaS在IaaS的基础上提供了更高层次的服务，除了计算、存储和网络，还包括了开发和部署应用程序所需的平台环境。PaaS提供了开发工具、数据库、中间件和运行时环境等，使开发人员能够更专注于应用程序的开发而不必关心底层基础设施。</p>\n<blockquote>\n<p>阿里云的EDAS</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-31-49.png\" alt=\"1.初识云计算与Openstack-2023-08-26-16-31-49\"></p>\n</li>\n<li><p>SaaS（Software as a Service–软件即服务）：<br>SaaS提供完整的应用程序，用户通过互联网访问这些应用程序，无需安装和维护。SaaS应用程序由云服务提供商托管和维护，用户只需要通过浏览器或移动应用访问应用功能。</p>\n<blockquote>\n<p>微软的Microsoft 365，各种在线工具。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-16-32-26.png\" alt=\"1.初识云计算与Openstack-2023-08-26-16-32-26\"></p>\n<h2 id=\"OpenStack介绍\"><a href=\"#OpenStack介绍\" class=\"headerlink\" title=\"OpenStack介绍\"></a>OpenStack介绍</h2><p>OpenStack是一个自由、开源的云计算平台。它主要作为基础设施即服务（IaaS）部署在公用云和私有云中，提供虚拟服务器和其他资源给用户使用。该软件平台由相互关联的组件组成，控制着整个数据中心内不同的厂商的处理器、存储和网络资源的硬件池。用户可以通过基于网络的仪表盘、命令行工具或RESTful网络服务来管理。</p>\n<p>OpenStack始于2010年，是Rackspace和美国国家航空航天局的合作项目。截至2012年，它由2012年9月成立的非营利组织OpenStack基金会管理，旨在促进OpenStack软件及其社区。到2018年，已经有500多家公司加入了该项目。在2020年，该基金会宣布它将在2021年更名为Open Infrastructure Foundation（开放基础设施基金会）。</p>\n<h3 id=\"适用范围\"><a href=\"#适用范围\" class=\"headerlink\" title=\"适用范围\"></a>适用范围</h3><p>OpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行建立和提供云计算服务。</p>\n<p>此外，OpenStack也用作建立防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。</p>\n<h3 id=\"发展历程\"><a href=\"#发展历程\" class=\"headerlink\" title=\"发展历程\"></a>发展历程</h3><p>OpenStack每半年会发布一个版本，版本从字母A开始向后按顺序的命名；OpenStack社区为了方便描述，因此他们为每一个字母来进行投票，来选出一个单词。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-20-34-27.png\" alt=\"1.初识云计算与Openstack-2023-08-26-20-34-27\"></p>\n<h3 id=\"OpenStack架构\"><a href=\"#OpenStack架构\" class=\"headerlink\" title=\"OpenStack架构\"></a>OpenStack架构</h3><p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-59-40.png\" alt=\"1.初识云计算与Openstack-2023-08-26-21-59-40\"></p>\n<h4 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h4><ol>\n<li>Keystone： 身份认证服务，用于管理用户、项目和角色，并提供认证和授权功能。</li>\n<li>Nova： 计算服务，用于创建和管理虚拟机实例，提供计算资源。</li>\n<li>Neutron： 网络服务，提供网络资源的管理和连接，包括虚拟网络、子网、路由等。</li>\n<li>Glance： 镜像服务，用于管理虚拟机镜像，用户可以从镜像创建虚拟机实例。</li>\n<li>Placement： 该组件于OpenStack Stein版本引入，主要用于优化虚拟机实例的资源分配和调度。</li>\n</ol>\n<p>其他常用组件：</p>\n<ol>\n<li>Cinder： 块存储服务，提供虚拟机实例所需的持久性块存储，如挂载到虚拟机的卷。</li>\n<li>Swift： 对象存储服务，用于存储非结构化数据，如文件、图像和视频等。</li>\n<li>Horizon： Web 控制台，提供用户界面，用于管理和监控 OpenStack 系统。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-21-11-14.png\" alt=\"1.初识云计算与Openstack-2023-08-26-21-11-14\"></p>\n<blockquote>\n<p>OpenStack本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署。<br>这种分布式特性让OpenStack具备极大的灵活性、伸缩性和高可用性。</p>\n</blockquote>\n<h3 id=\"示例架构\"><a href=\"#示例架构\" class=\"headerlink\" title=\"示例架构\"></a>示例架构</h3><p>示例架构需要至少两个节点（主机）来启动基本虚拟机或实例。块存储和对象存储等可选服务需要额外的节点。</p>\n<p>基本两节点OpenStack部署示例：</p>\n<ol>\n<li><p>控制节点（Controller Node）： 这个节点承担了OpenStack核心服务的角色，例如Identity服务 (Keystone)、Dashboard服务 (Horizon)、Compute服务 (Nova API)、网络服务 (Neutron API) 等。这个节点管理OpenStack环境的整体状态。</p>\n</li>\n<li><p>计算节点（Compute Node）： 这个节点用于运行虚拟机实例。虚拟机的资源会在计算节点上分配和运行。它连接到控制节点以获取任务和指令，并与存储和网络资源进行交互。</p>\n</li>\n</ol>\n<blockquote>\n<p>这种配置适用于非常基本的测试、学习或演示用途，但在生产环境中，为了实现更高的性能、可用性和容错性，通常会使用更多的节点和组件。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-26-22-58-14.png\" alt=\"1.初识云计算与Openstack-2023-08-26-22-58-14\"></p>\n<h2 id=\"使用packstack部署OpenStack平台\"><a href=\"#使用packstack部署OpenStack平台\" class=\"headerlink\" title=\"使用packstack部署OpenStack平台\"></a>使用packstack部署OpenStack平台</h2><h3 id=\"资源清单\"><a href=\"#资源清单\" class=\"headerlink\" title=\"资源清单\"></a>资源清单</h3><table>\n<thead>\n<tr>\n<th>资源名称</th>\n<th>说明</th>\n<th>地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>openStack-train.iso</td>\n<td>Centos + OpenStack平台镜像</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"基础环境配置\"><a href=\"#基础环境配置\" class=\"headerlink\" title=\"基础环境配置\"></a>基础环境配置</h3><h4 id=\"节点规划\"><a href=\"#节点规划\" class=\"headerlink\" title=\"节点规划\"></a>节点规划</h4><table>\n<thead>\n<tr>\n<th>节点名称（主机名）</th>\n<th>外网网卡IP地址（网卡名：ens34）</th>\n<th>内网网卡IP地址（网卡名：ens33）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>controller</td>\n<td>192.168.20.10</td>\n<td>192.168.10.10</td>\n</tr>\n<tr>\n<td>compute</td>\n<td>192.168.20.20</td>\n<td>192.168.10.20</td>\n</tr>\n</tbody></table>\n<h4 id=\"利用快照快速恢复系统\"><a href=\"#利用快照快速恢复系统\" class=\"headerlink\" title=\"利用快照快速恢复系统\"></a>利用快照快速恢复系统</h4><ol>\n<li><p>控制节点虚拟机环境准备</p>\n<p>虚拟机列表中右键名为<code>控制节点</code>的虚拟机-&gt;快照-&gt;快照管理器，选中<code>项目2 系统安装完成</code>后转到并确认。此时虚拟机<code>控制节点</code>已恢复到系统安装完毕后的版本（利用快照管理器可以将虚拟机快速恢复到之前已经保存过的任意状态）。</p>\n<blockquote>\n<p>这一步创建好的系统ROOT账户密码<code>000000</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-27-20-43-21.png\" alt=\"1.初识云计算与Openstack-2023-08-27-20-43-21\"></p>\n</li>\n<li><p>计算节点虚拟机环境准备</p>\n<p>先关闭<code>控制节点</code>虚拟机，在虚拟机列表中右键名为<code>计算节点</code>的虚拟机-&gt;移除，右键<code>控制节点</code>虚拟机-&gt;管理-&gt;克隆，按照向导提示完成虚拟机克隆，克隆自虚拟机中的当前状态，克隆方法选择<code>完整克隆</code>，虚拟机名称设置为<code>计算节点</code>。</p>\n</li>\n</ol>\n<p>此时运行OpenStack所需的双节点系统环境已经创建完成，接下来做基础配置。</p>\n<h4 id=\"虚拟机网络配置\"><a href=\"#虚拟机网络配置\" class=\"headerlink\" title=\"虚拟机网络配置\"></a>虚拟机网络配置</h4><p>此步骤的配置需要在<code>控制节点</code>和<code>计算节点</code>上完成，每个节点分别有两个网卡需要配置：一个内网网卡和一个外网网卡。</p>\n<ol>\n<li><p>在编辑-&gt;虚拟网络编辑器可以为虚拟机配置桥接模式网络连接、NAT 和仅主机模式网络连接。</p>\n<ol>\n<li><p>桥接模式</p>\n<p>桥接模式网络连接通过使用主机系统上的网络适配器将虚拟机连接到网络。如果主机系统位于网络中，桥接模式网络连接通常是虚拟机访问该网络的最简单途径。</p>\n</li>\n<li><p>NAT模式</p>\n<p>使用 NAT 模式网络时，虚拟机在外部网络中不必具有自己的 IP 地址。主机系统上会建立单独的专用网络。在默认配置中，虚拟机会在此专用网络中通过 DHCP 服务器获取地址。虚拟机和主机系统共享一个网络标识，此标识在外部网络中不可见。</p>\n</li>\n<li><p>仅主机模式</p>\n<p>编辑-&gt;虚拟网络编辑器，右下角更改设置，按照<a href=\"#%E8%8A%82%E7%82%B9%E8%A7%84%E5%88%92\">节点规划</a>将<code>仅主机模式</code>和<code>NAT模式</code>配置为如下图。其中<code>仅主机模式</code>的子网地址为<code>192.168.10.0</code>，<code>NAT模式</code>的子网地址为<code>192.168.20.0</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-29-14-43-53.png\" alt=\"1.初识云计算与Openstack-2023-08-29-14-43-53\"></p>\n</li>\n</ol>\n</li>\n<li><p>启动<code>控制节点</code>虚拟机，在控制节点中使用如下命令编辑<code>网卡ens33</code>的配置文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vi</span> /etc/sysconfig/network-scripts/ifcfg-ens33<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>编辑文件如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>266c663e-d288-4d54-b100-00741dda6c70\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.10    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>ens33作为内网网口不需要配置默认网关。</p>\n</blockquote>\n<p>用相同的方法配置外网网卡<code>ens34</code>，配置如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>bf2fdda3-d6bf-4a72-953f-02cd83115887\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.10    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span>\n<span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.2    <span class=\"token comment\"># 5. 配置网关</span>\n<span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span><span class=\"token number\">114.114</span>.114.114    <span class=\"token comment\"># 6. 配置dns</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用命令<code>ifup + 网卡名</code>激活上一步修改的两个网卡配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens33</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens34</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用命令<code>ip addr</code>查看当前网卡配置：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ip addr</span>\n<span class=\"token number\">1</span>: lo: <span class=\"token operator\">&lt;</span>LOOPBACK,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class=\"token number\">1000</span>\n   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n   inet <span class=\"token number\">127.0</span>.0.1/8 scope <span class=\"token function\">host</span> lo\n      valid_lft forever preferred_lft forever\n   inet6 ::1/128 scope <span class=\"token function\">host</span>\n      valid_lft forever preferred_lft forever\n<span class=\"token number\">2</span>: ens33: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc pfifo_fast state UP group default qlen <span class=\"token number\">1000</span>\n   link/ether 00:0c:29:f2:ca:50 brd ff:ff:ff:ff:ff:ff\n   inet <span class=\"token number\">192.168</span>.10.10/24 brd <span class=\"token number\">192.168</span>.10.255 scope global noprefixroute ens33\n      valid_lft forever preferred_lft forever\n   inet6 fe80::922:6217:cb6c:e63/64 scope <span class=\"token function\">link</span> noprefixroute\n      valid_lft forever preferred_lft forever\n<span class=\"token number\">3</span>: ens34: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc pfifo_fast state UP group default qlen <span class=\"token number\">1000</span>\n   link/ether 00:0c:29:f2:ca:5a brd ff:ff:ff:ff:ff:ff\n   inet <span class=\"token number\">192.168</span>.20.10/24 brd <span class=\"token number\">192.168</span>.20.255 scope global noprefixroute ens34\n      valid_lft forever preferred_lft forever\n   inet6 fe80::9b23:9dcb:6af7:812d/64 scope <span class=\"token function\">link</span> noprefixroute\n      valid_lft forever preferred_lft forever <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用<code>ping</code>命令验证当前虚拟机网络</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">//验证内网网卡和宿主机之间的网络连通性\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ping -c3 -I ens33 192.168.10.1</span>\nPING <span class=\"token number\">192.168</span>.10.1 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.10.1<span class=\"token punctuation\">)</span> from <span class=\"token number\">192.168</span>.10.10 ens33: <span class=\"token number\">56</span><span class=\"token punctuation\">(</span><span class=\"token number\">84</span><span class=\"token punctuation\">)</span> bytes of data.\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">192.168</span>.10.1: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">0.154</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">192.168</span>.10.1: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">0.587</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">192.168</span>.10.1: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">3</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">0.461</span> ms <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">//验证外网网卡和外网资源的网络连通性\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ping -c3 -I ens34 www.baidu.com</span>\nPING www.a.shifen.com <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span> from <span class=\"token number\">192.168</span>.20.10 ens34: <span class=\"token number\">56</span><span class=\"token punctuation\">(</span><span class=\"token number\">84</span><span class=\"token punctuation\">)</span> bytes of data.\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">153.3</span>.238.110 <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span>: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">6.73</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">153.3</span>.238.110 <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span>: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">6.99</span> ms\n<span class=\"token number\">64</span> bytes from <span class=\"token number\">153.3</span>.238.110 <span class=\"token punctuation\">(</span><span class=\"token number\">153.3</span>.238.110<span class=\"token punctuation\">)</span>: <span class=\"token assign-left variable\">icmp_seq</span><span class=\"token operator\">=</span><span class=\"token number\">3</span> <span class=\"token assign-left variable\">ttl</span><span class=\"token operator\">=</span><span class=\"token number\">128</span> <span class=\"token assign-left variable\">time</span><span class=\"token operator\">=</span><span class=\"token number\">6.96</span> ms<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>启动<code>计算节点</code>虚拟机，上述步骤完成后用相同的方法在<code>计算节点</code>上完成网络配置，首先配置内网网卡<code>ens33</code>：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vi</span> /etc/sysconfig/network-scripts/ifcfg-ens33<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>编辑文件如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>266c663e-d288-4d54-b100-00741dda6c70\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens33\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.10.20    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用相同的方法配置外网网卡<code>ens34</code>，配置如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">TYPE</span><span class=\"token operator\">=</span>Ethernet\n<span class=\"token assign-left variable\">PROXY_METHOD</span><span class=\"token operator\">=</span>none\n<span class=\"token assign-left variable\">BROWSER_ONLY</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">BOOTPROTO</span><span class=\"token operator\">=</span>static        <span class=\"token comment\"># 1. 配置静态分配ip</span>\n<span class=\"token assign-left variable\">DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV4_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6INIT</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_AUTOCONF</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_DEFROUTE</span><span class=\"token operator\">=</span>yes\n<span class=\"token assign-left variable\">IPV6_FAILURE_FATAL</span><span class=\"token operator\">=</span>no\n<span class=\"token assign-left variable\">IPV6_ADDR_GEN_MODE</span><span class=\"token operator\">=</span>stable-privacy\n<span class=\"token assign-left variable\">NAME</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">UUID</span><span class=\"token operator\">=</span>bf2fdda3-d6bf-4a72-953f-02cd83115887\n<span class=\"token assign-left variable\">DEVICE</span><span class=\"token operator\">=</span>ens34\n<span class=\"token assign-left variable\">ONBOOT</span><span class=\"token operator\">=</span>yes              <span class=\"token comment\"># 2. 配置开机激活网卡</span>\n<span class=\"token assign-left variable\">IPADDR</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.20    <span class=\"token comment\"># 3. 配置ip地址</span>\n<span class=\"token assign-left variable\">NETMASK</span><span class=\"token operator\">=</span><span class=\"token number\">255.255</span>.255.0   <span class=\"token comment\"># 4. 配置子网掩码</span>\n<span class=\"token assign-left variable\">GATEWAY</span><span class=\"token operator\">=</span><span class=\"token number\">192.168</span>.20.2    <span class=\"token comment\"># 5. 配置网关</span>\n<span class=\"token assign-left variable\">DNS1</span><span class=\"token operator\">=</span><span class=\"token number\">114.114</span>.114.114    <span class=\"token comment\"># 6. 配置dns</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>使用命令<code>ifup + 网卡名</code>激活上一步修改的两个网卡配置  </p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifdown ens33</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifdown ens34</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens33</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># ifup ens34</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>重复<code>步骤4</code>验证<code>计算节点</code>的网络配置</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>到目前为止网络配置完成，下一步开始配置本地yum源</p>\n<h4 id=\"配置本地YUM源、FTP服务、防火墙\"><a href=\"#配置本地YUM源、FTP服务、防火墙\" class=\"headerlink\" title=\"配置本地YUM源、FTP服务、防火墙\"></a>配置本地YUM源、FTP服务、防火墙</h4><ol>\n<li><p>这一步是加载<a href=\"#%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95\">资源清单</a>中列出的两个镜像源文件到虚拟机<code>控制节点</code>中。</p>\n<ul>\n<li><p>右键虚拟机<code>控制节点</code>-&gt;设置-&gt;选择已有的CD&#x2F;DVD驱动器-&gt;浏览，选择本地的<code>openStack-train.iso</code>文件后完成镜像的加载，同时勾选已连接。</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-28-20-13-50.png\" alt=\"1.初识云计算与Openstack-2023-08-28-20-13-50\"></p>\n</li>\n</ul>\n</li>\n<li><p>重启<code>控制节点</code>虚拟机，镜像加载到虚拟机<code>控制节点</code>后还需要挂载到系统目录下才能进行读取。</p>\n<ul>\n<li><p>首先创建挂载点，挂载驱动器中的镜像到指定目录</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir /opt/openstack    # 1. 创建挂载点</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span>\n<span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mount /dev/sr0 /opt/openstack  # 3. 挂载openStack-train.iso镜像</span>\nmount: /dev/sr0 is write-protected, mounting read-only<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>挂载完成后<code>df -h</code>查看挂载情况</p>\n</blockquote>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">/dev/sr0                  16G   16G     <span class=\"token number\">0</span> <span class=\"token number\">100</span>% /opt/openstack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n<li><p>这一步配置<code>控制节点</code>的YUM源，<code>控制节点</code>的源文件在本地。</p>\n<ul>\n<li><p>删除现有的配置文件</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># rm -rf /etc/yum.repos.d/*.repo</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>在<code>/etc/yum.repos.d</code>目录下创建配置文件<code>local.repo</code>，并添加以下配置：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">[base]\nname=base\nbaseurl=file:///opt/openstack/base/\ngpgcheck=0\nenabled=1\n[extras]\nname=extras\nbaseurl=file:///opt/openstack/extras/\ngpgcheck=0\nenabled=1\n[updates]\nname=updates\nbaseurl=file:///opt/openstack/updates/\ngpgcheck=0\nenabled=1\n[train]\nname=train\nbaseurl=file:///opt/openstack/train/\ngpgcheck=0\nenabled=1\n[virt]\nname=virt\nbaseurl=file:///opt/openstack/virt/\ngpgcheck=0\nenabled=1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>执行以下命令检查YUM源是否可用：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum clean all           # 1. 清除缓存</span>\nLoaded plugins: fastestmirror\nCleaning repos: base extras train updates virt\nCleaning up list of fastest mirrors\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum makecache           # 2. 重建缓存</span>\nLoaded plugins: fastestmirror\nDetermining fastest mirrors\nbase                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nextras                                                                                                                    <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\ntrain                                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nupdates                                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nvirt                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>/15<span class=\"token punctuation\">)</span>: base/primary_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">6.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span>/15<span class=\"token punctuation\">)</span>: base/filelists_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">7.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">3</span>/15<span class=\"token punctuation\">)</span>: base/other_db                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">4</span>/15<span class=\"token punctuation\">)</span>: extras/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">259</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">5</span>/15<span class=\"token punctuation\">)</span>: extras/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">145</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">6</span>/15<span class=\"token punctuation\">)</span>: extras/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">241</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">7</span>/15<span class=\"token punctuation\">)</span>: train/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">3.6</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">8</span>/15<span class=\"token punctuation\">)</span>: train/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">1.2</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">9</span>/15<span class=\"token punctuation\">)</span>: train/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">465</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">10</span>/15<span class=\"token punctuation\">)</span>: updates/filelists_db                                                                                             <span class=\"token operator\">|</span> <span class=\"token number\">6.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">11</span>/15<span class=\"token punctuation\">)</span>: updates/primary_db                                                                                               <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">12</span>/15<span class=\"token punctuation\">)</span>: updates/other_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">914</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">13</span>/15<span class=\"token punctuation\">)</span>: virt/filelists_db                                                                                                <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">14</span>/15<span class=\"token punctuation\">)</span>: virt/other_db                                                                                                    <span class=\"token operator\">|</span>  <span class=\"token number\">45</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">15</span>/15<span class=\"token punctuation\">)</span>: virt/primary_db                                                                                                  <span class=\"token operator\">|</span>  <span class=\"token number\">56</span> kB  00:00:00\nMetadata Cache Created\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum repolist            # 3. 查看仓库列表</span>\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\nrepo <span class=\"token function\">id</span>                                                              repo name                                                             status\nbase                                                                 base                                                                  <span class=\"token number\">10,039</span>\nextras                                                               extras                                                                   <span class=\"token number\">500</span>\ntrain                                                                train                                                                  <span class=\"token number\">3,168</span>\nupdates                                                              updates                                                                <span class=\"token number\">3,182</span>\nvirt                                                                 virt                                                                      <span class=\"token number\">63</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>到目前为止<code>控制节点</code>的YUM源配置完毕，最后在<code>控制节点</code>上设置域名解析、关闭防火墙、安装FTP服务器为<code>计算节点</code>提供服务</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># hostnamectl set-hostname controller  # 1. 修改主机名</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<blockquote>\n<p>修改完主机名后<code>ctrl + D</code>退出当前会话重新登录验证主机名设置是否生效。</p>\n</blockquote>\n<ul>\n<li><p>在<code>/etc/hosts</code>文件最后添加以下两行域名解析</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">192.168.10.10 controller\n192.168.10.20 compute<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>修改<code>/etc/selinux/config</code>文件中的<code>SELINUX=enforcing</code>为<code>SELINUX=disabled</code></p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>禁用SELinux和防火墙</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># setenforce 0                   # 1. 禁用SELinux</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl disable firewalld    # 2. 关闭开机启动防火墙</span>\nRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\nRemoved symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl stop firewalld       # 3. 立即关闭防火墙</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum remove -y NetworkManager   # 4. 卸载网络管理器</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>安装配置deltarpm来兼容packstack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum -y install deltarpm</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/yum.conf</code>文件中加一行禁用deltarpm</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># echo \"deltarpm=0\" >>/etc/yum.conf</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>安装配置FTP服务端</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum -y install vsftpd       # 1. 安装ftp服务端</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/vsftpd/vsftpd.conf</code>文件中加入一行<code>anon_root=/opt</code>，设置匿名用户访问的根目录为YUM源所挂载的目录</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl start vsftpd      # 1. 立刻启动FTP服务端</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl enable vsftpd     # 2. 设置开机启动</span>\nCreated symlink from /etc/systemd/system/multi-user.target.wants/vsftpd.service to /usr/lib/systemd/system/vsftpd.service.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>配置<code>iptables</code>允许ftp服务的20&#x2F;21端口</p>\n<ol>\n<li><p>编辑文件 <code>/etc/sysconfig/iptables-config</code> ，设置第6行<code>IPTABLES_MODULES=</code>值为<code>ip_conntrack_ftp</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">IPTABLES_MODULES</span><span class=\"token operator\">=</span><span class=\"token string\">\"ip_conntrack_ftp\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>编辑文件<code>/etc/sysconfig/iptables</code>添加两行规则</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables -L</span>\n<span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># iptables-save > /etc/sysconfig/iptables</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>这一步配置<code>计算节点</code>的YUM源，通过FTP服务访问挂载到<code>控制节点</code>的源文件。</p>\n<ul>\n<li><p>修改<code>计算节点</code>的主机名</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># hostnamectl set-hostname compute  # 1. 修改主机名</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>在<code>/etc/hosts</code>文件最后添加以下两行域名解析</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">192.168.10.10 controller\n192.168.10.20 compute<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>修改<code>/etc/selinux/config</code>文件中的<code>SELINUX=enforcing</code>为<code>SELINUX=disabled</code></p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>禁用SELinux和防火墙</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># setenforce 0                   # 1. 禁用SELinux</span>\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl disable firewalld    # 2. 关闭开机启动防火墙</span>\nRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\nRemoved symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># systemctl stop firewalld       # 3. 立即关闭防火墙</span>\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum remove -y NetworkManager   # 4. 卸载网络管理器</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除已有配置文件</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># rm -rf /etc/yum.repos.d/*.repo</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/yum.repos.d</code>目录下创建配置文件<code>local.repo</code>，并添加以下配置：</p>\n <pre class=\"line-numbers language-text\" data-language=\"text\"><code class=\"language-text\">[base]\nname=base\nbaseurl=ftp://controller/openstack/base/\ngpgcheck=0\nenabled=1\n[extras]\nname=extras\nbaseurl=ftp://controller/openstack/extras/\ngpgcheck=0\nenabled=1\n[updates]\nname=updates\nbaseurl=ftp://controller/openstack/updates/\ngpgcheck=0\nenabled=1\n[train]\nname=train\nbaseurl=ftp://controller/openstack/train/\ngpgcheck=0\nenabled=1\n[virt]\nname=virt\nbaseurl=ftp://controller/openstack/virt/\ngpgcheck=0\nenabled=1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>执行以下命令检查YUM源是否可用：</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum clean all           # 1. 清除缓存</span>\nLoaded plugins: fastestmirror\nCleaning repos: base extras train updates virt\nRepository base is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository extras is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository updates is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nCleaning up list of fastest mirrors\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum makecache         # 2. 重建缓存</span>\nLoaded plugins: fastestmirror\nRepository base is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository extras is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nRepository updates is listed <span class=\"token function\">more</span> than once <span class=\"token keyword\">in</span> the configuration\nDetermining fastest mirrors\n* base: mirrors.aliyun.com\n* extras: mirrors.aliyun.com\n* updates: mirrors.aliyun.com\nbase                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">3.6</span> kB  00:00:00\nextras                                                                                                                    <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\ntrain                                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nupdates                                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\nvirt                                                                                                                      <span class=\"token operator\">|</span> <span class=\"token number\">2.9</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">1</span>/15<span class=\"token punctuation\">)</span>: base/primary_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">6.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">2</span>/15<span class=\"token punctuation\">)</span>: base/filelists_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">7.0</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">3</span>/15<span class=\"token punctuation\">)</span>: base/other_db                                                                                                     <span class=\"token operator\">|</span> <span class=\"token number\">2.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">4</span>/15<span class=\"token punctuation\">)</span>: extras/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">259</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">5</span>/15<span class=\"token punctuation\">)</span>: extras/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">145</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">6</span>/15<span class=\"token punctuation\">)</span>: extras/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">241</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">7</span>/15<span class=\"token punctuation\">)</span>: train/filelists_db                                                                                               <span class=\"token operator\">|</span> <span class=\"token number\">3.6</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">8</span>/15<span class=\"token punctuation\">)</span>: train/primary_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">1.2</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">9</span>/15<span class=\"token punctuation\">)</span>: train/other_db                                                                                                   <span class=\"token operator\">|</span> <span class=\"token number\">465</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">10</span>/15<span class=\"token punctuation\">)</span>: updates/filelists_db                                                                                             <span class=\"token operator\">|</span> <span class=\"token number\">6.5</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">11</span>/15<span class=\"token punctuation\">)</span>: updates/primary_db                                                                                               <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> MB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">12</span>/15<span class=\"token punctuation\">)</span>: updates/other_db                                                                                                 <span class=\"token operator\">|</span> <span class=\"token number\">914</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">13</span>/15<span class=\"token punctuation\">)</span>: virt/filelists_db                                                                                                <span class=\"token operator\">|</span>  <span class=\"token number\">14</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">14</span>/15<span class=\"token punctuation\">)</span>: virt/other_db                                                                                                    <span class=\"token operator\">|</span>  <span class=\"token number\">45</span> kB  00:00:00\n<span class=\"token punctuation\">(</span><span class=\"token number\">15</span>/15<span class=\"token punctuation\">)</span>: virt/primary_db                                                                                                  <span class=\"token operator\">|</span>  <span class=\"token number\">56</span> kB  00:00:00\nMetadata Cache Created\n<span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum repolist          # 3. 查看仓库列表</span>\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\nrepo <span class=\"token function\">id</span>                                                              repo name                                                             status\nbase                                                                 base                                                                  <span class=\"token number\">10,039</span>\nextras                                                               extras                                                                   <span class=\"token number\">500</span>\ntrain                                                                train                                                                  <span class=\"token number\">3,168</span>\nupdates                                                              updates                                                                <span class=\"token number\">3,182</span>\nvirt                                                                 virt                                                                      <span class=\"token number\">63</span>\nrepolist: <span class=\"token number\">17,906</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>安装配置deltarpm来兼容packstack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum -y install deltarpm</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 在<code>/etc/yum.conf</code>文件中加一行禁用deltarpm</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@compute ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># echo \"deltarpm=0\" >>/etc/yum.conf</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"安装OpenStack平台\"><a href=\"#安装OpenStack平台\" class=\"headerlink\" title=\"安装OpenStack平台\"></a>安装OpenStack平台</h3><ul>\n<li><p>在控制节点安装packstack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># yum install -y openstack-packstack</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>生成配置文件</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># packstack --gen-answer-file=openstack.txt --os-neutron-l2-agent=openvswitch --os-neutron-ml2-mechanism-drivers=openvswitch --os-neutron-ml2-tenant-network-types=vxlan --os-neutron-ml2-type-drivers=vxlan,flat --provision-demo=n --os-neutron-ovs-bridge-mappings=extnet:br-ex --os-neutron-ovs-bridge-interfaces=br-ex:ens34</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>修改配置文件中的IP地址为内网IP</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/192.168.20.10/192.168.10.10/g' openstack.txt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> 修改文件<code>openstack.txt</code>中计算机点的IP</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@controller ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># sed -i 's/CONFIG_COMPUTE_HOSTS=.*/CONFIG_COMPUTE_HOSTS=192.168.10.20/g' openstack.txt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>开始安装OpenStack</p>\n <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">packstack --answer-file<span class=\"token operator\">=</span>openstack.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p> packstack运行结束后如下图</p>\n<p> <img src=\"https://raw.githubusercontent.com/yefreee/picture/main/note1.%E5%88%9D%E8%AF%86%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8EOpenstack-2023-08-31-01-28-23.png\" alt=\"1.初识云计算与Openstack-2023-08-31-01-28-23\"></p>\n</li>\n<li><p>登录OpenStack平台</p>\n<p> 接下来可以通过预先配置的网址<a href=\"http://192.168.10.10/dashboard\">http://192.168.10.10/dashboard</a>访问OpenStack平台</p>\n<p> 账户信息通过<code>cat keystonerc_admin</code>查看</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}